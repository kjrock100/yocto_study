Table of Contents

1 The Yocto Project Development Tasks Manual
1.1 Welcome
1.2 Other Information

2 Setting Up to Use the Yocto Project
2.1 Creating a Team Development Environment
2.2 Preparing the Build Host
2.2.1 Setting Up a Native Linux Host
2.2.2 Setting Up to Use CROss PlatformS (CROPS)
2.2.3 Setting Up to Use Windows Subsystem For Linux (WSL 2)
2.3 Locating Yocto Project Source Files
2.3.1 Accessing Source Repositories
2.3.2 Accessing Source Archives
2.3.3 Using the Downloads Page
2.4 Cloning and Checking Out Branches
2.4.1 Cloning the poky Repository
2.4.2 Checking Out by Branch in Poky
2.4.3 Checking Out by Tag in Poky
2.5 Initializing the Build Environment

3 Understanding and Creating Layers
3.1 Creating Your Own Layer
3.2 Following Best Practices When Creating Layers
3.3 Making Sure Your Layer is Compatible With Yocto Project
3.3.1 Yocto Project Compatible Program Application
3.3.2 yocto-check-layer Script
3.4 Enabling Your Layer
3.5 Appending Other Layers Metadata With Your Layer
3.5.1 Overlaying a File Using Your Layer
3.5.2 Installing Additional Files Using Your Layer
3.6 Prioritizing Your Layer
3.6.1 Providing Global-level Configurations With Your Layer
3.6.1.1 Conditionally Provide Global-level Configurations With Your Layer
3.7 Managing Layers
3.8 Creating a General Layer Using the bitbake-layers Script
3.9 Adding a Layer Using the bitbake-layers Script
3.10 Saving and restoring the layers setup

4 Customizing Images
4.1 Customizing Images Using local.conf
4.2 Customizing Images Using Custom IMAGE_FEATURES and EXTRA_IMAGE_FEATURES
4.3 Customizing Images Using Custom .bb Files
4.4 Customizing Images Using Custom Package Groups
4.5 Customizing an Image Hostname

5 Writing a New Recipe
5.1 Overview
5.2 Locate or Automatically Create a Base Recipe
5.2.1 Creating the Base Recipe Using devtool add
5.2.2 Creating the Base Recipe Using recipetool create
5.2.3 Locating and Using a Similar Recipe
5.3 Storing and Naming the Recipe
5.4 Running a Build on the Recipe
5.5 Fetching Code
5.5.1 Fetching Code Through Firewalls
5.5.2 Limiting the Number of Parallel Connections
5.6 Unpacking Code
5.7 Patching Code
5.8 Licensing
5.9 Dependencies
5.10 Configuring the Recipe
5.11 Using Headers to Interface with Devices
5.12 Compilation
5.13 Installing
5.14 Enabling System Services
5.15 Packaging
5.16 Sharing Files Between Recipes
5.17 Using Virtual Providers
5.18 Properly Versioning Pre-Release Recipes
5.19 Post-Installation Scripts
5.20 Testing
5.21 Examples
5.21.1 Building a Single .c File Package
5.21.2 Building a Makefile-Based Package
5.21.3 Building an Autotooled Package
5.21.4 Building a Meson Package
5.21.5 Splitting an Application into Multiple Packages
5.21.6 Packaging Externally Produced Binaries
5.22 Following Recipe Style Guidelines
5.23 Recipe Syntax

6 Adding a New Machine
6.1 Adding the Machine Configuration File
6.2 Adding a Kernel for the Machine
6.3 Adding a Formfactor Configuration File

7 Upgrading Recipes
7.1 Using the Auto Upgrade Helper (AUH)
7.2 Using devtool upgrade
7.3 Manually Upgrading a Recipe

8 Finding Temporary Source Code

9 Creating New Configuration Fragments In Your Build
9.1 Creating A Standard Configuration Fragment
9.2 Creating A Built-in Fragment

10 Setting Up the Poky Reference Distro Manually
10.1 Use Git to Clone The Layers
10.2 Building Your Image

11 Using Quilt in Your Workflow

12 Using a Development Shell

13 Using a Python Development Shell

14 Building
14.1 Building a Simple Image
14.2 Building Images for Multiple Targets Using Multiple Configurations
14.3 Building an Initial RAM Filesystem (Initramfs) Image
14.3.1 Customizing an Initramfs using initramfs-framework
14.3.2 Bundling an Initramfs Image From a Separate Multiconfig
14.4 Building a Tiny System
14.4.1 Tiny System Overview
14.4.2 Goals and Guiding Principles
14.4.3 Understand What Contributes to Your Image Size
14.4.4 Trim the Root Filesystem
14.4.5 Trim the Kernel
14.4.6 Remove Package Management Requirements
14.4.7 Look for Other Ways to Minimize Size
14.4.8 Iterate on the Process
14.5 Building Images for More than One Machine
14.6 Building Software from an External Source
14.7 Replicating a Build Offline

15 Building Images for Multiple Targets With Multiconfig
15.1 Setting Up and Running a Multiple Configuration Build
15.2 Enabling Multiple Configuration Build Dependencies
15.3 Suggested best practices
15.4 Common use case: building baremetal firmware alongside a Linux build
15.4.1 Adding a multiconfig configuration file and recipe for a baremetal firmware
15.4.2 Building the firmware
15.4.3 Using the output of my-firmware

16 Speeding Up a Build

17 Limiting the Host Resources Usage

18 Working With Libraries
18.1 Including Static Library Files
18.2 Combining Multiple Versions of Library Files into One Image
18.2.1 Preparing to Use Multilib
18.2.2 Using Multilib
18.2.3 Additional Implementation Details
18.3 Installing Multiple Versions of the Same Library

19 Working with Pre-Built Libraries
19.1 Introduction
19.2 Versioned Libraries
19.3 Non-Versioned Libraries
19.3.1 Some Background
19.3.2 Yocto Library Packaging Overview
19.3.3 Example

20 Using the devtool command-line tool
20.1 Use devtool add to Add an Application
20.2 Use devtool modify to Modify the Source of an Existing Component
20.3 devtool ide-sdk configures IDEs and bootstraps SDKs
20.4 Use devtool upgrade to Create a Version of the Recipe that Supports a Newer Version of the Software
20.5 A Closer Look at devtool add
20.5.1 Name and Version
20.5.2 Dependency Detection and Mapping
20.5.3 License Detection
20.5.4 Adding Makefile-Only Software
20.5.5 Adding Native Tools
20.5.6 Adding Node.js Modules
20.6 Working With Recipes
20.6.1 Finding Logs and Work Files
20.6.2 Setting Configure Arguments
20.6.3 Sharing Files Between Recipes
20.6.4 Packaging
20.7 Restoring the Target Device to its Original State

21 Using x32 psABI

22 Enabling GObject Introspection Support
22.1 Enabling the Generation of Introspection Data
22.2 Disabling the Generation of Introspection Data
22.3 Testing that Introspection Works in an Image
22.4 Known Issues

23 Optionally Using an External Toolchain

24 Creating Partitioned Images Using Wic
24.1 Background
24.2 Requirements
24.3 Getting Help
24.4 Operational Modes
24.4.1 Raw Mode
24.4.2 Cooked Mode
24.5 Using an Existing Kickstart File
24.6 Using the Wic Plugin Interface
24.7 Wic Examples
24.7.1 Generate an Image using an Existing Kickstart File
24.7.2 Using a Modified Kickstart File
24.7.3 Using a Modified Kickstart File and Running in Raw Mode
24.7.4 Using Wic to Manipulate an Image

25 Flashing Images Using bmaptool

26 Making Images More Secure
26.1 General Considerations
26.2 Security Flags
26.3 Considerations Specific to the OpenEmbedded Build System
26.4 Tools for Hardening Your Image

27 Creating Your Own Distribution
27.1 Copying and modifying the Poky distribution

28 Creating a Custom Template Configuration Directory

29 Conserving Disk Space
29.1 Conserving Disk Space During Builds
29.2 Purging Obsolete Shared State Cache Files

30 Working with Packages
30.1 Excluding Packages from an Image
30.2 Incrementing a Package Version
30.2.1 Working With a PR Service
30.2.2 Manually Bumping PR
30.2.3 Automatically Incrementing a Package Version Number
30.3 Handling Optional Module Packaging
30.3.1 Making Sure the Packaging is Done
30.3.2 Satisfying Dependencies
30.4 Using Runtime Package Management
30.4.1 Build Considerations
30.4.2 Host or Server Machine Setup
30.4.3 Target Setup
30.4.3.1 Using RPM
30.4.3.2 Using IPK
30.4.3.3 Using DEB
30.5 Generating and Using Signed Packages
30.5.1 Signing RPM Packages
30.5.2 Processing Package Feeds
30.6 Testing Packages With ptest
30.7 Creating Node Package Manager (NPM) Packages
30.7.1 Requirements and Caveats
30.7.2 Using the Registry Modules Method
30.7.3 Using the NPM Projects Code Method
30.8 Adding custom metadata to packages

31 Efficiently Fetching Source Files During a Build
31.1 Setting up Effective Mirrors
31.2 Getting Source Files and Suppressing the Build

32 Selecting an Initialization Manager
32.1 Using SysVinit with udev
32.2 Using BusyBox init with BusyBox mdev
32.3 Using systemd
32.3.1 Controling systemd from the target command line
32.3.2 Using systemd-journald without a traditional syslog daemon
32.3.3 Summary

33 Selecting a Device Manager
33.1 Using Persistent and Pre-Populated /dev
33.2 Using devtmpfs and a Device Manager

34 Using an External SCM

35 Creating a Read-Only Root Filesystem
35.1 Creating the Root Filesystem
35.2 Post-Installation Scripts and Read-Only Root Filesystem
35.3 Areas With Write Access

36 Maintaining Build Output Quality
36.1 Enabling and Disabling Build History
36.2 Understanding What the Build History Contains
36.2.1 Build History Package Information
36.2.2 Build History Image Information
36.2.3 Using Build History to Gather Image Information Only
36.2.4 Build History SDK Information
36.2.5 Examining Build History Information

37 Debugging Tools and Techniques
37.1 Viewing Logs from Failed Tasks
37.2 Viewing Variable Values
37.3 Viewing Package Information with oe-pkgdata-util
37.4 Viewing Dependencies Between Recipes and Tasks
37.5 Viewing Task Variable Dependencies
37.6 Debugging signature construction and unexpected task executions
37.7 Viewing Metadata Used to Create the Input Signature of a Shared State Task
37.8 Invalidating Shared State to Force a Task to Run
37.9 Running Specific Tasks
37.10 General BitBake Problems
37.11 Building with No Dependencies
37.12 Recipe Logging Mechanisms
37.12.1 Logging With Python
37.12.2 Logging With Bash
37.13 Debugging Parallel Make Races
37.13.1 The Failure
37.13.2 Reproducing the Error
37.13.3 Creating a Patch for the Fix
37.13.4 Testing the Build
37.14 Debugging With the GNU Project Debugger (GDB) Remotely
37.14.1 Using the debuginfod server method
37.14.2 Using the gdbserver method
37.15 Debugging with the GNU Project Debugger (GDB) on the Target
37.16 Enabling Minidebuginfo
37.17 Other Debugging Tips

38 Working With Licenses
38.1 Tracking License Changes
38.1.1 Specifying the LIC_FILES_CHKSUM Variable
38.1.2 Explanation of Syntax
38.2 Enabling Commercially Licensed Recipes
38.2.1 License Flag Matching
38.2.2 Other Variables Related to Commercial Licenses
38.3 Maintaining Open Source License Compliance During Your Productâ€™s Lifecycle
38.3.1 Providing the Source Code
38.3.2 Providing License Text
38.3.3 Providing Compilation Scripts and Source Code Modifications
38.3.4 Compliance Limitations with Executables Built from Static Libraries
38.4 Copying Non Standard Licenses

39 Dealing with Vulnerability Reports
39.1 How to report a potential security vulnerability?
39.1.1 Branches maintained with security fixes
39.1.2 Security-related discussions at the Yocto Project
39.1.3 What you should do if you find a security vulnerability
39.2 Security team
39.2.1 Security team appointment
39.2.2 Security Team Operations
39.2.3 What Yocto Security Team does when it receives a security vulnerability
39.2.4 If an upstream project does not respond quickly
39.2.5 Current Security Team members

40 Checking for Vulnerabilities
40.1 Vulnerabilities in Poky and OE-Core
40.2 Vulnerability check at build time
40.3 Fixing CVE product name and version mappings
40.4 Fixing vulnerabilities in recipes
40.5 Implementation details
40.6 Linux kernel vulnerabilities
40.6.1 generate-cve-exclusions.py
40.6.2 improve_kernel_cve_report.py

41 Creating a Software Bill of Materials

42 Using the Error Reporting Tool
42.1 Enabling and Using the Tool
42.2 Disabling the Tool
42.3 Setting Up Your Own Error Reporting Server

43 Using Wayland and Weston
43.1 Enabling Wayland in an Image
43.1.1 Building Wayland
43.1.2 Installing Wayland and Weston
43.2 Running Weston

44 Using the Quick EMUlator (QEMU)
44.1 Overview
44.2 Running QEMU
44.3 Switching Between Consoles
44.4 Removing the Splash Screen
44.5 Disabling the Cursor Grab
44.6 Running Under a Network File System (NFS) Server
44.7 QEMU CPU Compatibility Under KVM
44.8 QEMU Performance
44.9 QEMU Command-Line Syntax
44.10 runqemu Command-Line Options

45 Locking and Unlocking Recipes Using bblock
45.1 Locking tasks and recipes
45.2 Unlocking tasks and recipes
45.3 Configuration file
45.4 Locking mechanism
45.5 Example

46 Setting up a Hash Equivalence Server
46.1 Hash Equivalence Server Setup
46.2 Yocto Project Build Setup

