# Yocto Project 해시 동등성 (Hash Equivalence)

**해시 동등성(Hash Equivalence)**은 Yocto Project 빌드 시스템에서 불필요한 재빌드를 줄이고 공유 상태 캐시(Shared State Cache)의 재사용률을 극대화하기 위한 고급 기능입니다.

## 1. 개요

기존의 BitBake는 태스크의 입력(변수, 의존성 등)이 조금이라도 바뀌면 해당 태스크와 그에 의존하는 모든 하위 태스크를 다시 빌드했습니다. 하지만 입력이 바뀌었더라도 실제 생성된 출력물(바이너리 등)이 이전과 동일한 경우가 많습니다.

해시 동등성은 **"입력이 달라도 출력이 같다면, 하위 태스크들에게는 변경이 없는 것으로 간주하자"**는 개념입니다.

## 2. 문제 배경: 연쇄 재빌드 (Cascading Rebuilds)

예를 들어, `glibc` 레시피의 주석을 한 줄 수정했다고 가정해 봅시다.
1.  `glibc`의 체크섬(Signature)이 변경됩니다.
2.  `glibc`가 다시 컴파일됩니다.
3.  `glibc`에 의존하는 수많은 패키지들(사실상 시스템 전체)의 입력 체크섬도 변경됩니다.
4.  결과적으로 시스템 전체가 다시 빌드됩니다.

하지만 주석만 바뀐 `glibc`의 컴파일 결과물(라이브러리 바이너리)은 이전과 **완벽하게 동일**합니다. 이 경우 하위 패키지들을 다시 빌드하는 것은 자원 낭비입니다.

## 3. 작동 원리

해시 동등성은 **Hash Equivalence Server**를 통해 작동합니다.

1.  **태스크 실행:** 태스크가 실행되고 결과물(Output)이 생성됩니다.
2.  **출력 해시 계산 (Outhash):** 생성된 결과물의 내용을 기반으로 해시를 계산합니다.
3.  **서버 조회 및 등록:**
    *   서버에 "이 입력 해시(Taskhash)가 이 출력 해시(Outhash)를 만들었다"고 보고합니다.
    *   서버는 "이전에 다른 입력 해시가 동일한 출력 해시를 만든 적이 있는지" 확인합니다.
4.  **동등성 매핑 (Unihash):**
    *   만약 동일한 출력을 만든 적이 있다면, 현재의 입력 해시를 기존의 **통일된 해시(Unihash)**와 동등하다고 매핑합니다.
5.  **하위 태스크 보호:**
    *   하위 태스크는 의존성의 Taskhash 대신 Unihash를 사용하여 자신의 입력을 계산합니다.
    *   Unihash가 변하지 않았으므로, 하위 태스크의 체크섬도 유지되고 재빌드가 발생하지 않습니다.

## 4. 설정 방법

최신 Yocto Project 버전(Poky)에서는 기본적으로 활성화되어 있거나 쉽게 켤 수 있습니다. `conf/local.conf` 파일에서 다음 변수를 확인하십시오.

```bitbake
# Hash Equivalence Server를 로컬에서 자동으로 시작
BB_HASHSERVE = "auto"

# 서명 핸들러를 해시 동등성 지원 모드로 설정 (기본값일 수 있음)
BB_SIGNATURE_HANDLER = "OEEquivHash"
```

## 5. 요약

해시 동등성은 빌드 정확성을 해치지 않으면서도, 실질적인 변경이 없는 경우 불필요한 빌드 시간을 획기적으로 단축시켜 주는 최적화 기술입니다.
