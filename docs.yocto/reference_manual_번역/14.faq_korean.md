# 14. FAQ (자주 묻는 질문)

Yocto 프로젝트를 사용할 때 자주 묻는 질문들과 그 답변을 정리했습니다.

## 14.1 일반적인 질문

### 14.1.1 Poky와 OpenEmbedded는 어떻게 다릅니까?

`Poky`라는 용어는 Yocto 프로젝트에서 제공하는 특정한 참조 빌드 시스템을 나타냅니다. Poky는 OpenEmbedded-Core (OE-Core)와 BitBake를 기반으로 합니다. 따라서 빌드 시스템의 일반적인 용어는 "OpenEmbedded 빌드 시스템"입니다.

Yocto 프로젝트를 사용한 개발은 OpenEmbedded와 밀접하게 연관되어 있으며, 모든 변경사항은 먼저 OE-Core나 BitBake에 병합된 후 다시 Poky로 가져옵니다. 이러한 관행은 두 프로젝트 모두에게 즉시 이점을 제공합니다.

### 14.1.2 Poky / OpenEmbedded-Core가 안정적이라고 어떻게 주장할 수 있습니까?

안정성을 도와주는 세 가지 영역이 있습니다:

1. **최소화된 구성**: Yocto 프로젝트 팀은 OpenEmbedded-Core (OE-Core)를 작고 초점이 맞춰진 상태로 유지합니다. 다른 OpenEmbedded 커뮤니티 레이어의 수천 개 레시피와 비교하면, OE-Core는 약 830개의 레시피를 포함합니다. 작은 규모로 인해 테스트와 유지보수가 용이합니다.

2. **광범위한 테스트**: Yocto 프로젝트 팀은 작은 고정 세트의 참조 하드웨어와 에뮬레이션 대상을 사용하여 수동 및 자동화된 테스트를 실행합니다.

3. **자동화된 빌드**: Yocto 프로젝트는 자동빌더(autobuilder)를 사용하여 지속적인 빌드 및 통합 테스트를 수행합니다.

### 14.1.3 OpenEmbedded 빌드 시스템을 사용하여 만들어진 제품이 있습니까?

[Yocto 프로젝트 위키의 Products that use the Yocto Project](https://wiki.yoctoproject.org/wiki/Project_Users#Products_that_use_the_Yocto_Project) 페이지를 참고하세요. 다른 제품을 알고 있다면 이 페이지에 기여하세요.

### 14.1.4 OpenEmbedded-Core/Yocto Project 또는 Poky에서 systemd가 기본 init 시스템이 아닌 이유는 무엇입니까?

systemd는 커스터마이징 가능한 "임베디드" 빌드 시스템/환경의 목표와 완전히 일치하지 않는 특정 초점이 있는 데스크톱 Linux init 시스템입니다.

systemd는 OpenEmbedded-Core (OE-Core) 또는 Yocto 프로젝트의 목표와 방향과 일치하거나 일치하지 않을 수 있는 특정 레이아웃과 설정을 의무화합니다. 또한 모든 대상을 지원하지 않습니다. 예를 들어, systemd의 musl 지원은 문제가 있습니다.

기본값이 되려면 모든 선택에 맞춰야 하는데, 이는 의미가 없습니다. 따라서 systemd는 설정 옵션이며 설계 목표가 일치하는 경우 누구든 사용할 수 있습니다. 하지만 init을 처리하는 유일한 방법이 아님을 명확히 합니다.

## 14.2 빌드 환경

### 14.2.1 개발 시스템에 필수 의존성이 없습니다?

개발 시스템이 필수 Git, tar, Python 버전을 충족하지 않으면 다양한 방법으로 호스트 개발 시스템에서 필수 도구를 얻을 수 있습니다 (예: 타르볼 빌드 또는 타르볼 다운로드). "[필수 Git, tar, Python, make 및 gcc 버전](https://docs.yoctoproject.org/ref-manual/system-requirements.html#required-git-tar-python-make-and-gcc-versions)" 섹션에서 빌드 도구를 업데이트하는 방법을 참고하세요.

### 14.2.2 OpenEmbedded는 어떻게 소스 코드를 가져옵니까? 방화벽이나 프록시 서버를 통해 작동합니까?

빌드 시스템이 소스 코드를 얻는 방식은 매우 설정 가능합니다. HTTP 전송이 가능하면 대부분의 환경에서 소스 코드를 얻도록 빌드 시스템을 설정할 수 있습니다.

빌드 시스템이 소스 코드를 검색할 때, 먼저 로컬 다운로드 디렉토리를 시도합니다. 그 위치가 실패하면, Poky는 다음 순서로 PREMIRRORS, 업스트림 소스, MIRRORS를 시도합니다.

배포판이 "poky"라고 가정하면, OpenEmbedded 빌드 시스템은 SCM 기반 소스의 경우 기본적으로 Yocto 프로젝트 소스 PREMIRRORS를 사용하고, 일반 타르볼의 경우 업스트림을 사용하며, 실패하면 Yocto 프로젝트 소스 미러를 포함한 다른 여러 미러로 돌아갑니다.

#### 소스 미러 설정 예제

`local.conf` 설정 파일에 다음과 같은 내용을 추가하여 다른 모든 것보다 먼저 시도할 특정 서버를 추가할 수 있습니다:

```
PREMIRRORS:prepend = "\
    git://.*/.* https://downloads.yoctoproject.org/mirror/sources/ \
    ftp://.*/.* https://downloads.yoctoproject.org/mirror/sources/ \
    http://.*/.* https://downloads.yoctoproject.org/mirror/sources/ \
    https://.*/.* https://downloads.yoctoproject.org/mirror/sources/"
```

이러한 변경은 빌드 시스템이 Git, FTP, HTTP, HTTPS 요청을 가로채고 `http://` 소스 미러로 리다이렉트하게 합니다. `file://` URL을 사용하여 로컬 디렉토리 또는 네트워크 공유를 가리킬 수도 있습니다.

#### 네트워크 제한 옵션

- **BB_NO_NETWORK = "1"**: BitBake가 인터넷 액세스를 시도하는 대신 오류를 발생시키도록 합니다. 코드가 로컬 소스에서만 빌드되도록 하려는 경우 유용합니다.

- **BB_FETCH_PREMIRRORONLY = "1"**: 빌드 시스템이 PREMIRRORS에서만 소스를 가져오도록 제한합니다. 빌드 재현을 위해 유용합니다.

- **BB_GENERATE_MIRROR_TARBALLS = "1"**: 빌드 시스템이 미러 타르볼을 생성하도록 합니다. 미러 서버를 만들려는 경우 유용하지만, 그렇지 않으면 빌드 중 시간을 낭비할 수 있습니다.

#### 방화벽 및 프록시 설정

HTTP 전용 방화벽 뒤에 있는 경우, PREMIRRORS 서버가 최신 상태라면 `local.conf` 설정 파일을 다음과 같이 변경할 수 있습니다:

```
PREMIRRORS:prepend = "\
    git://.*/.* https://downloads.yoctoproject.org/mirror/sources/ \
    ftp://.*/.* https://downloads.yoctoproject.org/mirror/sources/ \
    http://.*/.* https://downloads.yoctoproject.org/mirror/sources/ \
    https://.*/.* https://downloads.yoctoproject.org/mirror/sources/"
BB_FETCH_PREMIRRORONLY = "1"
```

대부분의 소스 페칭은 `wget`을 통해 수행되므로 프록시 설정을 `.wgetrc` 파일에서 지정해야 합니다. 이 파일은 단일 사용자인 경우 홈 디렉토리에 있거나 글로벌 사용자 파일로 `/usr/local/etc/wgetrc`에 있을 수 있습니다.

## 14.3 OpenEmbedded 빌드 시스템 사용

### 14.3.1 외부 툴체인을 어떻게 사용합니까?

개발 작업 설명서의 "[외부 툴체인 선택적 사용](https://docs.yoctoproject.org/dev-manual/external-toolchain.html#optionally-using-an-external-toolchain)" 섹션을 참고하세요.

### 14.3.2 chmod 권한 문제가 발생합니다?

`chmod: XXXXX new permissions are r-xrwxrwx, not r-xr-xr-x` 오류가 나타나면, NTFS 파일시스템에서 빌드를 실행하고 있을 가능성이 있습니다. 대신 `ext4`, `btrfs`, `xfs`와 같은 최신 Linux 파일시스템이 있는 파티션에서 빌드 시스템을 실행하세요.

### 14.3.3 소스를 다운로드하려고 할 때 많은 404 오류가 보입니다. 뭔가 잘못되었습니까?

아무것도 잘못되지 않았습니다. OpenEmbedded 빌드 시스템은 업스트림 소스에서 다운로드하기 전에 설정된 소스 미러를 확인합니다. 빌드 시스템은 소스 아카이브와 SCM으로 관리되는 소프트웨어의 미리 체크아웃된 버전 모두를 검색합니다. 이 확인은 SCM 서버 자체의 부하를 줄일 수 있으므로 대규모 설치에 도움이 됩니다. 또한 업스트림 소스가 사라지면 빌드가 계속 작동할 수 있습니다.

### 14.3.4 왜 무작위로 빌드 실패가 발생합니까?

동일한 빌드가 완전히 다른 방식으로 무작위적으로 실패하는 경우, 가장 가능성이 높은 설명은:

- 빌드를 실행 중인 하드웨어에 문제가 있습니다.
- 가상화 하에서 빌드를 실행하고 있으며, 이 경우 가상화에 버그가 있을 가능성이 있습니다.

OpenEmbedded 빌드 시스템은 많은 네트워크, 디스크, CPU 활동을 유발하는 엄청난 양의 데이터를 처리하며 이러한 영역의 단일 비트 실패에도 민감합니다. 진정한 무작위 실패는 항상 하드웨어 또는 가상화 문제로 추적되었습니다.

### 14.3.5 `iconv.h` 문제로 인해 빌드가 실패하는 이유는 무엇입니까?

네이티브 레시피를 빌드하려고 할 때, GNU `libiconv`가 사용되지 않지만 `libiconv`에서 `iconv.h`가 포함되었음을 나타내는 오류 메시지가 표시될 수 있습니다:

```
#error GNU libiconv not in use but included iconv.h is from libiconv
```

이런 일이 발생하면 `/usr/local/include/`에 이전에 설치된 헤더 파일 버전이 있는지 확인해야 합니다. 그렇다면 제거하거나 임시로 이름을 바꾼 후 빌드를 다시 시도해야 합니다.

이 문제는 OpenEmbedded 빌드 시스템이 네이티브 빌드 중에 이전에 설치된 파일을 찾아 사용할 때 발생하는 "시스템 누수" 문제의 한 가지 표현일 뿐입니다. 이 유형의 문제는 `iconv.h`에 국한되지 않을 수 있습니다. `/usr/local/include`와 `/opt` 위치에서 누수가 발생하지 않도록 확인하세요.

### 14.3.6 다른 레시피가 내 `*-native` 레시피에서 제공하는 파일을 찾지 못하는 이유는 무엇입니까?

네이티브 레시피에서 제공하는 파일이 네이티브 sysroot에서 누락되었거나, 레시피가 잘못된 위치에 설치될 수 있으며, 또는 레시피의 `do_install` 작업 중에 권한 오류가 발생할 수 있습니다.

이 상황은 패키지에서 사용하는 빌드 시스템이 BitBake에서 제공하는 환경 변수를 인식하지 못할 때 발생합니다. 이 FAQ 항목을 촉발한 사건은 더 표준적인 변수 `bindir` 대신 `BINDIR`이라는 환경 변수를 사용한 Makefile과 관련이 있었습니다. 대부분의 경우 Makefile의 하드코딩된 기본값 "/usr/bin"이 작동했지만 레시피의 `-native` 변형에서는 작동하지 않았습니다. 다른 예로, 권한 오류는 `DESTDIR`을 무시하거나 해당 환경 변수에 다른 이름을 사용하는 Makefile로 인해 발생할 수 있습니다. 패키지의 빌드 시스템을 확인하여 이러한 종류의 문제가 존재하는지 확인하세요.

### 14.3.7 빌드 출력을 제거하고 다시 시작할 수 있습니까?

예, 쉽게 할 수 있습니다. BitBake를 사용하여 이미지를 빌드할 때, 모든 빌드 출력은 빌드 환경 설정 스크립트를 실행할 때 생성되는 디렉토리에 저장됩니다 (예: oe-init-build-env). 기본적으로 이 빌드 디렉토리는 `build`라는 이름이지만 원하는 모든 이름으로 지정할 수 있습니다.

빌드 디렉토리 내에는 `tmp` 디렉토리가 있습니다. 모든 빌드 출력을 제거하되 이전 빌드의 소스 코드나 다운로드된 파일을 보존하려면 `tmp` 디렉토리만 제거하면 됩니다.

### 14.3.8 레시피의 bbappend처럼 bbclass 파일을 추가할 수 있는 방법이 없는 이유는 무엇입니까?

Yocto 프로젝트는 의도적으로 이러한 기능을 구현하지 않기로 선택했습니다. 클래스 코드는 공유되고 재사용되도록 설계되었으며 사용자에게 일정 수준의 설정을 노출합니다. 이러한 변경 사항을 공유하도록 사람들을 장려하는 것을 원합니다.

클래스에 `append` 기능이 있었다면, 우리의 증거와 경험에 따르면 사람들은 문제나 제한 사항을 공유하고 논의하는 대신 자신의 레이어에서 사용자 정의 변경을 만들 것입니다. 이는 새 레이어가 포함될 때 이상한 클래스 상호작용을 초래합니다. 따라서 우리는 의도적으로 클래스 코드 개선 사항이나 수정 사항을 공유하는 자연스러운 압력을 갖도록 선택합니다.

또한 클래스 추가가 어떤 레시피에 적용될지, 레이어 모델에 어떻게 맞을지와 같은 기술적 고려사항도 있습니다. 이는 우리가 없이도 살 수 있다고 생각하는 복잡성입니다!

## 14.4 생성된 이미지 커스터마이징

### 14.4.1 OpenEmbedded 빌드 시스템이 출력으로 생성하는 것은 무엇입니까?

동일한 레시피 세트를 사용하여 다양한 형식의 출력을 생성할 수 있으므로, OpenEmbedded 빌드의 출력은 시작 방법에 따라 다릅니다. 일반적으로 출력은 대상 장치에 플래시할 준비가 된 이미지입니다.

### 14.4.2 Yocto 프로젝트에서 내 보드를 지원하도록 하려면 어떻게 합니까?

추가 보드에 대한 지원은 보드 지원 패키지 (BSP) 레이어를 생성하여 추가됩니다. BSP 레이어를 생성하는 방법에 대한 자세한 내용은 Yocto 프로젝트 개발 작업 설명서의 "[레이어 이해 및 생성](https://docs.yoctoproject.org/dev-manual/layers.html#understanding-and-creating-layers)" 섹션과 [Yocto 프로젝트 Board Support Package 개발자 가이드](https://docs.yoctoproject.org/bsp-guide/index.html)를 참고하세요.

일반적으로 보드가 완전히 특이한 것이 아니라면, Yocto 프로젝트에 지원을 추가하는 것은 매우 간단합니다.

### 14.4.3 Yocto 프로젝트에서 내 패키지를 지원하도록 하려면 어떻게 합니까?

패키지를 추가하려면 BitBake 레시피를 생성해야 합니다. BitBake 레시피를 생성하는 방법에 대한 정보는 Yocto 프로젝트 개발 작업 설명서의 "[새 레시피 작성](https://docs.yoctoproject.org/dev-manual/new-recipe.html#writing-a-new-recipe)" 섹션을 참고하세요.

### 14.4.4 라이선스 규정 준수를 위해 무엇을 배포해야 합니까?

이것은 어려운 질문이며, 특정 경우에 대한 답변은 변호사와 상담해야 합니다. GPL 준수를 위해서는 다른 사람이 동일한 최종 결과를 다시 빌드하고 생산할 수 있도록 충분한 정보를 배포해야 한다는 점을 명심할 가치가 있습니다. 이는 소스 코드, 적용된 모든 패치, 패키지가 어떻게 구성되고 빌드되었는지에 대한 설정 정보 공유를 의미합니다.

자세한 내용은 Yocto 프로젝트 개요 및 개념 설명서의 "[라이선싱](https://docs.yoctoproject.org/overview-manual/development-environment.html#licensing)" 섹션과 Yocto 프로젝트 개발 작업 설명서의 "[제품 라이프사이클 동안 오픈 소스 라이선스 준수 유지](https://docs.yoctoproject.org/dev-manual/licenses.html#maintaining-open-source-license-compliance-during-your-product-s-lifecycle)" 섹션을 참고하세요.

### 14.4.5 한 패키지를 다시 컴파일한 후 전체 리플래시를 해야 합니까?

OpenEmbedded 빌드 시스템은 IPK for OPKG, Debian 패키지 (`.deb`), RPM과 같은 다양한 형식으로 패키지를 빌드할 수 있습니다. 그러면 Ubuntu나 Fedora와 같은 데스크톱 배포판에서처럼 장치의 패키지 도구를 사용하여 수정된 패키지만 업그레이드할 수 있습니다. 그러나 대상의 패키지 관리는 완전히 선택 사항입니다.

### 14.4.6 내 패키지가 머신 지정으로 표시되는 것을 방지하려면 어떻게 합니까?

패키지에 한 머신에만 대한 머신 지정 데이터가 있지만 패키지가 모든 경우에 머신 지정으로 표시되는 경우, `.bb` 파일에서 `SRC_URI_OVERRIDES_PACKAGE_ARCH = "0"`을 설정할 수 있습니다. 그러나 필요한 경우 패키지를 수동으로 머신 지정으로 표시해야 합니다. `SRC_URI_OVERRIDES_PACKAGE_ARCH`를 처리하는 코드는 `meta/classes-global/base.bbclass` 파일에 있습니다.

### 14.4.7 `target`과 `target-native`의 차이점은 무엇입니까?

`*-native` 대상은 빌드에 사용되는 시스템에서 실행되도록 설계되었습니다. 이들은 일반적으로 `quilt-native`와 같이 빌드를 어떤 방식으로든 지원하기 위해 필요한 도구입니다. 비-네이티브 버전은 대상 장치에서 실행되는 것입니다.

### 14.4.8 `-native` 레시피의 `${bindir}`과 `${libdir}`이 이상한 값을 갖는 이유는 무엇입니까?

실행 파일과 라이브러리는 처음에 설치된 디렉토리 이외의 디렉토리에서 사용해야 할 수 있습니다. 이 상황을 복잡하게 하는 것은 때때로 이러한 실행 파일과 라이브러리가 초기 설치 대상 디렉토리에서 실행되기를 기대하도록 컴파일된다는 사실입니다. 그렇다면 이동하면 문제가 발생합니다.

이 시나리오는 주류 Linux 배포판의 패키지 유지보수자와 OpenEmbedded 빌드 시스템 모두에게 근본적인 문제입니다. 따라서 잘 확립된 솔루션이 존재합니다. Makefile, Autotools 설정 스크립트, 다른 빌드 시스템은 `bindir`, `libdir`, `sysconfdir`과 같은 환경 변수를 존중해야 합니다. 또한 프로그램이 실제로 실행될 때 실행 파일, 라이브러리, 데이터가 어디에 있는지를 나타내는 `DESTDIR` 환경 변수를 존중해야 합니다. 프로그램이 실제로 `DESTDIR`에서 실행되지 않음을 이해됩니다.

OpenEmbedded 빌드 시스템이 대상 아키텍처 프로그램을 빌드하기 위해 레시피를 사용할 때 (즉, 빌드되는 이미지에 포함되도록 의도된 프로그램), 그 프로그램은 결국 해당 이미지의 루트 파일시스템에서 실행됩니다. 따라서 빌드 시스템은 `bindir`에 "/usr/bin", `libdir`에 "/usr/lib" 등의 값을 제공합니다.

한편, `DESTDIR`은 빌드 디렉토리 내의 경로입니다. 그러나 레시피가 네이티브 프로그램을 빌드할 때 (즉, 빌드 머신에서 실행되도록 의도된 프로그램), 해당 프로그램은 빌드 머신의 루트 파일시스템에 직접 설치되지 않습니다. 따라서 빌드 시스템은 `DESTDIR`, `bindir` 및 관련 변수에 대해 빌드 디렉토리 내의 경로를 사용합니다.

### 14.4.9 더 많은 여유 공간이 있는 이미지를 어떻게 만듭니까?

기본적으로, OpenEmbedded 빌드 시스템은 채워진 루트 파일시스템 크기의 1.3배 크기인 이미지를 생성합니다. 이미지 크기에 영향을 주려면 다양한 설정을 지정해야 합니다:

- **이미지 크기**: OpenEmbedded 빌드 시스템은 `IMAGE_ROOTFS_SIZE` 변수를 사용하여 이미지 크기를 킬로바이트 단위로 정의합니다. 빌드 시스템은 초기 루트 파일시스템 크기를 고려하여 크기를 결정한 후 요청된 이미지 크기, 이미지에 추가할 요청된 추가 여유 디스크 공간 등의 수정 사항을 반영합니다.

- **오버헤드**: `IMAGE_OVERHEAD_FACTOR` 변수를 사용하여 빌드 시스템이 초기 이미지 크기에 적용하는 배수를 정의합니다. 기본값은 1.3입니다.

- **추가 여유 공간**: `IMAGE_ROOTFS_EXTRA_SPACE` 변수를 사용하여 이미지에 추가 여유 공간을 추가합니다. 빌드 시스템은 `IMAGE_ROOTFS_SIZE`를 결정한 후 이 공간을 이미지에 추가합니다.

### 14.4.10 경로 이름에 공백이 지원되지 않는 이유는 무엇입니까?

Yocto 프로젝트 팀은 이전에 이를 시도했지만, `autoconf`와 같이 OpenEmbedded 빌드 시스템이 의존하는 너무 많은 도구가 경로 이름에 공백을 찾을 때 중단됩니다. 그 상황이 변할 때까지, 팀은 경로 이름의 공백을 지원하지 않을 것입니다.

### 14.4.11 레시피에 바이너리를 추가하고 있습니다. 왜 이미지에서 다릅니까?

가장 명백한 변화는 시스템이 디버그 기호를 제거하는 것입니다. `INHIBIT_PACKAGE_STRIP`을 설정하여 디버그 기호가 제거되는 것을 중지하고/또는 `INHIBIT_PACKAGE_DEBUG_SPLIT`을 설정하여 디버그 기호가 별도 파일로 분할되는 것을 중지하면 바이너리가 변경되지 않음을 보장합니다.

## 14.5 실행 중인 시스템의 문제

### 14.5.1 터치스크린 장치의 커서를 어떻게 비활성화합니까?

Yocto 프로젝트 Board Support Packages (BSP) 개발자 가이드의 "[기타 BSP 특정 레시피 파일](https://docs.yoctoproject.org/bsp-guide/bsp.html#miscellaneous-bsp-specific-recipe-files)" 섹션에 설명된 대로 폼 팩터 파일을 생성해야 합니다.

`HAVE_TOUCHSCREEN` 변수를 다음과 같이 1로 설정합니다:

```
HAVE_TOUCHSCREEN=1
```

### 14.5.2 연결된 네트워크 인터페이스를 항상 어떻게 가져옵니까?

netbase 레시피에서 제공하는 기본 인터페이스 파일은 네트워크 인터페이스를 자동으로 가져오지 않습니다. 따라서 인터페이스 파일을 포함하는 BSP 특정 netbase를 추가해야 합니다. Yocto 프로젝트 Board Support Packages (BSP) 개발자 가이드의 "[기타 BSP 특정 레시피 파일](https://docs.yoctoproject.org/bsp-guide/bsp.html#miscellaneous-bsp-specific-recipe-files)" 섹션을 참고하세요.

예를 들어, 레이어에 다음 파일을 추가합니다:

```
meta-MACHINE/recipes-bsp/netbase/netbase/MACHINE/interfaces
meta-MACHINE/recipes-bsp/netbase/netbase_5.0.bbappend
```
