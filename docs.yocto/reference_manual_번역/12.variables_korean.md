******************
변수 용어집
******************

이 장에서는 OpenEmbedded 빌드에 사용되는 일반적인 변수들을 나열합니다.
이 시스템에 대해 설명하고, 시스템의 기능과 내용에 대한 개요를 제공합니다.

## 용어집 확인 시작

## 용어집 끝 확인

## 용어집

   :정렬됨:

### `ABIEXTENSION`

      GNU의 애플리케이션 바이너리 인터페이스(ABI) 필드에 대한 확장
      정식 아키텍처 이름(예: "eabi").

      ABI 확장은 머신 포함 파일에 설정됩니다. 예를 들어,
      ``meta/conf/machine/include/arm/arch-arm.inc`` 파일은 다음을 설정합니다.
      다음 확장::

         ABIEXTENSION = "eabi"

### `ALLOW_EMPTY`

      출력 패키지가 비어 있더라도 생성할지 여부를 지정합니다.
      BitBake는 기본적으로 빈 패키지를 생성하지 않습니다.
      특정 상황에서 행동은 문제를 일으킬 수 있습니다.
      `RDEPENDS` 또는 기타 엄격한 런타임
      패키지의 존재 여부에 대한 요구 사항.

      다른 모든 패키지 제어 변수와 마찬가지로, 이러한 변수들은 항상 다음과 같이 사용해야 합니다.
      패키지 이름 재정의와 함께 사용하면 다음과 같습니다.

         ALLOW_EMPTY:${PN} = "1"
         ALLOW_EMPTY:${PN}-dev = "1"
         ALLOW_EMPTY:${PN}-staticdev = "1"

   :용어:`대안`
      대체 바이너리 명명법이 필요한 패키지 내 명령어를 나열합니다.
      체계. 때때로 동일한 명령이 여러 패키지에 제공됩니다.
      이러한 상황이 발생하면 OpenEmbedded 빌드 시스템은 다음을 사용해야 합니다.
      대안 시스템을 사용하여 다른 바이너리 명명 체계를 생성합니다.
      명령어는 공존할 수 있습니다.

      변수를 사용하려면 패키지에 포함된 명령어를 나열하세요.
      다른 패키지에서 제공하는 경우. 예를 들어, `busybox` 패키지에서 제공하는 경우
      이러한 명령은 네 가지가 있으며, 다음과 같이 식별할 수 있습니다.

         대안: busybox = "sh sed 테스트 괄호"

      대안 시스템에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`ref-classes-update-alternatives`"
      부분.

### `ALTERNATIVE_LINK_NAME`

      대체 시스템에서 중복된 명령을 실제 명령에 매핑하는 데 사용됩니다.
      위치. 예를 들어, 제공된 ``bracket`` 명령이 있는 경우
      `busybox` 패키지가 다른 패키지를 통해 중복되었으므로,
      `ALTERNATIVE_LINK_NAME` 변수를 사용하여 실제 링크를 지정하십시오.
      위치::

         ALTERNATIVE_LINK_NAME[bracket] = "/usr/bin/["

      이 예에서, ``대괄호`` 명령(즉, ``[``)의 바이너리는 다음과 같습니다.
      `busybox` 패키지의 해당 파일은 `/usr/bin/`에 있습니다.

      .. 메모::

         `ALTERNATIVE_LINK_NAME`이 정의되지 않은 경우 기본값은 ``${bindir}/name``입니다.

      대안 시스템에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`ref-classes-update-alternatives`"
      부분.

### `ALTERNATIVE_PRIORITY`

      대안 시스템에서 기본 우선순위를 생성하는 데 사용됩니다.
      중복된 명령입니다. 변수를 사용하여 단일 명령을 생성할 수 있습니다.
      명령어 이름이나 패키지와 관계없이 기본값은 다음과 같습니다.
      패키지와 관계없이 특정 중복 명령 또는 기본값
      특정 패키지와 관련된 특정 명령어는 다음과 같습니다.
      사용 가능한 구문 형식::

         ALTERNATIVE_PRIORITY = "priority"
         ALTERNATIVE_PRIORITY[name] = "priority"
         ALTERNATIVE_PRIORITY_pkg[name] = "priority"

      대안 시스템에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`ref-classes-update-alternatives`"
      부분.

### `ALTERNATIVE_TARGET`

      대안 시스템에서 기본 링크 위치를 생성하는 데 사용됩니다.
      중복된 명령입니다. 변수를 사용하여 단일 명령을 생성할 수 있습니다.
      모든 중복 명령의 기본 위치(무엇이든 상관없이)
      명령어 이름 또는 패키지, 특정 중복 명령어에 대한 기본값
      패키지 종류와 관계없이, 또는 특정 명령에 대한 기본값이 설정되어 있을 수 있습니다.
      특정 패키지. 사용 가능한 구문 형식은 다음과 같습니다.

         ALTERNATIVE_TARGET = "target"
         ALTERNATIVE_TARGET[name] = "target"
         ALTERNATIVE_TARGET_pkg[name] = "target"

      .. 메모::

         `ALTERNATIVE_TARGET`이 정의되지 않은 경우 해당 값을 상속합니다.
         `ALTERNATIVE_LINK_NAME` 변수에서 가져왔습니다.

         만약 `ALTERNATIVE_LINK_NAME`과 `ALTERNATIVE_TARGET`이
         마찬가지로, `ALTERNATIVE_TARGET`의 대상은 "``.{BPN}``"입니다.
         그것에 덧붙여졌다.

         마지막으로, 참조된 파일의 이름이 변경되지 않았다면,
         대체 시스템은 이름을 변경할 필요성을 없애기 위해 이름을 바꿀 것입니다.
         :ref:`ref-tasks-install`의 대체 파일
         필요한 경우 명령에 대한 지원을 유지하면서 작업을 수행합니다.

      대안 시스템에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`ref-classes-update-alternatives`" 섹션.

### `ANY_OF_DISTRO_FEATURES`

      :ref:`ref-classes-features_check`를 상속받을 때
      클래스에서 이 변수는 배포 기능 목록을 식별합니다.
      현재 구성에서 최소 하나 이상이 활성화되어 있어야 합니다.
      OpenEmbedded 빌드 시스템이 레시피를 빌드하기 위한 것입니다. 다시 말해,
      `ANY_OF_DISTRO_FEATURES`에 나열된 기능 중 어느 것도 해당되지 않는 경우
      현재 구성 내의 `DISTRO_FEATURES`에 나타납니다.
      해당 레시피는 건너뛰어지며, 빌드 시스템이 빌드를 시도하는 경우
      그러면 레시피에 오류가 발생합니다.

### `APPEND`

      지정된 각 대상에 대한 추가 문자열의 재정의 목록
      `레이블`.

      자세한 내용은 :ref:`ref-classes-grub-efi` 클래스를 참조하세요.
      이 변수가 어떻게 사용되는지에 대한 정보입니다.

### `AR`

      :manpage:`ar <ar(1)>`을 실행하는 데 사용되는 최소 명령 및 인수입니다.

### `ARCHIVER_MODE`

      :ref:`ref-classes-archiver` 클래스와 함께 사용할 경우,
      릴리스된 아카이브를 생성하는 데 사용되는 정보 유형을 결정합니다.
      이 변수를 사용하여 패치된 소스 코드의 아카이브를 생성할 수 있습니다.
      원본 소스, 구성된 소스 등을 사용하여
      다음 변수 플래그(varflags)::

         ARCHIVER_MODE[src] = "original" # 압축 해제된 원본 소스 파일을 사용합니다.
         ARCHIVER_MODE[src] = "patched" # 패치된 소스 파일을 사용합니다. 이것이 기본값입니다.
         ARCHIVER_MODE[src] = "configured" # 구성된 소스 파일을 사용합니다.
         ARCHIVER_MODE[diff] = "1" # do_unpack과 do_patch 사이에 패치를 사용합니다.
         ARCHIVER_MODE[diff-exclude] ?= "file file ..." # diff에서 제외할 파일 및 디렉터리 목록입니다.
         ARCHIVER_MODE[dumpdata] = "1" # 환경 데이터를 사용합니다.
         ARCHIVER_MODE[recipe] = "1" # 레시피와 포함 파일을 사용합니다.
         ARCHIVER_MODE[srpm] = "1" # RPM 패키지 파일을 사용합니다.

      해당 변수의 작동 방식에 대한 자세한 내용은 다음을 참조하십시오.
      소스 디렉터리에 있는 ``meta/classes/archiver.bbclass`` 파일입니다.

### `AS`

      어셈블러를 실행하는 데 필요한 최소한의 명령과 인수입니다. (매뉴얼 페이지:)
      <as(1)>`.

### `ASSUME_PROVIDED`

      레시피 이름(PN 값) 목록을 표시합니다. BitBake는 그렇지 않습니다.
      빌드를 시도하는 대신, BitBake는 이러한 레시피가 이미 생성되었다고 가정합니다.
      지어졌습니다.

      OpenEmbedded-Core에서 `ASSUME_PROVIDED`는 대부분 네이티브를 지정합니다.
      빌드해서는 안 되는 도구들입니다. 예를 들어 `git-native`가 있습니다.
      지정된 경우 호스트의 Git 바이너리를 사용할 수 있습니다.
      `git-native`를 빌드하는 대신에.

### `ASSUME_SHLIBS`

      추가적인 ``shlibs`` 제공자 매핑 정보를 제공합니다.
      자동으로 제공되는 정보를 추가하거나 덮어씁니다.
      시스템입니다. 여러 항목을 입력할 경우 공백으로 구분하세요.

      예를 들어, 다음 형식을 사용하여 ``shlib`` 프로바이더를 추가하세요.
      패키지 이름에 shlibname이 포함되어 있으며 선택적으로 버전이 지정됩니다.

         shlibname:패키지 이름[_버전]

      다음은 `libEGL.so.1`이라는 공유 라이브러리를 추가하는 예입니다.
      ``libegl-implementation`` 패키지에서 제공하는 것과 같습니다.

         ASSUME_SHLIBS = "libEGL.so.1:libegl-implementation"

### `AUTO_LIBNAME_PKGS`

      :ref:`ref-classes-debian` 클래스가 상속될 때,
      이는 기본 동작이며, `AUTO_LIBNAME_PKGS`는 어떤 것을 지정하는지 명시합니다.
      패키지에서 라이브러리를 확인하고 필요에 따라 이름을 변경해야 합니다.
      데비안 라이브러리 패키지 명명 규칙.

      기본값은 "${PACKAGES}"이며, 이로 인해 다음과 같은 문제가 발생합니다.
      :ref:`ref-classes-debian` 클래스는 모든 패키지에 대해 작업을 수행합니다.
      레시피에 의해 명시적으로 생성됩니다.

### `AUTO_SYSLINUXMENU`

      SysLinux 부트로더용 자동 메뉴 생성을 가능하게 합니다.
      레시피에 이 변수를 설정해야 합니다.
      :ref:`ref-classes-syslinux` 클래스는 이 변수를 확인합니다.

### `AUTOREV`

      `SRCREV`가 이 변수의 값으로 설정되면, 이는 다음을 지정합니다.
      저장소의 최신 소스 리비전을 사용하십시오. 다음은 예시입니다.

         SRCREV = "${AUTOREV}"

      이전 구문을 사용하여 최신 버전을 검색하는 경우
      소프트웨어를 사용하려면 `PV`에 `+` 기호가 포함되어 있는지 확인해야 합니다.
      `bitbake`는 `PKGV`에 소스 제어 정보를 포함할 때 다음과 같은 작업을 수행합니다.
      레시피를 포장하는 것. 예를 들면:

         PV = "6.10.y+git"

      더 자세한 내용은 다음을 참조하세요.
      ":ref:`dev-manual/packages:패키지 버전 번호를 자동으로 증가시키는 방법`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `AUTOTOOLS_SCRIPT_PATH`

      `:ref:`ref-classes-autotools` 클래스를 사용할 때,
      `AUTOTOOLS_SCRIPT_PATH` 변수는 스크립트의 위치를 ​​저장합니다.
      Autotools 빌드 시스템에서 사용되는 다양한 스크립트. 기본값
      이 변수의 값은 `S`입니다.

### `AVAILTUNES`

      정의된 CPU 및 애플리케이션 바이너리 인터페이스(ABI) 목록
      OpenEmbedded 빌드에서 사용할 수 있는 튜닝(즉, "튠")
      체계.

      이 목록은 이용 가능한 곡들만 보여주는 것이며, 모든 곡이 포함된 것은 아닙니다.
      특정 기기 구성과 호환되거나, 또는
      서로에게
      :ref:`멀티라이브러리 <개발자 매뉴얼/라이브러리:여러 버전의 라이브러리 파일을 하나의 이미지로 결합>`
      구성.

      목록에 곡을 추가하려면 공백을 넣어 뒤에 붙여주세요.
      "+=" BitBake 연산자를 사용하십시오. 단순히 목록을 바꾸는 것만으로는 안 됩니다.
      "=" 연산자. 다음을 참조하십시오.
      BitBake의 ":ref:`bitbake-user-manual/bitbake-user-manual-metadata:basic syntax`" 섹션
      자세한 내용은 사용자 설명서를 참조하십시오.

### `AZ_SAS`

      Azure Storage 공유 액세스 서명을 사용할 때
      :ref:`Azure Storage fetcher (az://) <bitbake-user-manual/bitbake-user-manual-fetching:fetchers>`
      이 변수는 페처가 인증에 사용할 수 있도록 정의할 수 있습니다.
      비공개 자료에 접근할 수 있게 됩니다.

         AZ_SAS = ""se=2021-01-01&sp=r&sv=2018-11-09&sr=c&skoid=<skoid>&sig=<서명>""

      자세한 내용은 Microsoft Azure Storage 설명서를 참조하세요.
      https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview

### `B`

      `빌드 디렉터리` 내의 디렉터리는 다음과 같습니다.
      OpenEmbedded 빌드 시스템은 레시피 실행 중에 생성된 오브젝트를 배치합니다.
      빌드 프로세스입니다. 기본적으로 이 디렉터리는 다음과 같습니다.
      `S` 디렉터리는 다음과 같이 정의됩니다.

         S = "${UNPACKDIR}/${BP}"

      (`S`) 디렉터리와 가리키는 디렉터리를 분리할 수 있습니다.
      `B` 변수를 통해. 대부분의 Autotools 기반 레시피는 이를 지원합니다.
      이러한 디렉터리를 분리합니다. 빌드 시스템은 기본적으로 다음을 사용합니다.
      ``gcc``와 일부 커널 레시피를 위한 별도의 디렉터리가 있습니다.

### `BAD_RECOMMENDATIONS`

      설치하지 않을 "권장 전용" 패키지 목록을 보여줍니다. 권장 전용
      패키지는 다음을 통해서만 설치되는 패키지입니다.
      `RRECOMMENDS` 변수. 이를 통해 모든 것을 방지할 수 있습니다.
      이러한 "권장" 패키지가 설치되지 않도록 목록을 표시하여 방지할 수 있습니다.
      `BAD_RECOMMENDATIONS` 변수를 사용하면::

         BAD_RECOMMENDATIONS = "package_name package_name package_name ..."

      이 변수는 `local.conf` 파일에서 전역적으로 설정하거나,
      레시피 이름을 사용하여 특정 이미지 레시피에 첨부할 수 있습니다.
      보수::

         잘못된 권장 사항: pn-target_image = "package_name"

      패키지를 설치하지 않기로 선택하는 경우 발생할 수 있는 문제점을 인지하는 것이 중요합니다.
      이 변수를 사용하는 것과 다른 몇몇 패키지들이 이 변수에 의존하고 있습니다.
      (예: 레시피의 `RDEPENDS`에 나열됨)
      변수) OpenEmbedded 빌드 시스템은 귀하의 요청을 무시합니다.
      종속성 오류를 방지하기 위해 필요한 패키지를 설치합니다.

      이 변수는 IPK 및 RPM을 사용할 때만 지원됩니다.
      패키징 백엔드. DEB는 지원되지 않습니다.

      `NO_RECOMMENDATIONS` 및 다음을 참조하십시오.
      `PACKAGE_EXCLUDE` 변수는 관련 항목에 사용됩니다.
      정보.

### `BAREBOX_BINARY`

      `:ref:`ref-classes-barebox` 클래스를 사용할 때 이 변수를 사용하면 다음을 수행할 수 있습니다.
      배포 및 설치해야 할 특정 바이너리를 지정합니다.

      베어박스 빌드 시스템은 여러 개의 베어박스 바이너리를 한 번에 빌드할 수 있습니다.
      기본적으로 빌드된 모든 바이너리는 지정된 디렉터리에 배포 및 설치됩니다.
      원래 이름.

      다음은 이 변수의 사용 예입니다.

         BAREBOX_BINARY = "barebox-boundarydevices-imx6dl-nitrogen6x-1g.img"

### `BAREBOX_CONFIG`

      `:ref:`ref-classes-barebox` 클래스를 사용할 때 이 변수를 사용하면 다음을 수행할 수 있습니다.
      빌드할 베어박스 defconfig의 이름을 지정합니다.
      해당 이름은 barebox 빌드 환경에서 알려진 defconfig 파일이어야 합니다.
      이 변수는 주로 전용 변수가 필요한 일반적인 사용 사례에 유용합니다.
      별도의 설정이 필요하지 않습니다.
      :ref:`ref-classes-barebox` 클래스 자체는 이미 일부 QEMU에 대해 이를 설정하고 있습니다.
      기계들::

         BAREBOX_CONFIG:qemuarm = "multi_v7_defconfig"
         BAREBOX_CONFIG:qemuarm64 = ​​"multi_v8_defconfig"
         BAREBOX_CONFIG:qemux86-64 = "efi_defconfig"

      이러한 경우를 제외하고, `BAREBOX_CONFIG`의 기본값은 비어 있습니다.
      베어박스 구성을 제공하는 방법에 대한 자세한 내용은 다음을 참조하십시오.
      :ref:`ref-classes-barebox` 클래스.

### `BASE_LIB`

      CPU 또는 애플리케이션 바이너리의 라이브러리 디렉터리 이름
      인터페이스(ABI) 튜닝. `BASE_LIB`는 Multilib에서만 적용됩니다.
      컨텍스트를 참조하세요. ":ref:`dev-manual/libraries:combining multiple versions of library files into one image`"를 참조하세요.
      자세한 내용은 Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션을 참조하십시오.
      Multilib에서.

      `BASE_LIB` 변수는 머신 포함 파일에 정의되어 있습니다.
      `소스 디렉토리`. Multilib가 아닌 경우
      사용되는 경우 기본값은 "lib"입니다.

### `BASE_WORKDIR`

      모든 레시피의 작업 디렉토리 기본 경로를 가리킵니다. 기본값은 다음과 같습니다.
      값은 "${TMPDIR}/work"입니다.

### `BB_ALLOWED_NETWORKS`

      페처가 허용할 수 있는 호스트 목록을 공백으로 구분하여 지정합니다.
      필요한 소스 코드를 얻기 위해 사용할 수 있는 방법은 다음과 같습니다.
      이 변수와 관련된 고려 사항:

      - 이 호스트 목록은 `BB_NO_NETWORK`가 설정되지 않은 경우에만 사용됩니다.
         또는 "0"으로 설정하십시오.

      - 문자열 시작 부분에 대한 와일드카드 일치 검색은 제한적으로만 지원됩니다.
         호스트 이름입니다. 예를 들어, 다음 설정이 일치합니다.
         ``git.gnu.org``, ``ftp.gnu.org``, 그리고 ``foo.git.gnu.org``::

            BB_ALLOWED_NETWORKS = "*.gnu.org"

         .. 메모::

            "``*``" 문자는 시작 부분에서만 사용할 수 있습니다.
            호스트 이름이어야 하며, 나머지 부분과 분리되어야 합니다.
            호스트 이름입니다. 다른 곳에서는 와일드카드 문자를 사용할 수 없습니다.
            이름의 위치 또는 앞부분과 결합
            이름.

            예를 들어, `*.foo.bar`는 지원되지만 `*aa.foo.bar`는 지원되지 않습니다.
            그렇지 않습니다.

      - 호스트 목록에 없는 미러는 건너뛰고 디버그 로그에 기록됩니다.

      - 호스트 목록에 없는 네트워크에 접근하려고 하면 오류가 발생합니다.

      `BB_ALLOWED_NETWORKS`를 함께 사용하면
      `PREMIRRORS`는 매우 유용합니다. 호스트를 추가하세요.
      `PREMIRRORS`를 사용하려고 하면 소스 코드가 다음과 같이 표시됩니다.
      허용된 위치에서 가져왔으며 오류 발생을 방지합니다.
      허용되지 않는 호스트가 `SRC_URI`에 있습니다.
      문장입니다. 이는 페처가 해당 문장을 사용하려고 시도하지 않기 때문입니다.
      성공적으로 데이터를 가져온 후 `SRC_URI`에 호스트가 나열됩니다.
      `PREMIRRORS`가 발생합니다.

### `BB_BASEHASH_IGNORE_VARS`

      BitBake 설명서에서 ``bitbake:BB_BASEHASH_IGNORE_VARS`를 참조하십시오.

### `BB_CACHEDIR`

      BitBake 설명서에서 `bitbake:BB_CACHEDIR`을 참조하십시오.

### `BB_CHECK_SSL_CERTS`

      BitBake 설명서에서 ``bitbake:BB_CHECK_SSL_CERTS`를 참조하십시오.

### `BB_CONF_FRAGMENT_DESCRIPTION`

      ``BB_CONF_FRAGMENT_DESCRIPTION` 변수는 텍스트 설명을 정의합니다.
      구성 조각(Configuration Fragment)에 대한 설명입니다. 사용 방법에 대한 자세한 내용은 다음을 참조하세요.
      조각에 대한 자세한 내용은 Yocto의 :doc:`/ref-manual/fragments` 섹션을 참조하십시오.
      프로젝트 참조 설명서.

### `BB_CONF_FRAGMENT_SUMMARY`

      ``BB_CONF_FRAGMENT_SUMMARY` 변수는 한 줄짜리 텍스트 요약을 정의합니다.
      구성 조각(Configuration Fragment)의 요약입니다. 사용 방법에 대한 자세한 내용은 다음을 참조하세요.
      조각에 대한 자세한 내용은 Yocto의 :doc:`/ref-manual/fragments` 섹션을 참조하십시오.
      프로젝트 참조 설명서.

### `BB_CONSOLELOG`

      BitBake 설명서에서 `bitbake:BB_CONSOLELOG`를 참조하십시오.

### `BB_CURRENT_MC`

      BitBake 설명서에서 `bitbake:BB_CURRENT_MC`를 참조하십시오.

### `BB_CURRENTTASK`

      BitBake 설명서에서 `bitbake:BB_CURRENTTASK`를 참조하십시오.

### `BB_DEFAULT_TASK`

      BitBake 설명서에서 `bitbake:BB_DEFAULT_TASK`를 참조하십시오.

### `BB_DEFAULT_UMASK`

      BitBake 설명서에서 `bitbake:BB_DEFAULT_UMASK`를 참조하십시오.

### `BB_DEFER_BBCLASSES`

      BitBake 설명서에서 `bitbake:BB_DEFER_BBCLASSES`를 참조하십시오.

### `BB_DISKMON_DIRS`

      빌드 중에 디스크 공간과 사용 가능한 inode를 모니터링하고 허용합니다.
      이러한 매개변수를 기반으로 빌드를 제어할 수 있습니다.

      디스크 공간 모니터링은 기본적으로 비활성화되어 있습니다. 모니터링을 활성화하려면 다음 단계를 따르세요.
      `conf/local.conf` 파일에 ``BB_DISKMON_DIRS` 변수를 추가하세요.
      빌드 디렉터리에서 찾을 수 있습니다. 사용하세요.
      다음 형식:

      .. 코드 블록:: 없음

         BB_DISKMON_DIRS = "action,dir,threshold [...]"

         어디:

            조치는 다음과 같습니다:
               중단: 빌드가 중단되면 즉시 빌드를 중지합니다.
                          임계점이 무너졌다.
               작업 중지: 현재 작업 후 빌드를 중지합니다.
                          실행 중인 작업이 완료되었습니다.
                          임계점이 무너졌다.
               경고: 경고를 표시하되 계속 진행하십시오.
                          임계값이 돌파될 때 빌드됩니다.
                          이후 경고는 다음과 같이 발령됩니다.
                          BB_DISKMON_WARNINTERVAL에 의해 정의됨
                          변수는 다음과 같이 정의되어야 합니다.
                          conf/local.conf 파일.

            dir은 다음과 같습니다:
               원하는 디렉토리를 선택하세요. 하나를 지정할 수도 있고,
               더 많은 디렉터리를 모니터링하려면 분리하십시오.
               공백으로 그룹화합니다. 두 디렉터리가 있는 경우
               같은 기기에서 첫 번째 디렉토리만
               모니터링되고 있습니다.

            임계값은 다음과 같습니다.
               최소 디스크 공간 확보 또는
               최소 사용 가능한 이노드 수, 또는
               둘 다. 최소 하나는 지정해야 합니다.
               둘 중 하나를 생략하거나, 단순히 값을 생략하면 됩니다.
               기가바이트(GB) 단위로 G, M, K를 사용하여 임계값을 지정하십시오.
               각각 메가바이트(MB)와 킬로바이트(KB)입니다. 만약 그렇다면
               G, M, 또는 K를 지정하지 않으면 Kbytes로 간주됩니다.
               기본값입니다. GB, MB 또는 KB를 사용하지 마십시오.

      다음은 몇 가지 예입니다.

         BB_DISKMON_DIRS = "ABORT,${TMPDIR},1G,100K WARN,${SSTATE_DIR},1G,100K"
         BB_DISKMON_DIRS = "중지 작업,${TMPDIR},1G"
         BB_DISKMON_DIRS = "중단,${TMPDIR},,100K"

      첫 번째 예시는 다음 정보도 함께 제공해야만 작동합니다.
      `BB_DISKMON_WARNINTERVAL`
      `conf/local.conf` 파일의 변수입니다. 이 예시는 빌드를 실행합니다.
      디스크 공간이 부족하거나 시스템이 즉시 중지되는 경우
      ``${TMPDIR}``의 크기가 1GB 미만으로 떨어지거나 사용 가능한 여유 inode 수가 감소합니다.
      100KB 미만입니다. 두 개의 디렉터리가 제공되기 때문입니다.
      변수와 관련하여 빌드 시스템은 디스크 공간이 부족할 때 경고를 표시합니다.
      `${SSTATE_DIR}` 디렉터리의 크기가 1GB 미만이거나 해당 숫자가 됩니다.
      사용 가능한 inode 수가 100KB 미만으로 떨어지면 경고 메시지가 표시됩니다.
      `BB_DISKMON_WARNINTERVAL`에 정의된 간격 동안
      변하기 쉬운.

      두 번째 예시는 현재 실행 중인 모든 작업이 완료된 후 빌드를 중지합니다.
      ``${TMPDIR}``의 최소 디스크 공간이 확보되면 작업이 완료됩니다.
      디렉터리 용량이 1GB 미만으로 떨어졌습니다. 여유 공간에 대한 디스크 모니터링은 수행되지 않습니다.
      이 경우에는 이노드입니다.

      마지막 예시는 특정 숫자가 특정 값에 도달하면 빌드를 즉시 중단합니다.
      ``${TMPDIR}`` 디렉터리의 사용 가능한 inode가 100KB 미만으로 떨어졌습니다. 아니요.
      이 경우 디렉터리 자체에 대한 디스크 공간 모니터링이 수행됩니다.

### `BB_DISKMON_WARNINTERVAL`

      디스크 공간 및 사용 가능한 inode에 대한 경고 간격을 정의합니다. 이를 설정하려면 다음 단계를 따르세요.
      간격을 설정하려면 `conf/local.conf` 파일에서 변수를 정의하십시오.
      빌드 디렉터리.

      `BB_DISKMON_WARNINTERVAL` 변수를 사용하려면,
      또한 `BB_DISKMON_DIRS`를 사용해야 합니다.
      변수를 지정하고 해당 동작 방식을 "경고"로 정의합니다. 빌드 중에
      디스크 공간 또는 사용 가능한 디스크 수가 부족할 때마다 후속 경고가 발행됩니다.
      inode 수는 해당 간격만큼 더 감소합니다.

      `BB_DISKMON_WARNINTERVAL` 변수를 제공하지 않으면
      `BB_DISKMON_DIRS`를 "WARN" 액션과 함께 사용하십시오.
      모니터링 간격의 기본값은 다음과 같습니다.

         BB_DISKMON_WARNINTERVAL = "50M,5K"

      설정 파일에서 변수를 지정할 때는 다음을 사용하십시오.
      다음 형식:

      .. 코드 블록:: 없음

         BB_DISKMON_WARNINTERVAL = "disk_space_interval,disk_inode_interval"

         어디:

            disk_space_interval은 다음과 같습니다.
               기억의 간격은 다음 중 하나로 표현됩니다.
               G, M 또는 K는 각각 기가바이트(Gbytes), 메가바이트(Mbytes) 또는 킬로바이트(Kbytes)를 나타냅니다.
               각각 해당됩니다. GB, MB 또는 KB는 사용할 수 없습니다.

            disk_inode_interval은 다음과 같습니다.
               자유 이노드 간격은 다음 중 하나로 표현됩니다.
               G, M 또는 K는 각각 기가바이트(Gbytes), 메가바이트(Mbytes) 또는 킬로바이트(Kbytes)를 나타냅니다.
               각각 해당됩니다. GB, MB 또는 KB는 사용할 수 없습니다.

      다음은 예시입니다.

         BB_DISKMON_DIRS = "경고,${SSTATE_DIR},1G,100K"
         BB_DISKMON_WARNINTERVAL = "50M,5K"

      이러한 변수들이 원인이 됩니다
      OpenEmbedded 빌드 시스템은 매번 후속 경고를 발행합니다.
      사용 가능한 디스크 공간이 50MB 또는 그 이상의 용량만큼 추가로 줄어듭니다.
      ``${SSTATE_DIR}``에서 사용 가능한 inode가 5KB 더 감소합니다.
      디렉토리. 이후 간격에 따른 경고는 매번 발생합니다.
      초기 경고(즉, 1) 이후 해당 간격에 도달합니다.
      기가바이트(GB)와 100킬로바이트(KB)입니다.

### `BB_ENV_PASSTHROUGH`

      BitBake 설명서에서 ``bitbake:BB_ENV_PASSTHROUGH`를 참조하십시오.

### `BB_ENV_PASSTHROUGH_ADDITIONS`

      BitBake 설명서의 ``bitbake:BB_ENV_PASSTHROUGH_ADDITIONS`를 참조하십시오.

### `BB_FETCH_PREMIRRORONLY`

      BitBake 설명서에서 `bitbake:BB_FETCH_PREMIRRORONLY`를 참조하십시오.

### `BB_FILENAME`

      BitBake 설명서에서 ``bitbake:BB_FILENAME`을 참조하십시오.

### `BB_GENERATE_MIRROR_TARBALLS`

      소스 제어 저장소(예: Git)의 tarball을 생성합니다.
      메타데이터를 포함한 저장소를 다음 위치에 배치합니다.
      `DL_DIR` 디렉토리.

      성능상의 이유로 이러한 파일의 tarball을 생성하고 배치하는 것이 좋습니다.
      저장소는 OpenEmbedded 빌드의 기본 동작이 아닙니다.
      체계::

         BB_GENERATE_MIRROR_TARBALLS = "1"

      이 변수를 설정하세요
      빌드 디렉터리에 있는 `local.conf` 파일입니다.

      소스 파일이 포함된 tarball을 얻으면 다음 단계를 진행할 수 있습니다.
      Git이나 기타 관련 파일을 삭제하여 `DL_DIR` 디렉토리를 정리하세요.
      소스 제어 작업 디렉터리.

### `BB_GENERATE_SHALLOW_TARBALLS`

      BitBake 설명서에서 ``bitbake:BB_GENERATE_SHALLOW_TARBALLS`를 참조하십시오.

### `BB_GIT_DEFAULT_DESTSUFFIX`

      BitBake 설명서에서 `bitbake:BB_GIT_DEFAULT_DESTSUFFIX`를 참조하십시오.

      OpenEmbedded-Core(OE-Core)에서는 이 변수가 다음과 같이 설정됩니다.
      `BP`는 :oe_git:`bitbake.conf에서 기본적으로 사용됩니다.
      </openembedded-core/tree/meta/conf/bitbake.conf>`.

### `BB_GIT_SHALLOW`

      BitBake 설명서에서 ``bitbake:BB_GIT_SHALLOW`를 참조하십시오.

### `BB_GIT_SHALLOW_DEPTH`

      BitBake 설명서에서 `bitbake:BB_GIT_SHALLOW_DEPTH`를 참조하십시오.

### `BB_HASHCHECK_FUNCTION`

      BitBake 설명서에서 ``bitbake:BB_HASHCHECK_FUNCTION`을 참조하십시오.

### `BB_HASHCONFIG_IGNORE_VARS`

      BitBake 설명서에서 ``bitbake:BB_HASHCONFIG_IGNORE_VARS`를 참조하십시오.

### `BB_HASHSERVE`

      BitBake 설명서에서 `bitbake:BB_HASHSERVE`를 참조하십시오.

### `BB_HASHSERVE_UPSTREAM`

      BitBake 설명서에서 `bitbake:BB_HASHSERVE_UPSTREAM`을 참조하십시오.

### `BB_INVALIDCONF`

      BitBake 설명서에서 `bitbake:BB_INVALIDCONF`를 참조하십시오.

### `BB_LOADFACTOR_MAX`

      BitBake가 실행을 중지하는 시스템 부하 임계값입니다.
      추가 업무.

      빌드 중에 사용되는 리소스를 제한하는 방법에 대한 자세한 내용은 다음을 참조하세요.
      Yocto 프로젝트의 :doc:`/dev-manual/limiting-resources` 섹션
      개발 작업 매뉴얼.

### `BB_LOGCONFIG`

      BitBake 설명서의 ``bitbake:BB_LOGCONFIG`를 참조하십시오.

### `BB_LOGFMT`

      BitBake 설명서에서 `bitbake:BB_LOGFMT`를 참조하십시오.

### `BB_MULTI_PROVIDER_ALLOWED`

      BitBake 설명서에서 ``bitbake:BB_MULTI_PROVIDER_ALLOWED`를 참조하십시오.

### `BB_NICE_LEVEL`

      BitBake 설명서에서 `bitbake:BB_NICE_LEVEL`을 참조하십시오.

### `BB_NO_NETWORK`

      BitBake 설명서에서 ``bitbake:BB_NO_NETWORK`를 참조하십시오.

### `BB_NUMBER_PARSE_THREADS`

      BitBake 설명서에서 ``bitbake:BB_NUMBER_PARSE_THREADS`를 참조하십시오.

### `BB_NUMBER_THREADS`

      BitBake가 동시에 실행할 수 있는 최대 작업 수
      시간. OpenEmbedded 빌드 시스템은 이를 자동으로 구성합니다.
      빌드 시스템의 코어 수와 동일한 변수를 지정합니다.
      예를 들어, 듀얼 코어 프로세서를 사용하는 시스템
      하이퍼스레딩으로 인해 `BB_NUMBER_THREADS` 변수가 기본값으로 설정됩니다.
      "4"까지.

      단일 소켓 시스템(즉, CPU가 하나인 시스템)의 경우, 다음 작업은 필요하지 않습니다.
      빌드 시 최적의 병렬 처리를 얻으려면 이 변수를 재정의하십시오.
      하지만 여러 개의 물리적 장치를 사용하는 매우 큰 시스템을 운영하는 경우에는 상황이 달라질 수 있습니다.
      CPU의 경우, `BB_NUMBER_THREADS` 변수를 확인하는 것이 좋습니다.
      "20"보다 높게 설정되지 않습니다.

      빌드 속도 향상에 대한 자세한 내용은 다음을 참조하세요.
      ":ref:`dev-manual/speeding-up-build:빌드 속도 향상`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

      반면에, 시스템의 양을 제한하는 것이 목표라면
      BitBake 작업에서 소비되는 리소스, `BB_NUMBER_THREADS` 설정
      컴퓨터의 CPU 스레드 수보다 작은 숫자로
      그것으로는 충분하지 않을 겁니다. 각 패키지가 여전히 빌드되기 때문입니다.
      그리고 지정된 여러 병렬 작업을 통해 설치되었습니다.
      `PARALLEL_MAKE` 변수는 기본적으로 CPU 개수입니다.
      시스템의 스레드에 영향을 미치지 않으며,
      `BB_NUMBER_THREADS` 값.

      따라서 `BB_NUMBER_THREADS`를 "1"로 설정했지만 다른 설정을 하지 않으면
      `PARALLEL_MAKE`를 사용하면 시스템 리소스의 대부분이 소모됩니다.
      그래도.

      따라서 빌드 시스템의 부하를 줄이려면 다음 방법을 사용하세요.
      `BB_NUMBER_THREADS` 값을 상대적으로 낮은 값으로 설정합니다.
      시스템의 CPU 스레드 수에 맞춰 설정해야 합니다.
      `PARALLEL_MAKE`를 유사하게 낮은 값으로 설정합니다.

      `BB_NUMBER_THREADS`를 사용하는 대신 사용량을 유지하는 대안
      빌드 시스템 리소스를 효율적으로 관리하려면 더 스마트하게 활용해야 합니다.
      `BB_PRESSURE_MAX_CPU`, `BB_PRESSURE_MAX_IO` 또는
      `BB_PRESSURE_MAX_MEMORY` 컨트롤을 참조하십시오.
      Yocto 프로젝트의 `:doc:/dev-manual/limiting-resources` 섹션
      개발 작업 매뉴얼.

### `BB_ORIGENV`

      BitBake 설명서에서 `bitbake:BB_ORIGENV`를 참조하십시오.

### `BB_PRESERVE_ENV`

      BitBake 설명서에서 ``bitbake:BB_PRESERVE_ENV`를 참조하십시오.

### `BB_PRESSURE_MAX_CPU`

      BitBake 설명서에서 `bitbake:BB_PRESSURE_MAX_CPU`를 참조하십시오.

      빌드 중에 사용되는 리소스를 제한하는 방법에 대한 자세한 내용은 다음을 참조하세요.
      Yocto 프로젝트의 :doc:`/dev-manual/limiting-resources` 섹션
      개발 작업 매뉴얼.

### `BB_PRESSURE_MAX_IO`

      BitBake 설명서에서 `bitbake:BB_PRESSURE_MAX_IO`를 참조하십시오.

      빌드 중에 사용되는 리소스를 제한하는 방법에 대한 자세한 내용은 다음을 참조하세요.
      Yocto 프로젝트의 :doc:`/dev-manual/limiting-resources` 섹션
      개발 작업 매뉴얼.

### `BB_PRESSURE_MAX_MEMORY`

      BitBake 설명서에서 `bitbake:BB_PRESSURE_MAX_MEMORY`를 참조하십시오.

      빌드 중에 사용되는 리소스를 제한하는 방법에 대한 자세한 내용은 다음을 참조하세요.
      Yocto 프로젝트의 :doc:`/dev-manual/limiting-resources` 섹션
      개발 작업 매뉴얼.

### `BB_RUNFMT`

      BitBake 설명서에서 `bitbake:BB_RUNFMT`를 참조하십시오.

### `BB_RUNTASK`

      BitBake 설명서에서 ``bitbake:BB_RUNTASK`를 참조하십시오.

### `BB_SCHEDULER`

      BitBake 설명서에서 `bitbake:BB_SCHEDULER`를 참조하십시오.

### `BB_SCHEDULERS`

      BitBake 설명서에서 `bitbake:BB_SCHEDULERS`를 참조하십시오.

### `BB_SERVER_TIMEOUT`

      BitBake를 언로드할 시간(초)을 지정합니다.
      서버가 비활성 상태이므로 서버 시간 초과가 발생할 수 있습니다. 서버 시간 초과 여부를 결정하려면 `BB_SERVER_TIMEOUT`을 설정하십시오.
      BitBake 서버가 호출 간에 상주하는 시간.

      예를 들어, `local.conf` 파일에 다음 문장을 넣으세요.
      20초 동안 활동이 없으면 서버를 종료하도록 지시합니다.

         BB_SERVER_TIMEOUT = "20"

      서버가 절대 언로드되지 않도록 하려면,
      `BB_SERVER_TIMEOUT`을 "-1"로 설정합니다.

### `BB_SETSCENE_DEPVALID`

      BitBake 설명서에서 ``bitbake:BB_SETSCENE_DEPVALID`를 참조하십시오.

### `BB_SIGNATURE_EXCLUDE_FLAGS`

      BitBake 설명서의 ``bitbake:BB_SIGNATURE_EXCLUDE_FLAGS`를 참조하십시오.

### `BB_SIGNATURE_HANDLER`

      BitBake 설명서에서 ``bitbake:BB_SIGNATURE_HANDLER`를 참조하십시오.

### `BB_SRCREV_POLICY`

      BitBake 설명서에서 `bitbake:BB_SRCREV_POLICY`를 참조하십시오.

### `BB_STRICT_CHECKSUM`

      BitBake 설명서에서 ``bitbake:BB_STRICT_CHECKSUM`을 참조하십시오.

### `BB_TASK_IONICE_LEVEL`

      BitBake 설명서에서 `bitbake:BB_TASK_IONICE_LEVEL`을 참조하십시오.

### `BB_TASK_NICE_LEVEL`

      BitBake 설명서에서 ``bitbake:BB_TASK_NICE_LEVEL`을 참조하십시오.

### `BB_TASKHASH`

      BitBake 설명서에서 `bitbake:BB_TASKHASH`를 참조하십시오.

### `BB_USE_HOME_NPMRC`

      BitBake 설명서에서 ``bitbake:BB_USE_HOME_NPMRC`를 참조하십시오.

### `BB_VERBOSE_LOGS`

      BitBake 설명서에서 ``bitbake:BB_VERBOSE_LOGS`를 참조하십시오.

### `BB_WORKERCONTEXT`

      BitBake 설명서에서 `bitbake:BB_WORKERCONTEXT`를 참조하십시오.

### `BBCLASSEXTEND`

      레시피를 확장하여 동일한 레시피의 변형을 만들 수 있도록 합니다.
      소프트웨어. 레시피에는 "네이티브"와 같은 일반적인 변형이 있습니다.
      `quilt-native`는 빌드 환경에서 실행되도록 만들어진 Quilt의 복사본입니다.
      시스템; ``gcc-cross``와 같은 "크로스"는 다음과 같이 빌드된 컴파일러입니다.
      빌드 머신에서 실행되지만 대상 시스템에서 실행되는 바이너리를 생성합니다.
      `MACHINE`; ":ref:`ref-classes-nativesdk`",
      `MACHINE` 대신 SDK 머신을 대상으로 지정하고 "mulitlibs"를 사용합니다.
      형식은 "``multilib:``\ multilib_name"입니다.

      최소한의 재료로 레시피의 다른 변형을 만들려면
      코드의 경우, 일반적으로 레시피에 다음을 추가하는 것만큼 간단합니다.

         BBCLASSEXTEND =+ "native nativesdk"
         BBCLASSEXTEND =+ "multilib:multilib_name"

      .. 메모::

         내부적으로, `BBCLASSEXTEND` 메커니즘은 레시피를 생성합니다.
         변수 값을 다시 작성하고 재정의를 적용하는 등의 방법으로 변형을 만들 수 있습니다.
         ``:class-native``와 같이 사용합니다. 예를 들어 네이티브 버전을 생성하려면 다음과 같이 합니다.
         레시피, 즉 "foo"에 의존하는 `DEPENDS`가 다시 작성됩니다.
         "foo-native"에 대한 `DEPENDS`입니다.

         `BBCLASSEXTEND`를 사용하더라도 레시피는 한 번만 파싱됩니다.
         한 번 파싱하면 몇 가지 제약 사항이 생깁니다. 예를 들어, 다음과 같은 것은 아닙니다.
         버전에 따라 다른 파일을 포함할 수 있습니다.
         `include` 문은 레시피가 처리될 때 실행되기 때문입니다.
         분석되었습니다.

### `BBDEBUG`

      BitBake 설명서에서 ``bitbake:BBDEBUG`를 참조하십시오.

### `BBFILE_COLLECTIONS`

      구성된 레이어의 이름을 나열합니다. 이러한 이름은 찾기 위해 사용됩니다.
      다른 ``BBFILE_*`` 변수들입니다. 일반적으로 각 레이어는 추가됩니다.
      해당 이름을 `conf/layer.conf` 파일의 이 변수에 지정합니다.

### `BBFILE_PATTERN`

      파일과 일치하도록 확장되는 변수
      특정 레이어의 `BBFILES` 변수입니다.
      `conf/layer.conf` 파일에서 사용되며 접미사로 반드시 를 붙여야 합니다.
      특정 레이어의 이름(예: ``BBFILE_PATTERN_emenlow``).

### `BBFILE_PRIORITY`

      각 계층의 레시피 파일에 우선순위를 지정합니다.

      이 변수는 동일한 레시피가 여러 번 나타나는 상황에서 유용합니다.
      두 개 이상의 레이어에서. 이 변수를 설정하면 다음을 수행할 수 있습니다.
      동일한 레시피를 포함하는 다른 레이어보다 특정 레이어의 우선순위를 지정합니다.
      --- 여러 항목에 대한 우선순위를 효과적으로 제어할 수 있습니다.
      레이어. 이 변수를 통해 확립된 우선순위는 다음과 같습니다.
      레시피 버전(PV 변수)과는 관계없습니다.
      예를 들어, 더 높은 PV 값을 가진 레시피를 포함하는 레이어가 있지만
      BBFILE_PRIORITY로 설정된 경우 우선순위가 더욱 낮아집니다.
      우선순위가 더 낮습니다.

      `BBFILE_PRIORITY` 변수에 더 큰 값을 입력하면 다음과 같은 결과가 나타납니다.
      우선순위가 더 높습니다. 예를 들어, 값 6은 우선순위가 더 높습니다.
      5보다 큰 값. 지정되지 않은 경우 `BBFILE_PRIORITY` 변수가 사용됩니다.
      레이어 종속성을 기반으로 설정됩니다(`LAYERDEPENDS` 변수 참조).
      자세한 내용은 다음을 참조하십시오. 우선순위가 지정되지 않은 경우 기본 우선순위가 적용됩니다.
      종속성이 없는 레이어는 가장 낮은 정의된 우선순위 + 1(또는 1)입니다.
      우선순위가 정해지지 않은 경우).

      팁::

         `bitbake-layers show-layers` 명령어를 사용하면 레이어를 표시할 수 있습니다.
         구성된 모든 레이어와 해당 우선순위를 나열합니다.

### `BBFILES`

      BitBake가 빌드에 사용하는 레시피 파일 목록(공백으로 구분)
      소프트웨어.

      레시피 파일을 지정할 때 Python의 패턴 매칭 기능을 사용할 수 있습니다.
      `glob <https://docs.python.org/3/library/glob.html>`__ 구문.
      구문에 대한 자세한 내용은 다음 문서를 참조하십시오.
      이전 링크.

### `BBFILES_DYNAMIC`

      식별된 레이어가 존재할 때 콘텐츠를 활성화합니다. 사용자가 식별합니다.
      레이어는 해당 레이어가 정의하는 컬렉션에 따라 분류됩니다.

      `.bbappend` 파일 생성을 방지하려면 `BBFILES_DYNAMIC` 변수를 사용하십시오.
      해당 ``.bb`` 파일이 시도하는 레이어에 있는
      ``.bbappend``를 통해 다른 레이어를 수정하고 싶지는 않지만, 수정하고 싶지는 않습니다.
      다른 계층에 대한 강력한 의존성을 도입합니다.

      `BBFILES_DYNAMIC`에 대해 다음 형식을 사용하십시오.
      ``컬렉션_이름:파일_패턴``.

      다음 예는 두 개의 컬렉션 이름과 두 개의 컬렉션 이름을 식별합니다.
      파일 이름 패턴::

         BBFILES_DYNAMIC += " \
            clang-layer:${LAYERDIR}/bbappends/meta-clang/*/*/*.bbappend \
            core:${LAYERDIR}/bbappends/openembedded-core/meta/*/*/*.bbappend \
            "

      다음 예시는 유효하지 않은 내용으로 인해 발생하는 오류 메시지를 보여줍니다.
      구문 분석 오류를 일으키는 항목이 발견되었습니다.

      .. 코드 블록:: 없음

         오류: BBFILES_DYNAMIC 항목은 <컬렉션 이름>:<파일 이름 패턴> 형식이어야 하며, 다음 형식은 안 됩니다.
             /work/my-layer/bbappends/meta-security-isafw/*/*/*.bbappend
             /work/my-layer/bbappends/openembedded-core/meta/*/*/*.bbappend

### `BBINCLUDED`

      BitBake 설명서에서 `bitbake:BBINCLUDED`를 참조하십시오.

### `BBINCLUDELOGS`

      빌드 실패 시 BitBake가 로그를 표시하는 방식을 제어하는 ​​변수입니다.

### `BBINCLUDELOGS_LINES`

      `BBINCLUDELOGS`가 설정된 경우, 다음을 지정합니다.
      작업 로그 파일에서 출력할 최대 줄 수
      작업 실패를 보고합니다. `BBINCLUDELOGS_LINES`를 설정하지 않으면,
      로그 전체가 출력됩니다.

### `BBLAYERS`

      빌드 중에 활성화할 레이어 목록을 지정합니다. 이 변수는 정의되어 있습니다.
      빌드 디렉터리에 있는 `bblayers.conf` 구성 파일에서 설정하십시오.
      다음은 예시입니다.

         BBLAYERS = " \
             /home/scottrif/poky/meta \
             /home/scottrif/poky/meta-poky \
             /home/scottrif/poky/meta-yocto-bsp \
             /home/scottrif/poky/meta-mykernel \
             "

      이 예제는 네 개의 레이어를 지원하며, 그중 하나는 사용자 정의 레이어입니다.
      ``meta-mykernel``이라는 이름의 사용자 정의 레이어입니다.

### `BBLAYERS_FETCH_DIR`

      BitBake 설명서에서 `bitbake:BBLAYERS_FETCH_DIR`을 참조하십시오.

### `BBMASK`

      BitBake가 레시피 및 레시피 추가 파일을 처리하는 것을 방지합니다.

      `BBMASK` 변수를 사용하면 이러한 ``.bb`` 파일을 "숨길" 수 있습니다.
      ``.bbappend`` 파일. BitBake는 레시피 또는 레시피 추가 파일을 무시합니다.
      어떤 표현식과도 일치하는 파일. 마치 BitBake가 그렇지 않은 것 같습니다.
      해당 파일들을 전혀 볼 수 없습니다. 결과적으로 일치하는 파일은 구문 분석되지 않습니다.
      그렇지 않으면 BitBake에서 사용됩니다.

      사용자가 제공하는 값은 파이썬의 정규 표현식에 전달됩니다.
      컴파일러입니다. 따라서 구문은 파이썬의 정규 구문을 따릅니다.
      표현식 (재) 구문. 표현식은 전체와 비교됩니다. 표현식은 전체와 비교됩니다.
      파일 경로입니다. 전체 구문 정보는 Python의 구문 가이드를 참조하세요.
      자세한 내용은 https://docs.python.org/3/library/re.html#regular-expression-syntax 에서 확인할 수 있습니다.

      다음 예제는 완전한 정규 표현식을 사용하여 설명합니다.
      BitBake에서 모든 레시피 및 레시피 추가 파일을 무시하도록 설정
      ``meta-ti/recipes-misc/`` 디렉토리::

         BBMASK = "meta-ti/recipes-misc/"

      여러 디렉토리 또는 레시피를 가리고 싶다면 다음과 같이 할 수 있습니다.
      여러 개의 정규 표현식 조각을 지정합니다. 다음 예시를 참조하세요.
      여러 디렉토리와 개별 레시피를 숨깁니다.

         BBMASK += "/meta-ti/recipes-misc/meta-ti/recipes-ti/packagegroup/"
         BBMASK += "/meta-oe/recipes-support/"
         BBMASK += "/meta-foo/.*/openldap"
         BBMASK += "opencv.*\.bbappend"
         BBMASK += "lzma"

      .. 메모::

         디렉터리 이름을 지정할 때는 끝에 슬래시(/) 문자를 사용하십시오.
         해당 디렉토리 이름과 정확히 일치하는지 확인하기 위해서입니다.

### `BBMULTICONFIG`

      추가적인 개별 구성을 지정할 때 이 작업을 수행합니다.
      다양한 구성으로 빌드 대상을 설정하세요. 이 변수를 사용하세요.
      `conf/local.conf` 설정 파일을 지정하세요.
      사용 중인 각 구성 파일에 대해 multiconfigname을 지정합니다.
      예를 들어, 다음 줄은 세 개의 구성 파일을 지정합니다.

         BBMULTICONFIG = "configA configB configC"

      사용하는 각 설정 파일은 ``multiconfig`` 폴더에 있어야 합니다.
      레이어 내의 구성 디렉터리 하위 디렉터리 또는
      빌드 디렉터리(예: ) 내
      ``build_directory/conf/multiconfig/configA.conf`` 또는
      ``mylayer/conf/multiconfig/configB.conf``).

      환경에서 `BBMULTICONFIG`를 사용하는 방법에 대한 정보는 다음을 참조하십시오.
      다양한 구성을 가진 빌드 대상을 지원하는 기능에 대해서는 다음을 참조하십시오.
      ":ref:`dev-manual/building:다양한 구성을 사용하여 여러 대상에 대한 이미지 빌드`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `BBPATH`

      BitBake 설명서에서 ``bitbake:BBPATH`를 참조하십시오.

### `BBSERVER`

      BitBake 환경 변수에 정의된 경우, ``BBSERVER`는 다음을 가리킵니다.
      BitBake 원격 서버.

      BitBake로 변수를 내보낼 때는 다음 형식을 사용하십시오.
      환경::

         export BBSERVER=localhost:$port

      기본적으로 `BBSERVER`는 `BB_BASEHASH_IGNORE_VARS`에도 나타납니다.
      따라서 `BBSERVER`는 체크섬 및 종속성에서 제외됩니다.
      데이터.

### `BBTARGETS`

      BitBake 설명서의 ``bitbake:BBTARGETS`를 참조하십시오.

### `BINCONFIG`

      `ref-classes-binconfig-disabled` 클래스를 상속받을 때, 이것은
      이 변수는 비활성화할 바이너리 구성 스크립트를 지정합니다.
      ``pkg-config``를 사용하여 정보를 조회합니다.
      :ref:`ref-classes-binconfig-disabled` 클래스는 지정된 내용을 수정합니다.
      스크립트가 오류를 반환하도록 하여 해당 스크립트에 대한 호출을 쉽게 찾을 수 있도록 합니다.
      그리고 교체되었습니다.

      여러 스크립트를 추가하려면 공백으로 구분하세요. 다음은 예시입니다.
      ``libpng`` 레시피에서::

         BINCONFIG = "${bindir}/libpng-config ${bindir}/libpng16-config"

### `BINCONFIG_GLOB`

      `ref-classes-binconfig` 클래스를 상속할 때,
      이 변수는 구성 스크립트에 사용할 와일드카드를 지정합니다.
      수정이 필요합니다. 스크립트는 잘못된 경로를 수정하기 위해 편집되었습니다.
      컴파일 과정에서 설정되었으므로 사용 시 올바르게 작동합니다.
      sysroot에 설치되고 다른 빌드 프로세스에서 호출됩니다.
      레시피.

      .. 메모::

         `BINCONFIG_GLOB` 변수는 다음을 사용합니다.
         `셸 글로빙 <https://tldp.org/LDP/abs/html/globbingref.html>`__,
         이는 패턴 생성 중 와일드카드 인식 및 확장을 의미합니다.
         일치. 껍질 덩어리짐은 매우 유사합니다.
         `fnmatch <https://docs.python.org/3/library/fnmatch.html#module-fnmatch>`__
         그리고 `glob <https://docs.python.org/3/library/glob.html>`__.

      이 변수의 작동 방식에 대한 자세한 내용은 다음을 참조하십시오.
      소스 디렉터리에 있는 ``meta/classes-recipe/binconfig.bbclass``입니다.
      일반적인 정보도 찾을 수 있습니다.
      수업에 대한 정보
      ":ref:`ref-classes-binconfig`" 섹션.

### `BITBAKE_UI`

      BitBake 설명서에서 `bitbake:BITBAKE_UI`를 참조하십시오.

### `BP`

      기본 레시피 이름과 버전만 표시하고 특별한 레시피 이름은 제외합니다.
      접미사(예: ``-native``, ``lib64-`` 등). `BP`는
      다음으로 구성됩니다::

         ${BPN}-${PV}

### `BPN`

      이 변수는 `PN` 변수의 한 버전입니다.
      ``nativesdk-``와 같은 일반적인 접두사와 접미사가 제거되었습니다.
      ``-cross``, ``-native``, 그리고 multilib의 ``lib64-`` 및 ``lib32-``.
      제거되는 접두사와 접미사의 정확한 목록은 다음과 같습니다.
      `MLPREFIX` 및
      `SPECIAL_PKGSUFFIX` 변수,
      각기.

### `BUGTRACKER`

      레시피에 대한 상위 버그 추적 웹사이트의 URL을 지정합니다.
      OpenEmbedded 빌드 시스템은 이 변수를 사용하지 않습니다. 오히려,
      이 변수는 소프트웨어에 버그가 있을 경우 유용한 포인터 역할을 합니다.
      구축된 건물은 수동으로 보고해야 합니다.

### `BUILD_AR`

      아키텍처별 :manpage:`archiver <ar(1)>`를 지정합니다.
      빌드 호스트이며, 해당 기본 정의는 부분적으로 다음에서 파생됩니다.
      `BUILD_PREFIX`::

         BUILD_AR = "${BUILD_PREFIX}ar"

      :ref:`ref-classes-native` 레시피를 빌드할 때 `AR`은 다음으로 설정됩니다.
      이 변수의 기본값입니다.

      `BUILD_AR` 변수는 수동으로 설정해서는 안 되며, 거의 설정되지 않습니다.
      레시피에서 `AR`로 사용되는 이 용어는 상황에 따라 적절한 값을 포함합니다.
      컨텍스트(네이티브 또는 대상 레시피). 대상의 경우에는 예외가 적용됩니다.
      빌드에서 :manpage:`archiver <ar(1)>`를 사용해야 하는 레시피
      빌드 과정 중 어느 시점에 호스트가 생성됩니다.

### `BUILD_ARCH`

      빌드 호스트의 아키텍처를 지정합니다(예: ``i686``).
      OpenEmbedded 빌드 시스템은 `BUILD_ARCH` 값을 설정합니다.
      `uname` 명령어가 보고한 머신 이름입니다.

### `BUILD_AS`

      아키텍처별 어셈블러 <as(1)>를 지정합니다.
      빌드 호스트이며, 해당 기본 정의는 부분적으로 다음에서 파생됩니다.
      `BUILD_PREFIX`::

         BUILD_AS = "${BUILD_PREFIX}as ${BUILD_AS_ARCH}"

      `ref-classes-native` 레시피를 빌드할 때 `AS`는 다음으로 설정됩니다.
      이 변수의 기본값입니다.

      `BUILD_AS` 변수는 수동으로 설정해서는 안 되며, 설정하는 경우는 드뭅니다.
      레시피에서 `AS`로 사용되는 이 값은 상황에 따라 적절한 값을 포함합니다.
      컨텍스트(네이티브 또는 대상 레시피). 대상의 경우에는 예외가 적용됩니다.
      빌드에서 :manpage:`어셈블러 <as(1)>`를 사용해야 하는 레시피
      빌드 과정 중 어느 시점에 호스트가 생성됩니다.

### `BUILD_AS_ARCH`

      빌드에 사용할 아키텍처별 어셈블러 플래그를 지정합니다.
      호스트. 기본적으로 `BUILD_AS_ARCH` 값은 비어 있습니다.

### `BUILD_CC`

      빌드 호스트에 사용할 아키텍처별 C 컴파일러를 지정합니다.
      그리고 기본 정의는 부분적으로 `BUILD_PREFIX`에서 파생됩니다.
      그리고 `BUILD_CC_ARCH`::

         BUILD_CC = "${CCACHE}${BUILD_PREFIX}gcc ${BUILD_CC_ARCH}"

      :ref:`ref-classes-native` 레시피를 빌드할 때 `CC`는 다음으로 설정됩니다.
      이 변수의 기본값입니다.

      `BUILD_CC` 변수는 수동으로 설정해서는 안 되며, 설정하는 경우는 드뭅니다.
      레시피에서 `CC`로 사용되는 이 용어는 상황에 따라 적절한 값을 포함합니다.
      컨텍스트(네이티브 또는 대상 레시피). 대상의 경우에는 예외가 적용됩니다.
      빌드 호스트의 컴파일러를 사용해야 하는 레시피
      빌드 중에.

### `BUILD_CC_ARCH`

      빌드에 사용할 아키텍처별 C 컴파일러 플래그를 지정합니다.
      호스트. 기본적으로 `BUILD_CC_ARCH` 값은 비어 있습니다.

### `BUILD_CCLD`

      빌드에 사용할 :manpage:`링커 <ld(1)>` 명령어를 지정합니다.
      C 컴파일러가 링커로 사용될 때의 호스트와 그 기본값
      정의는 부분적으로 `BUILD_PREFIX`에서 파생되었습니다.
      `BUILD_CC_ARCH`::

         BUILD_CCLD = "${BUILD_PREFIX}gcc ${BUILD_CC_ARCH}"

      :ref:`ref-classes-native` 레시피를 빌드할 때 `CCLD`는 다음과 같이 설정됩니다.
      이 변수의 기본값입니다.

      `BUILD_CCLD` 변수는 수동으로 설정해서는 안 되며, 설정하는 경우는 드뭅니다.
      레시피에서 `CCLD`라는 용어로 사용되며, 해당 용어는 상황에 따라 적절한 값을 포함합니다.
      컨텍스트(네이티브 또는 대상 레시피). 대상의 경우에는 예외가 적용됩니다.
      빌드 호스트의 :manpage:`링커 <ld(1)>`를 사용해야 하는 레시피
      빌드 과정 중 어느 시점에서.

### `BUILD_CFLAGS`

      빌드 시 C 컴파일러에 전달할 플래그를 지정합니다.
      호스트를 빌드합니다. :ref:`ref-classes-native` 레시피를 빌드할 때,
      `CFLAGS`는 이 변수의 값으로 설정됩니다.
      기본.

### `BUILD_CPP`

      C 전처리 명령어를 지정합니다(C 및 C++ 컴파일러 모두에 적용).
      빌드 호스트용으로 빌드할 때, 기본 정의는 다음과 같이 파생됩니다.
      `BUILD_PREFIX` 및 `BUILD_CC_ARCH`의 일부::

         BUILD_CPP = "${BUILD_PREFIX}gcc ${BUILD_CC_ARCH} -E"

      :ref:`ref-classes-native` 레시피를 빌드할 때 `CPP`는 다음과 같이 설정됩니다.
      이 변수의 기본값입니다.

      `BUILD_CPP` 변수는 수동으로 설정해서는 안 되며, 설정하는 경우는 드뭅니다.
      레시피에서 `CPP`로 사용되는 이 함수는 상황에 따라 적절한 값을 포함합니다.
      컨텍스트(네이티브 또는 대상 레시피). 대상의 경우에는 예외가 적용됩니다.
      빌드 호스트의 전처리기를 사용해야 하는 레시피
      빌드 과정 중 특정 시점.

### `BUILD_CPPFLAGS`

      C 전처리기에 전달할 플래그를 지정합니다(즉, C 전처리기와 C 전처리기 모두에 전달합니다).
      빌드 호스트용으로 빌드할 때 (및 C++ 컴파일러)
      `-native` 컨텍스트에서 빌드, `CPPFLAGS`
      기본적으로 이 변수의 값으로 설정됩니다.

### `BUILD_CXX`

      빌드 호스트에 사용할 아키텍처별 C++ 컴파일러를 지정합니다.
      그리고 기본 정의는 부분적으로 `BUILD_PREFIX`에서 파생됩니다.
      그리고 `BUILD_CC_ARCH`::

         BUILD_CXX = "${CCACHE}${BUILD_PREFIX}g++ ${BUILD_CC_ARCH}"

      :ref:`ref-classes-native` 레시피를 빌드할 때 `CXX`는 다음과 같이 설정됩니다.
      이 변수의 기본값입니다.

      `BUILD_CXX` 변수는 수동으로 설정해서는 안 되며, 거의 설정되지 않습니다.
      레시피에서 `CXX`로 사용되는 이 값은 상황에 따라 적절한 값을 포함합니다.
      컨텍스트(네이티브 또는 대상 레시피). 대상의 경우에는 예외가 적용됩니다.
      빌드 호스트의 C++ 컴파일러를 사용해야 하는 레시피
      빌드 과정 중 특정 시점.

### `BUILD_CXXFLAGS`

      빌드 시 C++ 컴파일러에 전달할 플래그를 지정합니다.
      호스트를 빌드합니다. :ref:`ref-classes-native` 레시피를 빌드할 때,
      `CXXFLAGS`는 이 변수의 값으로 설정됩니다.
      기본적으로.

### `BUILD_FC`

      빌드 호스트에 사용할 Fortran 컴파일러 명령과 해당 기본값을 지정합니다.
      정의는 부분적으로 `BUILD_PREFIX`에서 파생되었습니다.
      `BUILD_CC_ARCH`::

         BUILD_FC = "${BUILD_PREFIX}gfortran ${BUILD_CC_ARCH}"

      `ref-classes-native` 레시피를 빌드할 때 `FC`는 다음으로 설정됩니다.
      이 변수의 기본값입니다.

      `BUILD_FC` 변수는 수동으로 설정해서는 안 되며, 거의 설정되지 않습니다.
      레시피에서 `FC`로 사용되는 이 값은 상황에 따라 적절한 값을 포함합니다.
      컨텍스트(네이티브 또는 대상 레시피). 대상의 경우에는 예외가 적용됩니다.
      빌드 호스트의 Fortran 컴파일러를 사용해야 하는 레시피
      빌드 과정 중 특정 시점.

### `BUILD_LD`

      빌드 호스트에 대한 링커 명령과 해당 기본값을 지정합니다.
      정의는 부분적으로 `BUILD_PREFIX`에서 파생되었습니다.
      `BUILD_LD_ARCH`::

         BUILD_LD = "${BUILD_PREFIX}ld ${BUILD_LD_ARCH}"

      :ref:`ref-classes-native` 레시피를 빌드할 때 `LD`는 다음으로 설정됩니다.
      이 변수의 기본값입니다.

      `BUILD_LD` 변수는 수동으로 설정해서는 안 되며, 설정하는 경우는 드뭅니다.
      레시피에서 `LD`로 사용되는 이 값은 상황에 따라 적절한 값을 포함합니다.
      컨텍스트(네이티브 또는 대상 레시피). 대상의 경우에는 예외가 적용됩니다.
      빌드 호스트의 링커를 사용해야 하는 레시피
      빌드 중에.

### `BUILD_LD_ARCH`

      빌드 호스트에 대한 아키텍처별 링커 플래그를 지정합니다.
      기본적으로 `BUILD_LD_ARCH`의 값은 비어 있습니다.

### `BUILD_LDFLAGS`

      빌드 시 링커에 전달할 플래그를 지정합니다.
      호스트. :ref:`ref-classes-native` 레시피를 빌드할 때,
      `LDFLAGS`는 이 변수의 값으로 설정됩니다.
      기본적으로.

### `BUILD_NM`

      객체에서 심볼을 나열하는 아키텍처별 유틸리티를 지정합니다.
      빌드 호스트용 파일과 해당 기본 정의는 부분적으로 파생됩니다.
      `BUILD_PREFIX`에서:

         BUILD_NM = "${BUILD_PREFIX}nm"

      :ref:`ref-classes-native` 레시피를 빌드할 때 `NM`은 다음으로 설정됩니다.
      이 변수의 기본값입니다.

      `BUILD_NM` 변수는 수동으로 설정해서는 안 되며, 거의 설정되지 않습니다.
      레시피에서 `NM`으로 사용되는 이 용어는 상황에 따라 적절한 값을 포함합니다.
      컨텍스트(네이티브 또는 대상 레시피). 대상의 경우에는 예외가 적용됩니다.
      빌드 호스트의 유틸리티를 사용해야 하는 레시피
      빌드 중에.

### `BUILD_OBJCOPY`

      아키텍처별 오브젝트 파일 복사 유틸리티를 지정합니다.
      빌드 호스트이며, 해당 기본 정의는 부분적으로 다음에서 파생됩니다.
      `BUILD_PREFIX`::

         BUILD_OBJCOPY = "${BUILD_PREFIX}objcopy"

      :ref:`ref-classes-native` 레시피를 빌드할 때 `OBJCOPY`가 설정됩니다.
      이 변수의 기본값으로 설정됩니다.

      `BUILD_OBJCOPY` 변수는 수동으로 설정해서는 안 되며,
      `OBJCOPY`라는 용어는 적절한 값을 포함하고 있기 때문에 레시피에서 거의 사용되지 않습니다.
      맥락(기본 레시피 또는 대상 레시피)에 따라 다릅니다. 단, 다음과 같은 경우는 예외로 합니다.
      빌드 호스트의 유틸리티를 사용해야 하는 대상 레시피
      빌드 과정 중 특정 시점.

### `BUILD_OBJDUMP`

      객체 파일을 표시하는 데 사용할 아키텍처별 유틸리티를 지정합니다.
      빌드 호스트에 대한 정보이며, 기본 정의는 다음과 같이 도출됩니다.
      `BUILD_PREFIX`::의 일부

         BUILD_OBJDUMP = "${BUILD_PREFIX}objdump"

      :ref:`ref-classes-native` 레시피를 빌드할 때 `OBJDUMP`가 설정됩니다.
      이 변수의 기본값으로 설정됩니다.

      `BUILD_OBJDUMP` 변수는 수동으로 설정해서는 안 되며,
      `OBJDUMP`에는 적절한 값이 포함되어 있으므로 레시피에서 거의 사용되지 않습니다.
      맥락(기본 레시피 또는 대상 레시피)에 따라 다릅니다. 단, 다음과 같은 경우는 예외로 합니다.
      빌드 호스트의 유틸리티를 사용해야 하는 대상 레시피
      빌드 과정 중 특정 시점.

### `빌드_최적화`

      C 컴파일러에 전달되는 최적화 플래그를 지정합니다.
      빌드 호스트 또는 SDK용으로 빌드합니다. 플래그는 그대로 전달됩니다.
      `BUILD_CFLAGS` 및
      `BUILDSDK_CFLAGS` 기본값.

      `BUILD_OPTIMIZATION` 변수의 기본값은 "-O2"입니다.
      -파이프".

### `BUILD_OS`

      빌드 호스트에서 사용 중인 운영 체제를 지정합니다(예:
      "linux". OpenEmbedded 빌드 시스템은 값을 설정합니다.
      `uname` 명령이 보고한 OS의 `BUILD_OS` ---
      첫 번째 단어를 소문자로 변환했습니다.

### `BUILD_PREFIX`

      네이티브 레시피에 사용되는 툴체인 바이너리 접두사입니다. OpenEmbedded
      빌드 시스템은 `BUILD_PREFIX` 값을 사용하여 설정합니다.
      :ref:`ref-classes-native` 레시피를 빌드할 때 `TARGET_PREFIX`를 사용합니다.

### `BUILD_RANLIB`

      인덱스를 생성하는 데 사용할 아키텍처별 유틸리티를 지정합니다.
      빌드 호스트용 아카이브와 해당 기본 정의는 부분적으로 파생됩니다.
      `BUILD_PREFIX`에서:

         BUILD_RANLIB = "${BUILD_PREFIX}ranlib -D"

      :ref:`ref-classes-native` 레시피를 빌드할 때 `RANLIB`는 다음과 같이 설정됩니다.
      이 변수의 기본값입니다.

      `BUILD_RANLIB` 변수는 수동으로 설정해서는 안 되며,
      `RANLIB`에는 적절한 값이 포함되어 있으므로 레시피에서 거의 사용되지 않습니다.
      맥락(기본 레시피 또는 대상 레시피)에 따라 다릅니다. 단, 다음과 같은 경우는 예외로 합니다.
      빌드 호스트의 유틸리티를 사용해야 하는 대상 레시피
      빌드 과정 중 특정 시점.

### `BUILD_READELF`

      아키텍처별 유틸리티를 지정하여 관련 정보를 표시합니다.
      빌드 호스트용 ELF 파일과 해당 기본 정의는 다음과 같이 파생됩니다.
      `BUILD_PREFIX`::의 일부

         BUILD_READELF = "${BUILD_PREFIX}readelf"

      :ref:`ref-classes-native` 레시피를 빌드할 때 `READELF`가 설정됩니다.
      이 변수의 기본값으로 설정됩니다.

      `BUILD_READELF` 변수는 수동으로 설정해서는 안 되며,
      `READELF`에 적절한 값이 포함되어 있으므로 레시피에서 거의 사용되지 않습니다.
      맥락(기본 레시피 또는 대상 레시피)에 따라 다릅니다. 단, 다음과 같은 경우는 예외로 합니다.
      빌드 호스트의 유틸리티를 사용해야 하는 대상 레시피
      빌드 과정 중 특정 시점.

### `BUILD_STRIP`

      바이너리에서 디버깅 심볼을 제거하는 데 사용할 명령어를 지정합니다.
      빌드 호스트용으로 생성되었으며, 기본 정의는 부분적으로 파생됩니다.
      `BUILD_PREFIX`에서:

         BUILD_STRIP = "${BUILD_PREFIX}strip"

      :ref:`ref-classes-native` 레시피를 빌드할 때 `STRIP`은 다음과 같이 설정됩니다.
      이 변수의 기본값입니다.

      `BUILD_STRIP` 변수는 수동으로 설정해서는 안 되며,
      `STRIP`에는 적절한 값이 포함되어 있으므로 레시피에서 거의 사용되지 않습니다.
      맥락(기본 레시피 또는 대상 레시피)에 따라 다릅니다. 단, 다음과 같은 경우는 예외로 합니다.
      빌드 호스트의 유틸리티를 사용해야 하는 대상 레시피
      빌드 과정 중 특정 시점.

### `BUILD_SYS`

      시스템 아키텍처 및 운영 체제를 포함한 시스템 사양을 명시합니다.
      빌드 호스트용 빌드 시 사용할 시스템 (즉, 빌드할 때)
      :ref:`ref-classes-native` 레시피).

      OpenEmbedded 빌드 시스템은 이 변수를 자동으로 설정합니다.
      `BUILD_ARCH`에서,
      `BUILD_VENDOR`, 그리고
      `BUILD_OS`. 설정할 필요가 없습니다.
      `BUILD_SYS` 변수를 직접 설정하세요.

### `BUILD_VENDOR`

      빌드 호스트용 빌드 시 사용할 공급업체 이름을 지정합니다.
      기본값은 빈 문자열("")입니다.

### `BUILDDIR`

      빌드 디렉터리의 위치를 ​​가리킵니다. 정의할 수 있습니다.
      이 디렉토리는 :ref:`structure-core-script` 스크립트를 통해 간접적으로 관리됩니다.
      스크립트를 실행할 때 빌드 디렉터리 경로를 전달하면 됩니다.
      스크립트를 실행할 때 빌드 디렉터리 경로를 지정하지 않으면
      `BUILDDIR`은 현재 디렉터리의 `build`를 기본값으로 사용합니다.

### `BUILDHISTORY_COMMIT`

      `ref-classes-buildhistory` 클래스를 상속할 때, 이 변수는
      빌드 기록 출력을 로컬에 커밋할지 여부를 지정합니다.
      Git 저장소. "1"로 설정하면 이 로컬 저장소가 유지됩니다.
      `ref-classes-buildhistory` 클래스와 커밋에 의해 자동으로 생성됩니다.
      최상위 하위 디렉터리의 변경 사항에 대해서는 빌드할 때마다 파일이 생성됩니다.
      빌드 기록 출력(이미지, 패키지 및 SDK)의 일부입니다. 원하시면
      시간이 지남에 따라 빌드 기록의 변경 사항을 추적하려면 이 값을 설정해야 합니다.
      "1".

      기본적으로 :ref:`ref-classes-buildhistory` 클래스
      빌드 기록 출력을 로컬 Git 저장소에 커밋할 수 있습니다.

         BUILDHISTORY_COMMIT ?= "1"

### `BUILDHISTORY_COMMIT_AUTHOR`

      :ref:`ref-classes-buildhistory`를 상속할 때
      클래스에서 이 변수는 각 Git 커밋에 사용할 작성자를 지정합니다.
      `BUILDHISTORY_COMMIT_AUTHOR` 변수가 제대로 작동하려면 다음이 필요합니다.
      `BUILDHISTORY_COMMIT` 변수는 반드시
      "1"로 설정됩니다.

      Git은 사용자가 제공하는 값이 다음과 같아야 합니다.
      `BUILDHISTORY_COMMIT_AUTHOR` 변수는 "이름" 형식을 취합니다.
      "email@host". 유효하지 않은 이메일 주소 또는 호스트를 제공합니다.
      오류가 발생하지 않습니다.

      기본적으로 `:ref:`ref-classes-buildhistory` 클래스는 변수를 설정합니다.
      다음과 같습니다::

         BUILDHISTORY_COMMIT_AUTHOR ?= "buildhistory <buildhistory@${DISTRO}>"

### `BUILDHISTORY_DIR`

      :ref:`ref-classes-buildhistory`를 상속할 때
      클래스에서 이 변수는 빌드 기록이 저장될 디렉터리를 지정합니다.
      정보가 저장됩니다. 변수 작동 방식에 대한 자세한 내용은 다음을 참조하세요.
      :ref:`ref-classes-buildhistory` 클래스를 참조하십시오.

      기본적으로 `:ref:`ref-classes-buildhistory` 클래스는 디렉터리를 설정합니다.
      다음과 같습니다::

         BUILDHISTORY_DIR ?= "${TOPDIR}/buildhistory"

### `BUILDHISTORY_FEATURES`

      :ref:`ref-classes-buildhistory`를 상속할 때
      클래스에서 이 변수는 빌드 기록 기능을 지정합니다.
      활성화되었습니다. 빌드 기록 작동 방식에 대한 자세한 내용은 다음을 참조하세요.
      ":ref:`개발자 매뉴얼/빌드 품질:빌드 출력 품질 유지`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

      이러한 기능은 공백으로 구분된 목록 형태로 지정할 수 있습니다.

      - *이미지:* 이미지 내용 분석 (다음 내용 포함)
         설치된 패키지 목록 등을 포함합니다.

      - *패키지:* 개별 패키지의 내용물 분석.

      - *sdk:* 소프트웨어 개발 키트의 내용 분석
         (SDK).

      - *작업:* 출력 파일 서명을 저장합니다.
         :ref:`공유 상태 <overview-manual/concepts:공유 상태 캐시>`
         (sstate) 작업.
         이렇게 하면 작업당 하나의 파일이 저장되고 SHA-256 체크섬이 나열됩니다.
         각 파일이 준비됩니다(즉, 작업의 결과물).

      기본적으로 `:ref:`ref-classes-buildhistory` 클래스는 다음을 활성화합니다.
      다음 기능들::

         BUILDHISTORY_FEATURES ?= "이미지 패키지 SDK"

### `BUILDHISTORY_IMAGE_FILES`

      :ref:`ref-classes-buildhistory`를 상속할 때
      클래스에서 이 변수는 복사된 파일의 경로 목록을 지정합니다.
      이미지 내용을 빌드 기록 디렉터리 아래에 저장합니다.
      이미지가 있는 디렉터리에 "image-files" 디렉터리가 있습니다.
      각 파일의 내용을 추적할 수 있습니다. 기본 설정은 복사입니다.
      `/etc/passwd`와 `/etc/group`을 사용하면 다음을 모니터링할 수 있습니다.
      사용자 및 그룹 항목의 변경 사항입니다. 목록을 수정하여 포함할 항목을 추가할 수 있습니다.
      어떤 파일이든 상관없습니다. 잘못된 경로를 지정해도 오류가 발생하지 않습니다.
      따라서 항상 존재하는 것은 아닌 파일도 포함할 수 있습니다.

      기본적으로 `:ref:`ref-classes-buildhistory` 클래스는 다음 경로를 제공합니다.
      다음 파일들::

         BUILDHISTORY_IMAGE_FILES ?= "/etc/passwd /etc/group"

### `BUILDHISTORY_PATH_PREFIX_STRIP`

      :ref:`ref-classes-buildhistory`를 상속할 때
      클래스에서 이 변수는 공통 경로 접두사를 지정합니다.
      작업 서명 목록에서 경로의 시작 부분을 제거했습니다.
      ``task`` 기능은 `BUILDHISTORY_FEATURES`에서 활성화되어 있습니다. 이는 다음과 같습니다.
      빌드 기록이 여러 소스에서 가져와 채워질 때 유용합니다.
      모두 동일한 최상위 디렉토리를 사용합니다.

      기본적으로 `:ref:`ref-classes-buildhistory` 클래스는 변수를 설정합니다.
      다음과 같습니다::

         BUILDHISTORY_PATH_PREFIX_STRIP ?= ""

      이 경우 접두사는 제거되지 않습니다.

### `BUILDHISTORY_PUSH_REPO`

      `ref-classes-buildhistory` 클래스를 상속할 때, 이 변수는
      선택적으로 빌드 기록을 푸시할 원격 저장소를 지정합니다.
      Git 변경 사항. `BUILDHISTORY_PUSH_REPO` 명령어가 제대로 작동하려면,
      `BUILDHISTORY_COMMIT`은 "1"로 설정해야 합니다.

      저장소는 특정 주소를 지정하는 원격 주소에 해당해야 합니다.
      Git에서 이해하는 저장소 또는 원격 이름
      로컬 환경에서 `git remote` 명령어를 사용하여 수동으로 설정한 환경입니다.
      저장소.

      기본적으로 `:ref:`ref-classes-buildhistory` 클래스는 변수를 설정합니다.
      다음과 같습니다::

         BUILDHISTORY_PUSH_REPO ?= ""

### `BUILDNAME`

      BitBake 설명서에서 ``bitbake:BUILDNAME`을 참조하십시오.

### `BUILDSDK_CFLAGS`

      빌드 시 C 컴파일러에 전달할 플래그를 지정합니다.
      SDK. ``nativesdk-`` 컨텍스트에서 빌드할 때,
      `CFLAGS`는 이 변수의 값으로 설정됩니다.
      기본.

### `BUILDSDK_CPPFLAGS`

      C 전처리기에 전달할 플래그를 지정합니다(즉, 둘 다에 대해).
      SDK용으로 빌드할 때 C 및 C++ 컴파일러를 사용합니다.
      ``nativesdk-`` 컨텍스트, `CPPFLAGS`가 설정되었습니다.
      이 변수의 기본값으로 설정됩니다.

### `BUILDSDK_CXXFLAGS`

      빌드 시 C++ 컴파일러에 전달할 플래그를 지정합니다.
      SDK. ``nativesdk-`` 컨텍스트에서 빌드할 때,
      `CXXFLAGS`는 이 변수의 값으로 설정됩니다.
      기본적으로.

### `BUILDSDK_LDFLAGS`

      SDK 빌드 시 링커에 전달할 플래그를 지정합니다.
      ``nativesdk-`` 컨텍스트에서 빌드할 때,
      `LDFLAGS`는 이 변수의 값으로 설정됩니다.
      기본적으로.

### `BUILDSTATS_BASE`

      빌드 통계가 저장된 디렉터리의 위치를 ​​가리킵니다.
      `:ref:`ref-classes-buildstats` 클래스를 사용하고 활성화할 때.
      `BUILDSTATS_BASE` 디렉터리의 기본값은 다음과 같습니다.
      ``${``\ `TMPDIR`\ ``}/buildstats/``.

### `BUSYBOX_SPLIT_SUID`

      BusyBox 레시피의 경우 출력을 분할할지 여부를 지정합니다.
      실행 파일을 두 부분으로 나눕니다. 하나는 필요한 기능을 위한 부분이고, 다른 하나는 필요한 기능을 위한 부분입니다.
      ``setuid root``와 나머지 기능(즉, 다음 기능들)에 대한 설정 하나가 있습니다.
      ``setuid root``가 필요하지 않습니다.

      `BUSYBOX_SPLIT_SUID` 변수의 기본값은 "1"이며, 이로 인해 다음과 같은 결과가 발생합니다.
      출력 실행 파일을 분할합니다. 변수를 "0"으로 설정하면 됩니다.
      단일 출력 실행 파일.

### `BZRDIR` 

      에서 ``bitbake:BZRDIR`을 참조하십시오 .

### `CACHE`

      BitBake가 캐시를 저장하는 데 사용하는 디렉터리를 지정합니다.
      메타데이터를 사용하면 매번 파싱할 필요가 없습니다.
      BitBake가 시작되었습니다.

### `CARGO_INSTALL_LIBRARIES`

      `ref-classes-cargo` 클래스를 상속할 때 변수는 다음과 같습니다.
      `CARGO_INSTALL_LIBRARIES`는 비어 있지 않은 값으로 설정할 수 있습니다.
      라이브러리 설치를 가능하게 하는 개별 레시피
      레시피는 ``${B}/target/${CARGO_TARGET_SUBDIR}``에 빌드되었습니다(파일 확장자: ).
      ``.so`` 또는 ``rlib``와 함께 사용됩니다. 기본적으로 이 변수는 정의되어 있지 않습니다.
      `cargo`의 동작을 재현하기 위해 라이브러리가 설치되지 않았습니다.
      `install` 명령어를 설치하세요.

### `CC`

      C 컴파일러를 실행하는 데 사용되는 최소한의 명령어와 인수입니다.

### `CCACHE_DISABLE`

      `ref-classes-ccache` 클래스를 상속받을 때,
      레시피에서 `CCACHE_DISABLE` 변수를 "1"로 설정하면 CCACHE 기능을 비활성화할 수 있습니다.
      `Ccache` 지원. 이 기능은 레시피가 `Ccache`를 지원하지 않는 것으로 알려진 경우에 유용합니다.

### `CCLD`

      C 언어에서 링커를 실행하는 데 사용되는 최소한의 명령어와 인수입니다.
      컴파일러가 링커로 사용되고 있습니다.

### `CFLAGS`

      C 컴파일러에 전달할 플래그를 지정합니다. 이 변수는 다음과 같습니다.
      환경 변수로 내보내져서 보이게 되었습니다.
      컴파일 단계에서 빌드되는 소프트웨어.

      `CFLAGS`의 기본 초기화는 입력값에 따라 다릅니다.
      건설 중:

      - 빌드 시 `TARGET_CFLAGS`를 사용합니다.
         목표

      - 빌드 시 `BUILD_CFLAGS`를 사용합니다.
         호스트 빌드(예: ``-native``)

      - 빌드 시 `BUILDSDK_CFLAGS`
         SDK(예: ``nativesdk-``)

### `CHECKLAYER_REQUIRED_TESTS`

      `CHECKLAYER_REQUIRED_TESTS` 변수에는 필수 QA 테스트 목록이 표시됩니다.
      Yocto Project 호환 상태를 통과하려면 활성화해야 합니다.
      레이어입니다. 읽기 전용 변수이며, 해당 변수에 대한 변경 사항은 레이어에 반영됩니다.
      변수는 기술 운영 위원회의 승인을 받아야 합니다.
      위원회(TSC) </TSC>`.

      Yocto Project 호환성 상태에 대한 자세한 내용은 다음을 참조하십시오.
      :ref:`dev-manual/layers:레이어 호환성 확인
      Yocto Project 개발 매뉴얼의 Yocto Project 섹션입니다.

### `CLASSOVERRIDE`

      특수 클래스 재정의를 지정하는 내부 변수
      현재 적용되어야 합니다(예: "class-target", "class-native" 등).
      네 번째). 이 변수를 사용하는 클래스(예:
      :ref:`ref-classes-native`, :ref:`ref-classes-nativesdk` 등)
      변수에 적절한 값을 설정하세요.

      .. 메모::

         `CLASSOVERRIDE`는 기본 "클래스 대상" 값을 다음에서 가져옵니다.
         ``bitbake.conf`` 파일.

      예를 들어, 다음 재정의를 사용하면 추가 파일을 설치할 수 있습니다.
      파일은 포함되지만, 대상 빌드 시에만 해당됩니다.

         do_install:append:class-target() {
             my-extra-file ${D}${sysconfdir}를 설치합니다.
         }

      다음은 `FOO`가 설정된 예입니다.
      빌드 호스트용으로 빌드할 때는 "native"를 사용하고, 그렇지 않을 때는 "other"를 사용합니다.
      빌드 호스트용 빌드 중::

         FOO:class-native = "native"
         FOO = "기타"

      `CLASSOVERRIDE`의 기본 메커니즘은 간단합니다.
      기본값에 포함되어 있다는 것입니다.
      `재정의`.

### `CLEANBROKEN`

      레시피 내에서 "1"로 설정하면, `CLEANBROKEN`은 다음을 지정합니다.
      빌드 중인 소프트웨어에 대해 ``make clean`` 명령어가 작동하지 않습니다.
      따라서 OpenEmbedded 빌드 시스템은 실행을 시도하지 않습니다.
      :ref:`ref-tasks-configure` 중에 ``make clean``을 실행합니다.
      이는 기본 동작입니다.

### `COMBINED_FEATURES`

      양쪽 모두에서 활성화된 하드웨어 기능 목록을 제공합니다.
      `기계_특징` 및
      `배포판_특징`. 이 선택 목록은 다음과 같습니다.
      기능에는 제어하는 ​​것이 합리적인 기능들이 포함되어 있습니다.
      기계 및 유통 구성 수준. 예를 들어,
      "블루투스" 기능은 하드웨어 지원이 필요하지만, 또한 다음과 같은 기능도 포함해야 합니다.
      하드웨어가 지원하는 경우 배포 수준에서 선택 사항입니다.
      블루투스 기능은 사용하려는 의도가 전혀 없으시군요.

### `COMMERCIAL_AUDIO_PLUGINS`

      이 변수는 :yocto_git:`GStreamer 레시피에만 해당됩니다.
      </poky/tree/meta/recipes-multimedia/gstreamer/gstreamer1.0-meta-base.bb>`.
      이를 통해 GStreamer를 "보기 흉하게" 만들 수 있습니다.
      <https://github.com/GStreamer/gst-plugins-ugly>`__ 및
      `"나쁜" <https://github.com/GStreamer/gst-plugins-bad>`__ 오디오 플러그인.

      상업용 라이선스와 관련된 기타 변수는 :ref:`dev-manual/licenses/other variables related to commercial licenses`를 참조하십시오.
      사용 내역을 확인하는 섹션입니다.

### `COMMERCIAL_VIDEO_PLUGINS`

      이 변수는 :yocto_git:`GStreamer 레시피에만 해당됩니다.
      </poky/tree/meta/recipes-multimedia/gstreamer/gstreamer1.0-meta-base.bb>`.
      이를 통해 GStreamer를 "보기 흉하게" 만들 수 있습니다.
      <https://github.com/GStreamer/gst-plugins-ugly>`__ 및
      `"나쁜" <https://github.com/GStreamer/gst-plugins-bad>`__ 비디오 플러그인.

      상업용 라이선스와 관련된 기타 변수는 :ref:`dev-manual/licenses/other variables related to commercial licenses`를 참조하십시오.
      사용 내역을 확인하는 섹션입니다.

### `COMMON_LICENSE_DIR`

      ``meta/files/common-licenses``를 가리킵니다.
      `소스 디렉토리`는 일반 라이선스가 있는 곳입니다.
      파일이 있습니다.

### `COMPATIBLE_HOST`

      하나 이상의 호스트로 해석되는 정규 표현식(예:
      레시피가 네이티브 레시피인 경우) 또는 하나 이상의 대상(레시피가 네이티브 레시피인 경우)
      레시피와 호환되는 (비네이티브) 정규 표현식
      `HOST_SYS`와 일치합니다. 다음을 사용할 수 있습니다.
      특정 시스템 유형에 대해 레시피가 생성되지 않도록 하는 변수
      레시피가 호환되지 않는 경우입니다. 이러한 빌드를 중지하는 것은
      특히 커널에 유용합니다. 이 변수는 또한 증가시키는 데 도움이 됩니다.
      빌드 시스템이 레시피 파싱을 건너뛰기 때문에 파싱 속도가 빨라집니다.
      현행 시스템과 호환됩니다.

### `COMPATIBLE_MACHINE`

      하나 이상의 대상 머신으로 해석되는 정규 표현식
      레시피와 호환되는 정규 표현식입니다.
      `MACHINEOVERRIDES`에 대항하여 사용할 수 있습니다.
      특정 기능을 가진 기기에 대해 레시피가 생성되지 않도록 하는 변수
      레시피가 호환되지 않습니다. 이러한 빌드를 중지하는 것이 특히 중요합니다.
      커널과 함께 사용하면 유용합니다. 이 변수는 구문 분석 속도 향상에도 도움이 됩니다.
      빌드 시스템이 호환되지 않는 레시피 구문 분석을 건너뛰기 때문에 속도가 향상됩니다.
      현재 사용 중인 기기로는 불가능합니다.

      특정 아키텍처에서만 사용 가능한 레시피를 만들고 싶다면
      (여기서는 ``aarch64`` 및 ``mips64``) 다음을 사용할 수 있습니다.

         호환 가능한 기계 = "^$"
         호환 가능한 머신:arch64 = "^(aarch64)$"
         호환 가능한 머신:mips64 = "^(mips64)$"

      첫 번째 줄은 "`MACHINEOVERRIDES` 조건을 만족하는 모든 머신과 일치"한다는 의미입니다.
      빈 문자열을 포함합니다. 빈 문자열은 항상 none을 의미합니다.

      두 번째는 `MACHINEOVERRIDES` 조건을 만족하는 모든 머신을 일치시키는 것입니다.
      하나의 오버라이드가 포함되어 있으며, 이는 정확히 ``aarch64``입니다.

      세 번째는 `MACHINEOVERRIDES` 조건을 만족하는 모든 머신을 일치시키는 것입니다.
      ``mips64``와 정확히 일치하는 오버라이드가 하나 포함되어 있습니다.

      다음과 같은 방법으로도 동일한 결과를 얻을 수 있습니다.

         호환 가능한 머신 = "^(aarch64|mips64)$"

      .. 메모::

         레시피에서 `COMPATIBLE_MACHINE`이 설정되면 다음에서 상속됩니다.
         토종 음식의 경우, 레시피는 항상 생략됩니다. 모든 토종 음식 레시피는 반드시 포함되어야 합니다.
         완전히 대상과 무관하며 `MACHINE`에 의존해서는 안 됩니다.

### `COMPLEMENTARY_GLOB`

      보완 목록을 설치할 때 일치시킬 와일드카드를 정의합니다.
      명시적으로(또는 암묵적으로) 설치된 모든 패키지에 대한 패키지
      이미지.

      `COMPLEMENTARY_GLOB` 변수는 Unix 파일 이름 패턴 일치를 사용합니다.
      (`fnmatch <https://docs.python.org/3/library/fnmatch.html#module-fnmatch>`__),
      이는 유닉스 스타일의 경로명 패턴 확장과 유사합니다.
      (`glob <https://docs.python.org/3/library/glob.html>`__).

      결과적으로 생성된 보완 패키지 목록은 다음과 연관됩니다.
      추가할 수 있는 항목
      `이미지 특징`. 사용 예시
      이것은 `IMAGE_FEATURES`에 추가될 때 사용되는 "dev-pkgs" 항목입니다.
      -dev 패키지(헤더 및 기타 개발 패키지 포함)를 설치합니다.
      이미지에 포함된 모든 패키지에 대한 파일입니다.

      와일드카드를 가리키는 새 기능 항목을 추가하려면 변수 플래그를 사용하십시오.
      기능 항목 이름을 지정하고 값을 사용하여 지정합니다.
      와일드카드. 예시는 다음과 같습니다.

         COMPLEMENTARY_GLOB[dev-pkgs] = '*-dev'

      .. 메모::

         보완 패키지를 설치할 때, 관련 관계를 추천합니다.
         (`RRECOMMENDS`를 통해 설정된) 값은 항상 무시됩니다.

### `COMPONENTS_DIR`

      각 레시피에 대한 sysroot 구성 요소를 저장합니다. OpenEmbedded 빌드
      이 시스템은 레시피별 구성을 위해 `COMPONENTS_DIR`을 사용합니다.
      다른 레시피에 대한 sysroots입니다.

      기본값은 다음과 같습니다.
      "``${``\ `STAGING_DIR`\ ``}-components``."
      (즉
      "``${``\ `TMPDIR`\ ``}/sysroots-components``").

### `CONF_VERSION`

      로컬 구성 파일의 버전을 추적합니다(예:
      `local.conf` 파일에 대한 CONF_VERSION 값은 매번 증가합니다.
      `build/conf/`` 호환성 변경 사항입니다.

### `CONFFILES`

      패키지에 포함된 편집 가능하거나 구성 가능한 파일을 식별합니다.
      패키지 관리 시스템(PMS)을 사용하여 업데이트하는 경우
      대상 시스템의 패키지의 경우 구성에 문제가 발생할 수 있습니다.
      최초 설치 이후 변경된 파일 및
      이제 변경되지 않고 유지되기를 원하는 내용은 덮어쓰기됩니다. 다시 말해,
      패키지 내에 재설정하고 싶지 않은 편집 가능한 파일이 있을 수 있습니다.
      패키지 업데이트 프로세스의 일부로, `CONFFILES` 명령어를 사용할 수 있습니다.
      차단하려는 패키지 내 파일 목록을 나타내는 변수입니다.
      이번 업데이트 과정에서 PMS가 덮어쓰기되는 것을 방지합니다.

      `CONFFILES` 변수를 사용하려면 패키지 이름 재정의를 제공하십시오.
      결과 패키지를 식별하는 정보입니다. 그런 다음, 제공해 주세요.
      공백으로 구분된 파일 목록입니다. 예시는 다음과 같습니다.

         CONFFILES:${PN} += "${sysconfdir}/file1 \
             ${sysconfdir}/file2 ${sysconfdir}/file3"

      `CONFFILES`와 `FILES` 사이에는 관계가 있습니다.
      변수. `CONFFILES`에 나열된 파일은 다음 변수들의 하위 집합이어야 합니다.
      `FILES`에 나열된 파일들입니다. 구성 파일들이기 때문입니다.
      사용자가 제공하는 `CONFFILES` 파일은 다음과 같이 식별됩니다.
      PMS는 해당 파일을 덮어쓰지 않으므로, 파일이 다음과 같은 조건을 충족해야 한다는 것은 당연합니다.
      이미 `FILES`를 통해 패키지의 일부로 포함되어 있습니다.
      변하기 쉬운.

      .. 메모::

         `CONFFILES` 변수의 일부로 경로를 지정할 때는 다음과 같습니다.
         적절한 경로 변수를 사용하는 것이 좋은 관행입니다.
         예를 들어, `/etc` 또는 `${bindir}` 대신 `${sysconfdir}`를 사용합니다.
         `/usr/bin`이 아니라면, 이러한 변수 목록은 다음에서 확인할 수 있습니다.
         ``meta/conf/bitbake.conf`` 파일의 맨 위 부분
         `소스 디렉토리`.

### `CONFIG_INITRAMFS_SOURCE`

      초기 RAM 파일 시스템(Initramfs) 소스 파일을 식별합니다.
      OpenEmbedded 빌드 시스템은 이 커널 Kconfig를 수신하고 사용합니다.
      이 변수는 환경 변수로 사용됩니다. 기본적으로 이 변수는 설정되어 있습니다.
      null("")로.

      `CONFIG_INITRAMFS_SOURCE`는 단일 cpio 아카이브일 수 있습니다.
      ``.cpio`` 접미사 또는 공백으로 구분된 디렉터리 목록과 함께
      Initramfs 이미지를 빌드하기 위한 파일입니다. cpio 아카이브에는 다음 내용이 포함되어야 합니다.
      Initramfs 이미지로 사용될 파일 시스템 아카이브입니다. 디렉터리
      `Initramfs`에 포함될 파일 시스템 레이아웃을 포함해야 합니다.
      이미지. 파일에는 설명된 형식에 따른 항목이 포함되어야 합니다.
      커널 트리의 ``usr/gen_init_cpio`` 프로그램에 의해 실행됩니다.

      여러 디렉터리와 파일을 지정하면 `Initramfs` 이미지가 사용됩니다.
      그것들 모두의 합이 될 것입니다.

      Initramfs를 생성하는 방법에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`dev-manual/building:초기 RAM 파일 시스템(Initramfs) 이미지 빌드`" 섹션
      Yocto 프로젝트 개발 작업 매뉴얼에 있습니다.

### `CONFIG_SITE`

      `autoconf` 테스트 결과가 포함된 파일 목록 (관련 내용)
      현재 빌드 버전입니다. 이 변수는 Autotools 유틸리티에서 사용됩니다.
      `configure`를 실행할 때.

### `CONFIGURE_FLAGS`

      GNU configure에 필요한 최소 인자입니다.

### `CONFIGURE_SCRIPT`

      `:ref:`ref-classes-autotools` 클래스를 사용할 때,
      `CONFIGURE_SCRIPT` 변수는 ``configure``의 위치를 ​​저장합니다.
      Autotools 빌드 시스템용 스크립트입니다. 이 스크립트의 기본 정의는 다음과 같습니다.
      변수는 다음과 같습니다::

         CONFIGURE_SCRIPT ?= "${AUTOTOOLS_SCRIPT_PATH}/configure"

      여기서 `AUTOTOOLS_SCRIPT_PATH`는 스크립트의 위치입니다.
      Autotools는 시스템 스크립트를 빌드하는데, 기본값은 `S`입니다.

### `CONFLICT_DISTRO_FEATURES`

      :ref:`ref-classes-features_check`를 상속받을 때
      클래스에서 이 변수는 다음과 같은 분포 특성을 식별합니다.
      레시피가 충돌하는 경우 레시피를 만들어야 합니다. 다시 말해, 만약
      `CONFLICT_DISTRO_FEATURES` 변수는 다음 기능도 나열합니다.
      현재 구성 내의 `DISTRO_FEATURES`에 나타납니다.
      해당 레시피는 건너뛰어지며, 빌드 시스템이 빌드를 시도하는 경우
      그러면 레시피에 오류가 발생합니다.

### `CONVERSION_CMD`

      이 변수는 이미지 변환 명령을 저장하는 데 사용됩니다.
      이미지 변환을 통해 이미지를 다음과 같은 다양한 객체로 변환할 수 있습니다.

      - 이미지의 압축 버전

      - 이미지의 체크섬

      :ref:`ref-classes-image_types`의 `CONVERSION_CMD` 예시
      클래스는 다음과 같습니다::

         CONVERSION_CMD:lzo = "lzop -9 ${IMAGE_NAME}${IMAGE_NAME_SUFFIX}.${type}"

### `COPY_LIC_DIRS`

      "1"로 설정하면
      `COPY_LIC_MANIFEST` 변수,
      OpenEmbedded 빌드 시스템은 라이선스 파일을 이미지에 복사합니다.
      각 라이선스는 ``/usr/share/common-licenses``에 있습니다.
      패키지입니다. 라이선스 파일은 이미지 내의 디렉터리에 배치됩니다.
      빌드 시간 동안 자체적으로 발생합니다.

      .. 메모::

         `COPY_LIC_DIRS`는 라이선스를 추가하는 경로를 제공하지 않습니다.
         새로 설치된 패키지를 이미지에 추가하는 것으로, 이는 다음과 같은 경우에 가장 적합할 수 있습니다.
         업그레이드할 수 없는 읽기 전용 파일 시스템입니다. 자세한 내용은 다음을 참조하십시오.
         추가 정보는 `LICENSE_CREATE_PACKAGE` 변수를 참조하십시오.
         ":ref:`dev-manual/licenses:providing license text`"를 참조할 수도 있습니다.
         Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션
         라이선스 문구 제공에 관한 정보입니다.

### `COPY_LIC_MANIFEST`

      이 값을 "1"로 설정하면 OpenEmbedded 빌드 시스템이 라이선스를 복사합니다.
      이미지에 대한 매니페스트
      이미지 내의 ``/usr/share/common-licenses/license.manifest``
      빌드 시간 동안 자체적으로 발생합니다.

      .. 메모::

         `COPY_LIC_MANIFEST`는 라이선스를 추가하는 경로를 제공하지 않습니다.
         새로 설치된 패키지를 이미지에 추가하는 것으로, 이는 다음과 같은 경우에 가장 적합할 수 있습니다.
         업그레이드할 수 없는 읽기 전용 파일 시스템입니다. 자세한 내용은 다음을 참조하십시오.
         추가 정보는 `LICENSE_CREATE_PACKAGE` 변수를 참조하십시오.
         ":ref:`dev-manual/licenses:providing license text`"를 참조할 수도 있습니다.
         Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션
         라이선스 문구 제공에 관한 정보입니다.

### `COPYLEFT_LICENSE_EXCLUDE`

      소스 아카이브에서 제외할 라이선스 목록을 공백으로 구분하여 입력합니다.
      :ref:`ref-classes-archiver` 클래스. 다시 말해, 라이선스가 있는 경우
      레시피의 `LICENSE` 값은 값에 있습니다.
      `COPYLEFT_LICENSE_EXCLUDE`를 사용하면 해당 소스는 아카이브되지 않습니다.
      수업.

      .. 메모::

         `COPYLEFT_LICENSE_EXCLUDE` 변수는 다음보다 우선순위가 높습니다.
         `COPYLEFT_LICENSE_INCLUDE` 변수.

      기본값은 "CLOSED Proprietory"입니다.
      `COPYLEFT_LICENSE_EXCLUDE`는 다음에서 설정됩니다.
      :ref:`ref-classes-copyleft_filter` 클래스,
      :ref:`ref-classes-archiver` 클래스에 의해 상속됩니다.

### `COPYLEFT_LICENSE_INCLUDE`

      소스 아카이브에 포함할 라이선스 목록을 공백으로 구분하여 입력하십시오.
      :ref:`ref-classes-archiver` 클래스에 의해. 다른 경우에는
      레시피의 라이선스(LICENSE)에 라이선스가 있는 경우,
      값이 `COPYLEFT_LICENSE_INCLUDE` 값에 있다면,
      소스 코드는 클래스에 의해 보관됩니다.

      기본값은 `:ref:ref-classes-copyleft_filter` 클래스에 의해 설정됩니다.
      이는 :ref:`ref-classes-archiver` 클래스에 의해 상속됩니다. 기본값
      값에는 "GPL*", "LGPL*" 및 "AGPL*"이 포함됩니다.

### `COPYLEFT_PN_EXCLUDE`

      보관된 소스에서 제외할 레시피 목록
      :ref:`ref-classes-archiver` 클래스. `COPYLEFT_PN_EXCLUDE`
      이 변수는 라이선스 포함 및 제외로 인해 발생하는 설정을 재정의합니다.
      `COPYLEFT_LICENSE_INCLUDE` 및 `COPYLEFT_LICENSE_EXCLUDE`
      각각 변수입니다.

      기본값은 ""이며, 이는 명시적으로 제외하지 않음을 나타냅니다.
      `COPYLEFT_PN_EXCLUDE`에 대한 레시피 이름은 다음과 같이 설정됩니다.
      :ref:`ref-classes-copyleft_filter` 클래스는 상속됩니다.
      :ref:`ref-classes-archiver` 클래스.

### `COPYLEFT_PN_INCLUDE`

      소스 아카이브에 포함할 레시피 목록
      :ref:`ref-classes-archiver` 클래스. `COPYLEFT_PN_INCLUDE`
      이 변수는 라이선스 포함 및 제외로 인해 발생하는 설정을 재정의합니다.
      `COPYLEFT_LICENSE_INCLUDE` 및 `COPYLEFT_LICENSE_EXCLUDE`
      각각 변수입니다.

      기본값은 ""이며, 이는 명시적으로 포함하지 않음을 나타냅니다.
      `COPYLEFT_PN_INCLUDE`에 대한 레시피 이름은 다음과 같이 설정됩니다.
      :ref:`ref-classes-copyleft_filter` 클래스는 상속됩니다.
      :ref:`ref-classes-archiver` 클래스.

### `COPYLEFT_RECIPE_TYPES`

      소스에 포함할 레시피 유형 목록을 공백으로 구분하여 입력하세요.
      :ref:`archiver <ref-classes-archiver>` 클래스에 의해 보관되었습니다.
      레시피 유형은 ``target``, :ref:`ref-classes-native`입니다.
      :ref:`ref-classes-nativesdk`, :ref:`ref-classes-cross`,
      :ref:`ref-classes-crosssdk` 및 :ref:`ref-classes-cross-canadian`.

      `COPYLEFT_RECIPE_TYPES`의 기본값은 "target*"입니다.
      이는 `ref-classes-copyleft_filter` 클래스에 의해 설정됩니다.
      :ref:`ref-classes-archiver` 클래스에 의해 상속됩니다.

### `CORE_IMAGE_EXTRA_INSTALL`

      이미지에 추가할 패키지 목록을 지정합니다.
      이 변수는 ``local.conf`` 구성 파일에서만 설정할 수 있습니다.
      빌드 디렉터리에 있습니다.

      이 변수는 더 이상 사용되지 않는 ``POKY_EXTRA_INSTALL``을 대체합니다.
      지원됩니다.

### `COREBASE`

      OpenEmbedded-Core 메타데이터의 상위 디렉터리를 지정합니다.
      레이어(예: ``메타``).

      `COREBASE`가 부모를 가리킨다는 점은 중요한 차이점입니다.
      레이어 자체가 아니라 이 레이어의 특정 부분을 말하는 것입니다. 예를 들어 다음과 같은 상황을 생각해 보세요.
      Poky Git 저장소를 복제하고 ``poky``라는 이름을 유지했습니다.
      로컬 저장소 복사본의 경우, 이 경우에는 `COREBASE`입니다.
      `poky` 폴더를 가리키는 이유는 해당 폴더가 `poky` 폴더의 상위 디렉토리이기 때문입니다.
      ``poky/meta`` 레이어.

### `COREBASE_FILES`

      COREBASE 디렉터리에 있는 파일 목록을 표시합니다.
      나열된 레이어 외에는 복사해야 합니다.
      ``bblayers.conf`` 파일. `COREBASE_FILES` 변수는 다음을 허용합니다.
      OpenEmbedded 빌드 시스템에서 메타데이터를 복사합니다.
      확장 가능한 SDK에 통합합니다.

      `COREBASE`에 파일을 명시적으로 나열해야 하는 이유는 다음과 같습니다.
      일반적으로 빌드 디렉터리와 기타 파일이 포함되어서는 안 됩니다.
      일반적으로 확장 가능한 SDK에 복사됩니다. 따라서 값은
      `COREBASE_FILES`는 특정 파일만 복사하기 위해 사용됩니다.
      실제로 필요한 것들입니다.

### `CPP`

      C 전처리기를 실행하는 데 사용되는 최소한의 명령어와 인수입니다.

### `CPPFLAGS`

      C 전처리기에 전달할 플래그를 지정합니다(즉, 둘 다에 대해).
      C 및 C++ 컴파일러에서 사용됩니다. 이 변수는 환경 변수로 내보내집니다.
      변수이므로 빌드 중인 소프트웨어에서 확인할 수 있습니다.
      컴파일 단계.

      `CPPFLAGS`의 기본 초기화는 입력값에 따라 다릅니다.
      건설 중:

      - 빌드 시 `TARGET_CPPFLAGS`
         목표

      - 빌드 시 `BUILD_CPPFLAGS`를 사용합니다.
         호스트 빌드(예: ``-native``)

      - 빌드 시 `BUILDSDK_CPPFLAGS`
         SDK(예: ``nativesdk-``)의 경우

### `CROSS_COMPILE`

      대상 도구에 대한 툴체인 바이너리 접두사입니다.
      `CROSS_COMPILE` 변수는 다음과 같습니다.
      `TARGET_PREFIX` 변수.

      .. 메모::

         OpenEmbedded 빌드 시스템은 `CROSS_COMPILE`을 설정합니다.
         특정 상황에서만 사용되는 변수입니다 (예: 커널 빌드 시).
         (및 커널 모듈 레시피).

### `CVE_CHECK_CREATE_MANIFEST`

      배포에 포함할 CVE 매니페스트를 생성할지 여부를 지정합니다.
      디렉터리입니다. 기본값은 "1"입니다.

### `CVE_CHECK_IGNORE`

      이 변수는 더 이상 사용되지 않으며 `CVE_STATUS`로 대체해야 합니다.

### `CVE_CHECK_MANIFEST_JSON`

      JSON 형식의 CVE 매니페스트 파일 경로를 지정합니다. 자세한 내용은 다음을 참조하십시오.
      `CVE_CHECK_CREATE_MANIFEST`.

### `CVE_CHECK_MANIFEST_JSON_SUFFIX`

      JSON 매니페스트 접미사를 수정할 수 있습니다. 자세한 내용은 다음을 참조하세요.
      `CVE_CHECK_MANIFEST_JSON`.

### `CVE_CHECK_REPORT_PATCHED`

      :ref:`ref-classes-cve-check`를 사용할지 여부를 지정합니다.
      해당 클래스는 패치되었거나 무시된 CVE를 보고해야 합니다. 기본값은 "1"이지만,
      패치되거나 무시된 CVE가 필요하지 않은 경우 이 값을 "0"으로 설정할 수 있습니다.
      로그.

### `CVE_CHECK_SHOW_WARNINGS`

      :ref:`ref-classes-cve-check`를 사용할지 여부를 지정합니다.
      해당 클래스는 패치가 적용되지 않은 경우 콘솔에 경고 메시지를 생성해야 합니다.
      CVE가 발견되었습니다. 기본값은 "1"이지만, 필요한 경우 "0"으로 설정할 수 있습니다.
      빌드가 완료된 후 이미 로그를 검토/처리하고 있습니다.
      완료되었으므로 경고 메시지가 필요하지 않습니다.

### `CVE_CHECK_SKIP_RECIPE`

      패키지 이름 목록(`PN`)
      CVE(일반적인 취약점 및 노출)는 무시됩니다.

### `CVE_CHECK_STATUSMAP`

      `CVE_STATUS`의 모든 가능한 원인에 대한 매핑 변수:
      ``패치됨``, ``패치되지 않음`` 및 ``무시됨``.
      자세한 내용은 `ref-classes-cve-check` 또는 `meta/conf/cve-check-map.conf`를 참조하세요.

         CVE_CHECK_STATUSMAP[cpe-incorrect] = "무시됨"

### `CVE_CHECK_VEX_JUSTIFICATION`

      `CVE_STATUS` 사유에 대한 매핑 변수
      (예: ``적용할 수 없는 플랫폼``)을 :ref:`ref-classes-vex`로
      정당성. 다음과 같이 설정해야 합니다.

         CVE_CHECK_VEX_JUSTIFICATION[not-applicable-config] = "vulnerableCodeNotPresent"

### `CVE_DB_INCR_UPDATE_AGE_THRES`

      CVE 데이터베이스의 최대 사용 기간을 초 단위로 지정합니다.
      전체 다운로드 대신 증분 업데이트를 사용합니다. "0"을 입력하면 전체 다운로드를 강제로 수행합니다.
      전체 다운로드.

### `CVE_DB_UPDATE_INTERVAL`

      CVE 데이터베이스 업데이트 간격을 초 단위로 지정합니다.
      ``cve-update-db-native`` 명령어의 기본값은 "86400"으로, 하루에 한 번 실행됩니다.
      (24*60*60). 값이 "0"으로 설정되면 업데이트가 강제로 실행됩니다.
      매번 그렇습니다. 또는 "-1"과 같은 음수 값을 입력하면 비활성화됩니다.
      완전히 업데이트되었습니다.

### `CVE_PRODUCT`

      레시피에서, 레시피 이름과 일치하는 데 사용되는 이름을 정의합니다.
      상위 `NIST CVE 데이터베이스 <https://nvd.nist.gov/>`에 있는 이름과 대조합니다.

      기본값은 ${`BPN`}입니다(단, 상속받는 레시피는 제외).
      :ref:`ref-classes-pypi` 클래스는 다음을 기반으로 설정됩니다.
      `PYPI_PACKAGE`). NIST CVE에 있는 이름과 일치하지 않으면
      데이터베이스 또는 데이터베이스에 여러 항목이 있는 경우 기본값
      값을 변경해야 합니다.

      다음은 :oe_layerindex:`Berkeley DB 레시피 </layerindex/recipe/544>`의 예입니다.

         CVE_PRODUCT = "oracle_berkeley_db berkeley_db"

      때때로 제품명이 충분히 구체적이지 않은 경우가 있습니다. 예를 들어
      "tar"는 GNU ``tar`` 패키지와 관련된 CVE와 일치하며 또한
      `node-tar`는 Node.js 확장 프로그램입니다. 이 문제를 피하려면 다음을 사용하세요.
      공급업체 이름을 접두사로 사용합니다. 구문은 다음과 같습니다.

         CVE_PRODUCT = "벤더:패키지"

### `CVE_STATUS`

      패치되었거나 무시해야 하는 CVE ID입니다.
      :oe_layerindex:`Python3 레시피</layerindex/recipe/23823>`의 예시::

         CVE_STATUS[CVE-2020-15523] = "해당 플랫폼 없음: ​​이 문제는 Windows에서만 적용됩니다."

      형식은 "이유: 설명"이며, 설명은 선택 사항입니다.
      이유는 매핑을 통해 최종 CVE 상태에 매핑됩니다.
      `CVE_CHECK_STATUSMAP`. 자세한 내용은 :ref:`dev-manual/vulnerabilities:fixing vulnerabilities in recipes`를 참조하십시오.
      자세한 내용은 다음을 참조하세요.

### `CVE_STATUS_GROUPS`

      상태와 이유가 동일한 CVE가 많은 경우, 이 방법을 사용하면 간소화할 수 있습니다.
      `CVE_STATUS`::와 같은 유사한 줄 대신 변수를 사용하세요.

         CVE_STATUS_GROUPS = "CVE_STATUS_WIN CVE_STATUS_PATCHED"

         CVE_STATUS_WIN = "CVE-1234-0001 CVE-1234-0002"
         CVE_STATUS_WIN[status] = "not-applicable-platform: 이 문제는 Windows에서만 적용됩니다."
         CVE_STATUS_PATCHED = "CVE-1234-0003 CVE-1234-0004"
         CVE_STATUS_PATCHED[status] = "fixed-version: 외부에서 수정됨"

### `CVE_VERSION`

      레시피에서, 레시피 버전과 일치하는 데 사용되는 버전을 정의합니다.
      `NIST CVE 데이터베이스 <https://nvd.nist.gov/>`에 있는 버전과 비교합니다.
      :ref:`ref-classes-cve-check`를 사용할 때.

      기본값은 ${`PV`}이지만, 레시피에서 사용자 지정 버전 번호를 사용하는 경우
      이는 상위 소프트웨어 구성 요소 릴리스 버전과 일치하지 않으며, 버전 또한 마찬가지입니다.
      CVE 데이터베이스에서 사용되는 경우, 이 변수를 사용하여 설정할 수 있습니다.
      :ref:`ref-classes-cve-check`의 버전 번호입니다. 예시::

          CVE_VERSION = "2.39"

### `CVSDIR`

      CVS 시스템에서 체크아웃된 파일이 저장되는 디렉토리는 다음과 같습니다.
      저장됨.

### `CXX`

      C++ 컴파일러를 실행하는 데 사용되는 최소한의 명령어와 인수입니다.

### `CXXFLAGS`

      C++ 컴파일러에 전달할 플래그를 지정합니다. 이 변수는 다음과 같습니다.
      환경 변수로 내보내져서 보이게 되었습니다.
      컴파일 단계에서 빌드되는 소프트웨어.

      `CXXFLAGS`의 기본 초기화는 입력값에 따라 다릅니다.
      건설 중:

      - 빌드 시 `TARGET_CXXFLAGS`
         목표

      - 빌드 시 `BUILD_CXXFLAGS`를 사용합니다.
         호스트 빌드(예: ``-native``)

      - 빌드 시 `BUILDSDK_CXXFLAGS`
         SDK(예: ``nativesdk-``)의 경우

### `D`

      대상 디렉터리입니다. 빌드 디렉터리 내의 위치입니다.
      구성 요소가 설치되는 곳
      :ref:`ref-tasks-install` 작업. 이 위치는 기본값입니다.
      에게::

         ${WORKDIR}/이미지

      .. 메모::

         이 디렉터리에서 읽거나 쓰는 작업은 다음 권한으로 실행되어야 합니다.
         :ref:`fakeroot <overview-manual/concepts:fakeroot 및 pseudo>`.

### `DATE`

      빌드가 시작된 날짜입니다. 날짜는 연도, 월 순으로 표시됩니다.
      날짜는 일(YMD) 형식으로 표시됩니다(예: 2015년 2월 9일은 "20150209").

### `DATETIME`

      현재 빌드가 시작된 날짜 및 시간입니다. 형식은 다음과 같습니다.
      타임스탬프에 적합합니다.

### `DEBIAN_NOAUTONAME`

      :ref:`ref-classes-debian` 클래스가 상속될 때,
      이는 기본 동작이며, `DEBIAN_NOAUTONAME`은 다음을 지정합니다.
      데비안 라이브러리에 따르면 특정 패키지의 이름은 변경해서는 안 됩니다.
      패키지 이름 지정. 패키지 이름을 재정의 수단으로 사용해야 합니다.
      이 변수를 설정하세요. 다음은 `fontconfig` 레시피의 예시입니다.

         DEBIAN_NOAUTONAME:fontconfig-utils = "1"

### `DEBIANNAME`

      :ref:`ref-classes-debian` 클래스가 상속될 때,
      이는 기본 동작이며, `DEBIANNAME` 명령어를 사용하면 이 동작을 재정의할 수 있습니다.
      개별 패키지에 대한 라이브러리 이름입니다. 라이브러리 재정의
      이 경우 이름은 드물게 사용됩니다. 패키지 이름을 사용해야 합니다.
      이 변수를 설정할 때 재정의됩니다. 다음은 예시입니다.
      ``dbus`` 레시피::

         DEBIANNAME:${PN} = "dbus-1"

### `DEBUG_BUILD`

      디버깅 정보를 포함하여 패키지를 빌드하도록 지정합니다.
      `SELECTED_OPTIMIZATION` 변수의 값에 영향을 미칩니다.

### `DEBUG_OPTIMIZATION`

      `TARGET_CFLAGS`와 `CFLAGS`에 전달할 옵션은 다음과 같습니다.
      디버깅을 위해 시스템을 컴파일합니다. 이 변수의 기본값은 "-O"입니다.
      -fno-omit-frame-pointer ${DEBUG_FLAGS} -pipe".

### `DEBUG_PREFIX_MAP`

      ``-fdebug-prefix-map``과 같은 C 컴파일러 옵션을 설정할 수 있습니다.
      ``-fmacro-prefix-map`` 및 ``-ffile-prefix-map``은 다음을 허용합니다.
      디버깅 섹션에서 빌드 시간 경로를 설치 시간 경로로 바꿉니다.
      바이너리 파일의 경우, 컴파일러 출력 파일의 위치에 관계없이 컴파일이 가능합니다.
      디버거에게 알려주기 위해 추가 명령을 전달해야 한다는 단점이 있습니다.
      소스 파일이 있는 위치입니다.

      이는 Yocto 프로젝트에서 보증을 위해 사용됩니다.
      :doc:`/test-manual/reproducible-builds` 소스 코드가 있더라도
      패키지에서 `__FILE__` 또는 `assert()` 매크로를 사용합니다. 자세한 내용은 다음을 참조하세요.
      `reproducible-builds.org <https://reproducible-builds.org/docs/build-path/>`__
      자세한 내용은 웹사이트를 참조하세요.

      이 변수는 ``meta/conf/bitbake.conf`` 파일에 설정되어 있습니다.
      사용자가 설정할 수 있도록 설계되지 않았습니다.

### `DEFAULT_PREFERENCE`

      레시피 선택 우선순위에 대한 약한 편향을 지정합니다.

      이 변수의 가장 일반적인 사용법은 해당 변수를 "-1"로 설정하는 것입니다.
      소프트웨어 개발 버전을 위한 레시피.
      이런 식으로 변수를 사용하면 레시피의 안정적인 버전이 빌드됩니다.
      기본적으로 `PREFERRED_VERSION`이 사용되지 않는 경우
      개발 버전을 빌드합니다.

      .. 메모::

         `DEFAULT_PREFERENCE`에서 제공하는 편향은 미약하며 무시됩니다.
         `BBFILE_PRIORITY` 변수가 두 변수 간에 다른 경우
         같은 레시피의 여러 가지 버전이 담긴 층들.

### `DEFAULT_TIMEZONE`

      이미지에 설정된 시간대를 지정합니다.

      이 변수는 `tzdata` 패키지를 구성합니다.
      ``${sysconfdir}/localtime``에 따라 설정하세요. 유효한 값은 모든 파일입니다.
      ``CET`` 또는 ``Asia/Baku``와 같은 ``/usr/share/zoneinfo``에 있습니다.

### `DEFAULTTUNE`

      기본 CPU 및 애플리케이션 바이너리 인터페이스(ABI) 튜닝(예:
      OpenEmbedded 빌드 시스템에서 사용하는 "튜닝"입니다.
      `DEFAULTTUNE`은 정의하는 데 도움이 됩니다.
      `TUNE_FEATURES`.

      기본 설정은 암묵적으로 또는 명시적으로 설정됩니다.
      머신(MACHINE)입니다. 하지만, 재정의할 수 있습니다.
      정의된 대로 사용 가능한 곡을 사용하는 설정
      `사용 가능한 음악`.

### `DEPENDS`

      레시피의 빌드 시 필요한 종속성을 나열합니다. 이러한 종속성은 다음과 같습니다.
      내용(예: 헤더 및 공유 라이브러리)이 포함된 다른 레시피
      레시피를 만들 때 필요한 요소입니다.

      예를 들어, 다음과 같은 내용을 포함하는 레시피 `foo`를 생각해 보세요.
      과제::

          의존성 = "bar"

      이전 과제의 실질적인 효과는 모든 파일이
      bar에 의해 설치된 파일은 해당 스테이징 시스템 루트에서 사용할 수 있습니다.
      `STAGING_DIR* <STAGING_DIR>` 변수에 의해 주어지며,
      `foo`에 대한 `ref-tasks-configure` 작업이 실행됩니다. 이 메커니즘은 다음과 같습니다.
      :ref:`ref-tasks-configure`가 의존하도록 함으로써 구현됩니다.
      :ref:`ref-tasks-populate_sysroot` 각 레시피에 나열된 작업
      `의존적`, ~을 통해
      ``[``\ :ref:`deptask <bitbake-user-manual/bitbake-user-manual-metadata:variable flags>`\ ``]``
      :ref:`ref-classes-base` 클래스의 선언입니다.

      .. 메모::

         예를 들어 `STAGING_DIR_HOST`를 참조해야 하는 경우는 드뭅니다.
         명시적으로. 표준 클래스와 빌드 관련 변수는 다음과 같습니다.
         적절한 스테이징 시스템 루트를 자동으로 사용하도록 구성되어 있습니다.

      또 다른 예로, `DEPENDS`를 사용하여 유틸리티를 추가할 수도 있습니다.
      빌드 과정 중에 빌드 머신에서 실행되는 것들입니다. 예를 들어 레시피 같은 것들이죠.
      이는 `codegen` 레시피로 빌드된 코드 생성기를 사용합니다.
      다음과 같은 증상이 나타날 수 있습니다.

         DEPENDS = "codegen-native"

      더 많은 정보를 원하시면
      자세한 내용은 :ref:`ref-classes-native` 클래스를 참조하십시오.
      `EXTRANATIVEPATH` 변수.

      .. 메모::

         - `DEPENDS`는 레시피 이름 목록입니다. 더 정확히 말하자면,
            이것은 `PROVIDES` 이름 목록입니다.
            일반적으로 레시피 이름과 일치합니다. 패키지 이름을 다음과 같이 입력합니다.
            `DEPENDS`에서 "foo-dev"는 의미가 없습니다. "foo"를 사용하세요.
            대신 이렇게 하면 모든 패키지의 파일이 포함됩니다.
            `foo-dev`를 포함한 `foo`를 위로 올립니다.
            시스루트.

         - 의존성(DEPENDS) 관계에 있는 다른 레시피를 포함하는 레시피는 다음과 같은 방식으로 작동하지 않습니다.
            그 자체로 패키지 간의 런타임 종속성을 추가합니다.
            두 가지 레시피로 만들어집니다. 하지만, 앞서 설명드린 바와 같이
            ":ref:`개요-매뉴얼/개념:자동으로 추가된 런타임 종속성`"
            Yocto 프로젝트 개요 및 개념 설명서의 해당 섹션,
            런타임 종속성은 종종 자동으로 추가됩니다.
            대부분의 레시피에서는 `DEPENDS`만으로도 충분합니다.

         - 예상과 반대로, `DEPENDS`는 다음과 같은 경우에도 종종 필요합니다.
            미리 컴파일된 구성 요소를 설치하는 레시피. 예를 들어,
            ``libfoo``는 미리 컴파일된 라이브러리로, 해당 라이브러리에 링크됩니다.
            `libbar`를 사용한 다음 `libfoo`에 링크하려면 둘 다 필요합니다.
            `libfoo`와 `libbar`가 sysroot에 있어야 합니다.
            `libfoo`를 설치하는 레시피에 `DEPENDS`가 없으면
            `libbar`를 설치하는 레시피에 대해 다른 레시피들이
            `libfoo`에 대한 링크에 실패했습니다.

      런타임 종속성에 대한 자세한 내용은 `RDEPENDS`를 참조하십시오.
      변수입니다. 또한 다음을 확인할 수 있습니다.
      ":ref:`bitbake-user-manual/bitbake-user-manual-metadata:tasks`" 및
      ":ref:`bitbake-user-manual/bitbake-user-manual-execution:dependencies`"
      작업에 대한 자세한 내용은 BitBake 사용자 설명서의 해당 섹션을 참조하십시오.
      및 종속성.

### `DEPLOY_DIR`

      OpenEmbedded 빌드 시스템이 사용하는 일반적인 영역을 가리킵니다.
      준비된 이미지, 패키지, SDK 및 기타 출력 파일을 배치하십시오.
      빌드 시스템 외부에서 사용하기 위한 것입니다. 기본적으로 이 디렉터리는
      빌드 디렉터리 내에 `${TMPDIR}/deploy`로 존재합니다.

      빌드 디렉터리 구조에 대한 자세한 내용은 다음을 참조하세요.
      ":ref:`ref-manual/structure:빌드 디렉토리 --- ``build/```" 섹션.
      `deploy` 디렉터리의 내용에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`overview-manual/concepts:images`",
      ":ref:`overview-manual/concepts:package feeds`" 및
      ":ref:`overview-manual/concepts:application development sdk`" 섹션 모두
      Yocto 프로젝트 개요 및 개념 설명서.

### `DEPLOY_DIR_DEB`

      OpenEmbedded 빌드 시스템이 배치하는 영역을 가리킵니다.
      빌드 과정 외부에서 바로 사용할 수 있는 데비안 패키지
      시스템. 이 변수는 `PACKAGE_CLASSES`에 다음이 포함된 경우에만 적용됩니다.
      ":ref:`ref-classes-package_deb`".

      BitBake 설정 파일은 처음에 다음을 정의합니다.
      `DEPLOY_DIR_DEB` 변수를 하위 폴더로
      `DEPLOY_DIR`::

         DEPLOY_DIR_DEB = "${DEPLOY_DIR}/deb"

      :ref:`ref-classes-package_deb` 클래스는 다음을 사용합니다.
      `DEPLOY_DIR_DEB` 변수를 사용하여 다음을 확인하십시오.
      :ref:`ref-tasks-package_write_deb` 작업
      데비안 패키지를 적절한 폴더에 기록합니다. 자세한 내용은 다음을 참조하세요.
      포장이 어떻게 작동하는지에 대한 정보는 다음을 참조하세요.
      ":ref:`overview-manual/concepts:package feeds`" 섹션
      Yocto 프로젝트 개요 및 개념 설명서에 나와 있습니다.

### `DEPLOY_DIR_IMAGE`

      OpenEmbedded 빌드 시스템이 배치하는 영역을 가리킵니다.
      준비된 이미지 및 기타 관련 출력 파일
      대상 시스템에 배포됩니다. 디렉터리는 시스템별로 다릅니다.
      이 디렉터리에는 ``${MACHINE}``이라는 이름이 포함되어 있기 때문입니다. 기본적으로 이 디렉터리는
      빌드 디렉터리 내에 있습니다.
      ``${DEPLOY_DIR}/images/${MACHINE}/``.

      파일을 배포할 때 레시피에서 직접 사용해서는 안 됩니다. 대신,
      이 기능은 레시피가 이미 배포된 파일을 "읽어야" 할 때만 유용합니다.
      종속성으로 인해 발생합니다. 따라서 해당 내용은 다음과 같이 채워져야 합니다.
      :ref:`ref-classes-deploy` 클래스 또는 다음을 사용하여 `DEPLOYDIR`을 실행합니다.
      :ref:`ref-classes-image` 클래스에 의한 `IMGDEPLOYDIR`의 내용입니다.

      빌드 디렉터리의 구조에 대한 자세한 내용은 다음을 참조하세요.
      ":ref:`ref-manual/structure:빌드 디렉토리 --- ``build/```" 섹션.
      `deploy` 디렉터리의 내용에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`overview-manual/concepts:images`" 및
      ":ref:`overview-manual/concepts:application development sdk`" 섹션은 둘 다
      Yocto 프로젝트 개요 및 개념 설명서.

### `DEPLOY_DIR_IPK`

      OpenEmbedded 빌드 시스템이 배치하는 영역을 가리킵니다.
      빌드 시스템 외부에서 바로 사용할 수 있는 IPK 패키지입니다.
      이 변수는 `PACKAGE_CLASSES`에 다음 내용이 포함된 경우에만 적용됩니다.
      ":ref:`ref-classes-package_ipk`".

      BitBake 설정 파일은 처음에 이 변수를 다음과 같이 정의합니다.
      `DEPLOY_DIR`::의 하위 폴더

         DEPLOY_DIR_IPK = "${DEPLOY_DIR}/ipk"

      :ref:`ref-classes-package_ipk` 클래스는 `DEPLOY_DIR_IPK`를 사용합니다.
      :ref:`ref-tasks-package_write_ipk` 작업이 제대로 작동하는지 확인하기 위한 변수입니다.
      IPK 패키지를 해당 폴더에 저장합니다. 자세한 내용은 다음을 참조하십시오.
      포장이 어떻게 작동하는지에 대해서는 다음을 참조하세요.
      ":ref:`overview-manual/concepts:package feeds`" 섹션
      Yocto 프로젝트 개요 및 개념 설명서에 나와 있습니다.

### `DEPLOY_DIR_RPM`

      OpenEmbedded 빌드 시스템이 배치하는 영역을 가리킵니다.
      빌드 시스템 외부에서 바로 사용할 수 있는 RPM 패키지입니다.
      이 변수는 `PACKAGE_CLASSES`에 다음 내용이 포함된 경우에만 적용됩니다.
      ":ref:`ref-classes-package_rpm`".

      BitBake 설정 파일은 처음에 이 변수를 다음과 같이 정의합니다.
      `DEPLOY_DIR`::의 하위 폴더

         DEPLOY_DIR_RPM = "${DEPLOY_DIR}/rpm"

      :ref:`ref-classes-package_rpm` 클래스는 다음을 사용합니다.
      `DEPLOY_DIR_RPM` 변수를 사용하여 다음을 확인하십시오.
      :ref:`ref-tasks-package_write_rpm` 작업
      RPM 패키지를 지정된 폴더에 기록합니다. 자세한 내용은 다음을 참조하십시오.
      포장이 어떻게 작동하는지에 대해서는 다음을 참조하세요.
      ":ref:`overview-manual/concepts:package feeds`" 섹션
      Yocto 프로젝트 개요 및 개념 설명서에 나와 있습니다.

### `DEPLOYDIR`

      `ref-classes-deploy` 클래스를 상속받을 때,
      `DEPLOYDIR`은 배포된 파일을 위한 임시 작업 영역을 가리킵니다.
      :ref:`ref-classes-deploy` 클래스에 다음과 같이 설정되어 있습니다.

         DEPLOYDIR = "${WORKDIR}/deploy-${PN}"

      `:ref:`ref-classes-deploy` 클래스를 상속받는 레시피는 파일을 복사해야 합니다.
      `DEPLOYDIR` 디렉터리에 배포되며, 클래스가 복사 작업을 처리합니다.
      그것들을 `DEPLOY_DIR_IMAGE`로 이동시키세요.
      나중에.

### `DESCRIPTION`

      패키지 관리자가 사용하는 패키지 설명입니다. 설정되지 않은 경우,
      `DESCRIPTION`은 `SUMMARY`의 값을 가져옵니다.
      변하기 쉬운.

### `DEV_PKG_DEPENDENCY`

      레시피에서 런타임 권장 사항을 쉽게 비활성화하거나 조정할 수 있는 방법을 제공합니다.
      메인의 `${PN}-dev` 패키지에 대한 (`RRECOMMENDS`)
      (``${PN}``) 패키지.

### `DISABLE_STATIC`

      기본적으로 정적 링크를 비활성화하는 데 사용됩니다(저장을 위해).
      (정적 라이브러리는 임베디드 시스템에서 자주 사용되지 않으므로 공간을 차지합니다.)
      기본값은 " --disable-static "이지만 "로 설정할 수 있습니다.
      원하는 경우 정적 링크를 활성화하기 위해서입니다. 일부 레시피는 이 기능을 제공합니다.
      개별적으로도 있고, 또한 다음과 같은 것도 있습니다.
      ``meta/conf/distro/include/no-static-libs.inc`` 포함 파일
      일부 레시피에 대한 정적 링크를 비활성화합니다.
      패키지 또는 빌드 도구(예: CMake)는 다음을 명시적으로 지원합니다.
      정적 링크 활성화/비활성화, 그리고 그러한 경우에
      `DISABLE_STATIC`은 사용되지 않습니다.

### `DISTRO`

      배포판의 약칭입니다. 전체 명칭에 대한 정보는 다음을 참조하세요.
      배포판의 자세한 내용은 `DISTRO_NAME`을 참조하십시오.
      변하기 쉬운.

      `DISTRO` 변수는 배포 구성에 해당합니다.
      루트 이름이 변수의 인수와 동일하고 그 파일
      파일 확장자는 ``.conf``입니다. 예를 들어, 배포판
      Poky 배포판의 설정 파일 이름은 `poky.conf`입니다.
      그리고 해당 파일은 ``meta-poky/conf/distro`` 디렉터리에 있습니다.
      `소스 디렉토리`.

      ``poky.conf`` 파일 내에서 `DISTRO` 변수는 다음과 같이 설정됩니다.
      다음이 따릅니다::

         DISTRO = "poky"

      배포판 설정 파일은 `conf/distro` 폴더에 있습니다.
      `Metadata` 내의 디렉터리에는 다음이 포함됩니다.
      배포 구성. `DISTRO` 값에는 다음 내용이 포함되어서는 안 됩니다.
      공백이 있으며, 일반적으로 모두 소문자입니다.

      .. 메모::

         `DISTRO` 변수가 비어 있으면 기본 구성 세트가 사용됩니다.
         사용되는 것은 내부에 명시되어 있습니다.
         ``meta/conf/distro/defaultsetup.conf`` 파일도 소스 디렉터리에 있습니다.

### `DISTRO_CODENAME`

      빌드 중인 배포판의 코드명을 지정합니다.

### `DISTRO_EXTRA_RDEPENDS`

      모든 이미지에 추가할 배포판별 패키지 목록을 지정합니다.
      이 변수는 ``packagegroup-base``를 통해 적용되므로
      변수라는 용어는 실제로 기능이 더 풍부한 이미지에만 적용됩니다.
      `packagegroup-base`를 포함하세요. 이 변수를 사용하여 유지할 수 있습니다.
      일반 이미지에서 배포 정책을 제외합니다. 다른 모든 배포판과 마찬가지입니다.
      변수는 배포판의 ``.conf`` 파일에서 설정합니다.

### `DISTRO_EXTRA_RRECOMMENDS`

      배포판별 패키지 목록을 지정하여 모든 이미지에 추가합니다.
      패키지가 존재합니다. 패키지가 존재하지 않거나 비어 있을 수도 있습니다(예:
      커널 모듈). 패키지 목록은 자동으로 설치되지만
      삭제할 수 있습니다.

### `DISTRO_FEATURES`

      배포판에서 원하는 다양한 소프트웨어 지원
      특징. 배포판에서 배포판 특징을 정의합니다.
      설정 파일.

      대부분의 경우, 특징의 존재 여부는 다음과 같습니다.
      `DISTRO_FEATURES`는 제공된 적절한 옵션으로 변환됩니다.
      구성 스크립트를 실행하는 동안
      :ref:레시피에 대한 `ref-tasks-configure` 작업
      선택적으로 해당 기능을 지원합니다. 예를 들어, "x11"을 지정하는 경우
      `DISTRO_FEATURES`라는 용어는 해당 배포판용으로 빌드된 모든 소프트웨어에 적용됩니다.
      X11 지원을 선택적으로 수행할 수 있는 대상이 X11 지원을 갖도록 하려면
      활성화됨.

      .. 메모::

         단순히 `DISTRO_FEATURES`를 활성화하는 것만으로는 충분하지 않습니다.
         패키지에 대한 기능 지원을 활성화합니다. 예를 들어 다음과 같은 메커니즘이 있습니다.
         `PACKAGECONFIG` 트랙 `DISTRO_FEATURES`가 사용됩니다.
         패키지 기능을 활성화/비활성화합니다.

      블루투스와 NFS 지원도 두 가지 예입니다. 더 자세한 내용은 다음을 참조하세요.
      Yocto Project에 포함된 기능 목록 및 사용 가능한 기능
      이 변수를 제공하는 방법에 대한 자세한 내용은 ":ref:`ref-features-distro`" 섹션을 참조하십시오.

### `DISTRO_FEATURES_BACKFILL`

      `DISTRO_FEATURES`에 추가할 기능 목록을 공백으로 구분하여 입력하십시오.
      `DISTRO_FEATURES_BACKFILL_CONSIDERED`에도 존재하지 않는 경우.

      이 변수는 ``meta/conf/bitbake.conf`` 파일에 설정되어 있습니다.
      사용자가 설정할 수 있도록 설계된 것이 아닙니다. 참조하는 것이 가장 좋습니다.
      어떤 배포판 기능이 활성화되어 있는지 확인하기 위한 변수입니다.
      :ref:`모든 배포판 구성에 대해 <ref-features-backfill>`이 백필되었습니다.

### `DISTRO_FEATURES_BACKFILL_CONSIDERED`

      `DISTRO_FEATURES_BACKFILL`에서 가져온 기능 목록을 공백으로 구분합니다.
      그것은 :ref:`백필 <ref-features-backfill>` (즉, 추가됨)이 되어서는 안 됩니다.
      빌드 중에 `DISTRO_FEATURES`로 이동합니다.

      이는 선택 해제 메커니즘에 해당합니다. 새로운 기본 배포판이 출시될 때
      새로운 기능이 도입되면 배포판 관리자가 검토(고려)할 수 있습니다.
      그들을 제외하고 제외하기로 결정한다.
      :ref:`백필된 <ref-features-backfill>` 기능입니다. 따라서
      `DISTRO_FEATURES_BACKFILL`과 조합
      `DISTRO_FEATURES_BACKFILL_CONSIDERED`를 사용하면 가능합니다.
      기존 배포판을 손상시키지 않고 새로운 기본 기능을 추가합니다.


### `DISTRO_FEATURES_DEFAULT`

      기본 배포판 목록을 제공하는 편의 변수입니다.
      C 라이브러리에 특정한 기능을 제외한 모든 기능
      (``libc``).

      사용자 지정 배포판을 만들 때 다음 사항이 유용할 수 있습니다.
      기본값을 재사용할 수 있습니다
      `DISTRO_FEATURES` 옵션 없이
      전체 집합을 모두 작성해야 합니다. 다음은 이를 사용하는 예입니다.
      사용자 지정 배포판 구성 파일의 `DISTRO_FEATURES_DEFAULT`::

         DISTRO_FEATURES ?= "${DISTRO_FEATURES_DEFAULT} myfeature"

### `DISTRO_FEATURES_FILTER_NATIVE`

      대상에 존재할 경우 적용되는 기능 목록을 지정합니다.
      `DISTRO_FEATURES` 값은 다음과 같아야 합니다.
      네이티브 레시피를 빌드할 때 `DISTRO_FEATURES`에 포함됩니다.
      이 변수는 필터링에 사용된 특징 외에 추가로 사용됩니다.
      `DISTRO_FEATURES_NATIVE`
      변하기 쉬운.

### `DISTRO_FEATURES_FILTER_NATIVESDK`

      대상에 존재할 경우 적용되는 기능 목록을 지정합니다.
      `DISTRO_FEATURES` 값은 포함되어야 합니다.
      :ref:`ref-classes-nativesdk`를 빌드할 때 `DISTRO_FEATURES`를 사용합니다.
      레시피. 이 변수는 필터링에 사용된 기능 외에 추가로 사용됩니다.
      `DISTRO_FEATURES_NATIVESDK` 변수.

### `DISTRO_FEATURES_NATIVE`

      포함해야 할 기능 목록을 지정합니다.
      네이티브 빌드 시 `DISTRO_FEATURES`
      레시피. 이 변수는 필터링된 기능 외에 추가로 사용됩니다.
      사용
      `DISTRO_FEATURES_FILTER_NATIVE`
      변하기 쉬운.

### `DISTRO_FEATURES_NATIVESDK`

      포함해야 할 기능 목록을 지정합니다.
      빌드 시 `DISTRO_FEATURES`
      :ref:`ref-classes-nativesdk` 레시피. 이 변수는 사용됩니다.
      필터링된 기능 외에도
      `DISTRO_FEATURES_FILTER_NATIVESDK` 변수.

### `DISTRO_NAME`

      배포판의 정식 명칭입니다. 약식 명칭에 대한 정보는 다음을 참조하세요.
      배포에 대한 자세한 내용은 `DISTRO` 변수를 참조하십시오.

      ``DISTRO_NAME` 변수는 배포판에 해당합니다.
      루트 이름이 변수 이름과 동일한 구성 파일
      인수는 ``.conf``이고 파일 이름 확장자는 ``.conf``입니다. 예를 들어,
      Poky 배포판의 배포 구성 파일 이름은 다음과 같습니다.
      `poky.conf` 파일은 `meta-poky/conf/distro` 디렉토리에 있습니다.
      `소스 디렉터리`의 일부입니다.

      `poky.conf` 파일 내에서 ``DISTRO_NAME` 변수가 설정됩니다.
      다음과 같습니다::

         DISTRO_NAME = "Poky(Yocto 프로젝트 참조 배포판)"

      배포판 설정 파일은 `conf/distro` 폴더에 있습니다.
      `Metadata` 내의 디렉터리에는 다음이 포함됩니다.
      배포 구성.

      .. 메모::

         `DISTRO_NAME` 변수가 비어 있으면 기본값 세트가 사용됩니다.
         구성이 사용되며, 이는 내부에 명시되어 있습니다.
         ``meta/conf/distro/defaultsetup.conf`` 파일도 소스 디렉터리에 있습니다.

### `DISTRO_VERSION`

      배포 버전입니다.

### `DISTROOVERRIDES`

      현재 설정에 특정한 재정의 목록을 콜론으로 구분하여 표시합니다.
      배포. 기본적으로 이 목록에는 다음 값이 포함됩니다.
      `배포`.

      `DISTROOVERRIDES`를 확장하여 추가적인 재정의를 추가할 수 있습니다.
      배포에 적용합니다.

      `DISTROOVERRIDES`의 기본 메커니즘은 간단합니다.기본값에 포함되어 
      있습니다 .
      `재정의`.

      다음은 :yocto_git:`meta-poky/conf/distro/poky-tiny.conf`의 예입니다.
      </poky/tree/meta-poky/conf/distro/poky-tiny.conf>`::

         DISTROOVERRIDES = "poky:poky-tiny"

### `DL_DIR`

      빌드 프로세스에서 사용하는 중앙 다운로드 디렉터리
      다운로드. 기본적으로 `DL_DIR`은 미러링에 적합한 파일을 가져옵니다.
      Git 저장소를 제외한 모든 것에 해당됩니다. Git의 tarball을 원하시면...
      저장소를 사용하려면 다음을 사용하십시오.
      `BB_GENERATE_MIRROR_TARBALLS`
      변하기 쉬운.

      `DL_DIR` 변수를 정의하여 이 디렉토리를 설정할 수 있습니다.
      `conf/local.conf` 파일입니다. 이 디렉터리는 자체적으로 관리되며,
      건드릴 필요가 없습니다. 기본적으로 디렉토리는 다음과 같습니다.
      빌드 디렉터리의 `다운로드`::

         #DL_DIR ?= "${TOPDIR}/downloads"

      다른 다운로드 디렉토리를 지정하려면,
      해당 줄의 주석을 제거하고 디렉토리 경로를 제공하면 됩니다.

      첫 번째 빌드 과정에서 시스템은 다양한 소스 코드를 다운로드합니다.
      다양한 상위 프로젝트의 tarball 파일입니다. 다운로드에는 시간이 걸릴 수 있습니다.
      특히 네트워크 연결 속도가 느린 경우라면, 타르볼은 유용합니다.
      모든 파일은 ``DL_DIR`로 정의된 디렉터리에 저장되며 빌드됩니다.
      시스템은 소스 tarball을 찾기 위해 먼저 그곳을 살펴봅니다.

      .. 메모::

         시스템을 완전히 삭제하고 다시 구축할 때 이 디렉토리를 보존할 수 있습니다.
         이후 빌드에서 이 부분의 속도를 높이세요.

      이 디렉토리는 여러 빌드 간에 안전하게 공유할 수 있습니다.
      동일한 개발 환경입니다. 빌드 방법에 대한 자세한 내용은 다음을 참조하세요.
      방화벽이나 프록시 뒤에서 작업할 때 프로세스가 소스 파일을 가져옵니다.
      서버 관련 문의는 ":doc:`/ref-manual/faq`"에서 확인하세요.
      챕터입니다. 또한 다음을 참조할 수도 있습니다.
      ":yocto_wiki:`네트워크 프록시 뒤에서 작업하기 </Working_Behind_a_Network_Proxy>`"
      위키 페이지.

### `DOC_COMPRESS`

      :ref:`ref-classes-compress_doc`를 상속할 때
      클래스에서 이 변수는 압축 시 사용되는 압축 정책을 설정합니다.
      OpenEmbedded 빌드 시스템은 매뉴얼 및 정보 페이지를 압축합니다.
      기본적으로 사용되는 압축 방식은 gz(gzip)입니다. 기타 정책
      사용 가능한 버전은 xz와 bz2입니다.

      정책 및 이 변수 ​​사용 방법에 대한 자세한 내용은 다음을 참조하십시오.
      ``meta/classes-recipe/compress_doc.bbclass`` 파일의 주석입니다.

### `DT_FILES`

      컴파일에 사용할 장치 트리 소스 파일 목록을 공백으로 구분하여 나열합니다.
      `ref-classes-devicetree` 클래스를 상속하는 레시피입니다.
      이는 `DT_FILES_PATH`에 상대적입니다.

      편의상 `.dts`와 `.dtb` 확장자 모두 사용할 수 있습니다.

      모든 장치 트리 소스를 빌드하려면 빈 문자열(기본값)을 사용하십시오.
      `DT_FILES_PATH` 디렉터리.

### `DT_FILES_PATH`

      레시피를 사용하여 트리 외부의 장치 트리 소스를 컴파일할 때
      :ref:`ref-classes-devicetree` 클래스를 상속하며, 이 변수는 다음을 지정합니다.
      빌드할 dts 파일이 포함된 디렉터리의 경로입니다.

      기본값은 `S` 디렉터리입니다.

### `DT_PADDING_SIZE`

      `ref-classes-devicetree` 클래스를 상속할 때, 이 변수는
      장치 트리 블롭에 추가되는 패딩의 크기를 지정합니다.
      추가 공간은 일반적으로 부팅 중에 추가 속성을 저장하는 데 사용됩니다.

### `EFI_ARCH`

      EFI 표준 내의 CPU 아키텍처 이름입니다. 설정 위치:
      :oe_git:`meta/conf/image-uefi.conf
      `<openembedded-core/tree/meta/conf/image-uefi.conf>`.

### `EFI_PROVIDER`

      부팅 가능한 이미지를 빌드할 때 (즉, ``hddimg``, ``iso`` 또는
      ``wic.vmdk``는 `IMAGE_FSTYPES`에 있습니다.
      `EFI_PROVIDER` 변수는 사용할 EFI 부트로더를 지정합니다.
      기본값은 "grub-efi"이지만, "systemd-boot"를 대신 사용할 수도 있습니다.

      :ref:`ref-classes-systemd-boot` 및 :ref:`ref-classes-image-live`를 참조하십시오.
      자세한 내용은 수업을 참조하세요.

### `EFI_UKI_DIR`

      EFI 시스템 파티션 내에서 UKI 이미지의 주요 위치입니다.

### `EFI_UKI_PATH`

      루트 파일 시스템 내에서 UKI 이미지의 경로입니다.

### `ENABLE_BINARY_LOCALE_GENERATION`

      `glibc`에 대해 어떤 로케일을 생성할지 제어하는 ​​변수입니다.
      빌드 중에 (대상 장치의 RAM이 64MB 이상인 경우 유용함)
      더 적은).

### `ERR_REPORT_DIR`

      `ref-classes-report-error` 클래스와 함께 사용될 때, 다음을 지정합니다.
      :ref:`오류 보고`에 의해 생성된 디버그 파일을 저장하는 데 사용되는 경로
      도구 <dev-manual/error-reporting-tool:오류 보고 도구 사용>`,
      이를 통해 발생하는 빌드 오류를 중앙 저장소에 제출할 수 있습니다.
      데이터베이스. 기본적으로 이 변수의 값은 다음과 같습니다.
      ``${``\ `LOG_DIR`\ ``}/error-report``.

      ``ERR_REPORT_DIR``을 오류를 저장할 경로로 설정할 수 있습니다.
      디버그 파일을 다음과 같이 저장하는 보고 도구입니다.
      ``local.conf`` 파일::

         ERR_REPORT_DIR = "경로"

### `ERROR_QA`

      실패 시 보고되는 품질 보증 검사를 지정합니다.
      OpenEmbedded 빌드 시스템에서 발생하는 오류입니다. 이 변수는 다음 위치에서 설정합니다.
      배포 구성 파일입니다. 검사 목록을 보려면 다음을 참조하세요.
      이 변수를 통해 제어할 수 있습니다. 자세한 내용은 다음을 참조하세요.
      ":ref:`ref-classes-insane`" 섹션.

### `ESDK_CLASS_INHERIT_DISABLE`

      `INHERIT`에서 제거할 클래스 목록
      확장 가능한 SDK 구성 내에서 전역적으로 값을 지정합니다.
      :ref:`populate-sdk-ext <ref-classes-populate-sdk-*>` 클래스는 다음을 설정합니다.
      기본값::

         ESDK_CLASS_INHERIT_DISABLE ?= "buildhistory"

      일부 클래스는 확장 가능한 SDK 내에서 일반적으로 적용되지 않습니다.
      컨텍스트입니다. 이 변수를 사용하여 해당 클래스를 비활성화할 수 있습니다.

      확장 가능한 SDK를 사용자 지정하는 방법에 대한 자세한 내용은 다음을 참조하십시오.
      구성에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`sdk-manual/appendix-customizing:확장 가능한 SDK 구성`"
      Yocto 프로젝트 애플리케이션 개발 섹션 및
      확장형 소프트웨어 개발 키트(eSDK) 설명서.

### `ESDK_LOCALCONF_ALLOW`

      OpenEmbedded 빌드에서 허용되는 변수 목록
      시스템 구성을 확장 가능한 SDK 구성으로 변환합니다.
      기본적으로 변수 목록은 비어 있으며 다음과 같이 설정됩니다.
      :ref:`populate-sdk-ext <ref-classes-populate-sdk-*>` 클래스.

      이 목록은 다음을 사용하여 지정된 변수를 재정의합니다.
      `ESDK_LOCALCONF_REMOVE` 변수와 함께
      슬래시(/) 문자로 인해 다른 변수들이 자동으로 추가됩니다.
      시작 부분에서 발견됨
      값은 일반적으로 경로를 나타내므로 그렇지 않을 수도 있습니다.
      SDK가 설치된 시스템에서 유효해야 합니다.

      확장 가능한 SDK를 사용자 지정하는 방법에 대한 자세한 내용은 다음을 참조하십시오.
      구성에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`sdk-manual/appendix-customizing:확장 가능한 SDK 구성`"
      Yocto 프로젝트 애플리케이션 개발 섹션 및
      확장형 소프트웨어 개발 키트(eSDK) 설명서.

### `ESDK_LOCALCONF_REMOVE`

      OpenEmbedded 빌드에서 허용되지 않는 변수 목록
      시스템 구성을 확장 가능한 SDK 구성으로 변환합니다. 일반적으로,
      이것들은 해당 기기에 특정한 변수들입니다.
      빌드 시스템이 실행 중이므로 잠재적으로 문제가 발생할 수 있습니다.
      확장 가능한 SDK 내에서.

      기본적으로 `ESDK_LOCALCONF_REMOVE`가 설정되어 있습니다.
      :ref:`populate-sdk-ext <ref-classes-populate-sdk-*>` 클래스 및
      다음 변수들은 제외됩니다:

      - `CONF_VERSION`
      - `BB_NUMBER_THREADS`
      - `BB_NUMBER_PARSE_THREADS`
      - `PARALLEL_MAKE`
      - `PRSERV_HOST`
      - `SSTATE_MIRRORS` `DL_DIR`
      - `SSTATE_DIR` `TMPDIR`
      - `BB_SERVER_TIMEOUT`

      확장 가능한 SDK를 사용자 지정하는 방법에 대한 자세한 내용은 다음을 참조하십시오.
      구성에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`sdk-manual/appendix-customizing:확장 가능한 SDK 구성`"
      Yocto 프로젝트 애플리케이션 개발 섹션 및
      확장형 소프트웨어 개발 키트(eSDK) 설명서.

### `SHLIBS에서 제외`

      OpenEmbedded 빌드 시스템의 공유 라이브러리 리졸버를 실행합니다.
      공유 라이브러리를 검색할 때 전체 패키지를 제외합니다.

      .. 메모::

         공유 라이브러리 리졸버의 기능은 부분적으로 다음에서 비롯됩니다.
         내부 함수 ``package_do_shlibs``는 다음의 일부입니다.
         :ref:`ref-tasks-package` 작업입니다. 공유되는 항목에 유의해야 합니다.
         라이브러리 리졸버는 라이브러리 간의 일부 종속성을 암묵적으로 정의할 수 있습니다.
         패키지.

      ``EXCLUDE_FROM_SHLIBS` 변수는 다음과 유사합니다.
      `PRIVATE_LIBS` 변수는 다음을 제외합니다.
      패키지 전체가 아닌 패키지에 포함된 특정 라이브러리만 해당됩니다.

      `EXCLUDE_FROM_SHLIBS` 변수를 사용하려면 해당 변수를 "1"로 설정하십시오.
      특정 패키지::

         EXCLUDE_FROM_SHLIBS = "1"

### `EXCLUDE_FROM_WORLD`

      BitBake에게 월드 빌드에서 특정 레시피를 제외하도록 지시합니다(예:
      ``bitbake world``). 월드 빌드 과정에서 BitBake는 파일을 찾고, 구문 분석하고,
      모든 레이어에 노출된 모든 레시피를 빌드합니다.
      ``bblayers.conf`` 설정 파일.

      이 변수를 사용하여 월드 빌드에서 레시피를 제외하려면 다음을 설정하세요.
      레시피에서 변수를 "1"로 설정합니다.

      .. 메모::

         `EXCLUDE_FROM_WORLD`에 추가된 레시피도 빌드 과정에서 여전히 사용될 수 있습니다.
         다른 레시피의 의존성을 충족시키기 위해 월드를 구축합니다. 추가
         레시피에 `EXCLUDE_FROM_WORLD`를 지정하면 해당 레시피가 `EXCLUDE_FROM_WORLD`에 포함되지 않도록 보장할 뿐입니다.
         월드 빌드의 빌드 대상 목록에 명시적으로 추가되었습니다.

### `EXTENDPE`

      레시피의 접두사를 만들기 위해 파일 이름 및 경로명과 함께 사용됩니다.
      레시피의 `PE` 값에 따라 버전이 결정됩니다. `PE`인 경우
      레시피에 대해 값이 설정되고 0보다 크면 `EXTENDPE`는 다음과 같이 됩니다.
      값(예: `PE`가 "1"과 같으면 `EXTENDPE`는 "1"이 됩니다).
      레시피의 `PE` 속성이 설정되지 않았거나(기본값) 0인 경우,
      `EXTENDPE`는 ""가 됩니다.

      예시를 보려면 `STAMP` 변수를 참조하십시오.

### `EXTENDPKGV`

      최종 버전에 나타나는 전체 패키지 버전 사양
      레시피에 의해 생성된 패키지입니다. 해당 변수의 값은 일반적으로 사용됩니다.
      런타임 종속성을 다른 버전과 완전히 동일한 버전으로 수정하기 위해
      같은 레시피로 포장하세요::

         RDEPENDS:${PN}-additional-module = "${PN} (= ${EXTENDPKGV})"

      종속성 관계는 패키지를 강제하기 위한 것입니다.
      관리자가 이러한 유형의 패키지를 순차적으로 업그레이드하도록 합니다.

### `EXTERNAL_KERNEL_DEVICETREE`

      :ref:`ref-classes-kernel-fit-image`를 상속할 때
      `virtual/dtb`에 대한 `preferred_provider`가 `devicetree`로 설정되었습니다.
      변수 `EXTERNAL_KERNEL_DEVICETREE`는 다음을 지정하는 데 사용할 수 있습니다.
      컴파일된 디바이스 트리 또는 디바이스 트리가 하나 이상 포함된 디렉터리
      사용할 오버레이입니다.

### `EXTERNAL_KERNEL_TOOLS`

      설정된 경우, `EXTERNAL_KERNEL_TOOLS` 변수는 이러한 도구들을 나타냅니다.
      도구는 소스 트리에 없습니다.

      커널 도구가 해당 트리에 포함되어 있으면, 해당 도구가 우선적으로 사용됩니다.
      외부에서 설치된 도구. `EXTERNAL_KERNEL_TOOLS` 설정
      이 변수는 OpenEmbedded 빌드 시스템이 설치된 버전을 우선적으로 사용하도록 지시합니다.
      외부 도구. :ref:`ref-classes-kernel-yocto` 클래스를 참조하세요.
      ``meta/classes-recipe``를 클릭하면 해당 변수가 어떻게 사용되는지 확인할 수 있습니다.

### `EXTERNAL_TOOLCHAIN`

      사용하려는 경우
      :ref:`외부 툴체인 <dev-manual/external-toolchain:외부 툴체인을 선택적으로 사용>`,
      이 변수를 사용하면 이 툴체인이 설치된 디렉토리를 지정할 수 있습니다.
      설치되었습니다.

### `EXTERNALSRC`

      :ref:`ref-classes-externalsrc`를 상속할 때
      클래스에서 이 변수는 소스 트리를 가리키는데, 이 소스 트리는 클래스 외부에 있습니다.
      OpenEmbedded 빌드 시스템입니다. 이 변수가 설정되면 다음이 지정됩니다.
      OpenEmbedded 빌드에서 사용하는 `S` 변수입니다.
      이 시스템은 압축 해제된 레시피 소스 코드를 찾는 데 사용됩니다.

      자세한 내용은 ":ref:`ref-classes-externalsrc`" 섹션을 참조하십시오.
      이 변수를 사용하는 방법에 대한 정보도 찾을 수 있습니다.
      ":ref:`dev-manual/building:외부 소스에서 소프트웨어 빌드`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `EXTERNALSRC_BUILD`

      :ref:`ref-classes-externalsrc`를 상속할 때
      클래스에서 이 변수는 레시피 파일이 있는 디렉토리를 가리킵니다.
      소스 코드가 빌드되는데, 이는 OpenEmbedded 빌드 과정과는 별개입니다.
      시스템. 이 변수가 설정되면 `B` 변수가 설정됩니다.
      이는 OpenEmbedded 빌드 시스템이 해당 파일을 찾는 데 사용하는 것입니다.
      `디렉토리 빌드`.

      자세한 내용은 ":ref:`ref-classes-externalsrc`" 섹션을 참조하십시오.
      이 변수를 사용하는 방법에 대한 정보도 찾을 수 있습니다.
      ":ref:`dev-manual/building:외부 소스에서 소프트웨어 빌드`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `EXTRA_AUTORECONF`

      :ref:`ref-classes-autotools`를 상속하는 레시피의 경우
      클래스의 경우, ``EXTRA_AUTORECONF`를 사용하여 추가 옵션을 지정할 수 있습니다.
      실행 중에 실행되는 ``autoreconf`` 명령에 전달합니다.
      :ref:`ref-tasks-configure` 작업.

      기본값은 "--exclude=autopoint"입니다.

### `EXTRA_IMAGE_FEATURES`

      이미지에 포함할 추가 기능 목록입니다. 목록을 작성할 때 사용합니다.
      특징이 두 개 이상일 경우 공백으로 구분하세요.

      일반적으로 이 변수는 ``local.conf`` 파일에서 구성합니다.
      빌드 디렉터리에서 찾을 수 있습니다. 이 파일을 사용할 수도 있지만,
      레시피 내의 변수를 사용하는 것은 바람직하지 않으며, 모범 사례에 따르면 그렇게 하지 않는 것이 좋습니다.

      .. 메모::

         이미지 레시피 내에서 주요 기능을 활성화하려면 다음을 사용하십시오.
         `IMAGE_FEATURES` 변수.

      다음은 추가할 수 있는 기능의 몇 가지 예입니다.

        - "dbg-pkgs" --- 설치된 모든 패키지에 -dbg 패키지를 추가합니다.
          디버깅 및 프로파일링을 위한 심볼 정보입니다.

        - "빈 루트 암호" --- 이 기능은 다음과 같은 경우에 사용할 수 있습니다.
          루트 사용자가 비밀번호를 비워둔 상태로 로그인할 수 있도록 허용합니다.
        - "allow-empty-password" --- Dropbear 및 OpenSSH가 빈 암호를 허용하도록 설정합니다.
          비밀번호 문자열이 비어 있는 계정에서의 로그인.
        - "allow-root-login" --- Dropbear 및 OpenSSH에서 루트 로그인을 허용합니다.
        - "설치 후 로깅" --- 설치 후 스크립트 실행 로그를 활성화합니다.
          이미지의 첫 부팅 시 ``/var/log/postinstall.log`` 파일에 기록됩니다.
          대상 시스템.
        - "dev-pkgs" --- 설치된 모든 패키지에 -dev 패키지를 추가합니다. 이것은
          이미지에 포함된 라이브러리를 사용하여 개발하려는 경우 유용합니다.
        - "read-only-rootfs" --- 루트 파일 시스템이 읽기 전용인 이미지를 생성합니다.
          읽기 전용입니다. 자세한 내용은 다음을 참조하세요.
          ":ref:`dev-manual/read-only-rootfs:읽기 전용 루트 파일 시스템 생성`"
          자세한 내용은 Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션을 참조하십시오.
          정보
        - "tools-debug" --- gdb 및 strace와 같은 디버깅 도구를 추가합니다.
        - "tools-sdk" --- gcc, make 등의 개발 도구를 추가합니다.
          pkgconfig 등.
        - "tools-testapps" --- 유용한 테스트 도구를 추가합니다.
          ts_print, aplay, arecord 등과 같은 함수들입니다.

      Yocto에 포함된 이미지 기능의 전체 목록은 다음과 같습니다.
      프로젝트에 대한 자세한 내용은 ":ref:`ref-features-image`" 섹션을 참조하십시오.

      이 예시를 통해 이미지를 사용자 지정하는 방법을 알아보겠습니다.
      변수에 대한 자세한 내용은 ":ref:`dev-manual/customizing-images:custom \`\`image_features\`\` 및 \`\`extra_image_features\`\``를 참조하세요."
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `EXTRA_IMAGECMD`

      이미지 생성 명령에 대한 추가 옵션을 지정합니다.
      `IMAGE_CMD`에 지정되었습니다. 설정할 때
      이 변수에 연결된 이미지 유형에 대한 재정의를 사용하십시오. 다음은 그 예입니다.
      예시:

         EXTRA_IMAGECMD:ext3 ?= "-i 4096"

### `EXTRA_IMAGEDEPENDS`

      패키지를 제공하지 않는 빌드 레시피 목록
      루트 파일 시스템에 설치합니다.

      최종 이미지를 만들기 위해 레시피가 필요한 경우도 있지만, 반드시 필요한 것은 아닙니다.
      루트 파일 시스템에 필요합니다. `EXTRA_IMAGEDEPENDS`를 사용할 수 있습니다.
      이 레시피들을 나열하고 따라서 종속성을 지정하는 변수입니다.
      대표적인 예로는 시스템 구성에 필요한 부트로더가 있습니다.

      .. 메모::

         루트 파일 시스템에 패키지를 추가하는 방법은 다양한 문서를 참조하십시오.
         `RDEPENDS` 및 `RRECOMMENDS` 변수.

### `EXTRA_OECMAKE`

      추가 `CMake <https://cmake.org/overview/>`__ 옵션은 다음을 참조하십시오.
      추가 정보는 `ref-classes-cmake` 클래스를 참조하세요.

### `EXTRA_OECONF`

      추가 `configure` 스크립트 옵션은 다음을 참조하세요.
      `PACKAGECONFIG_CONFARGS`에 대한
      구성 스크립트 옵션 전달에 대한 추가 정보입니다.

### `EXTRA_OEMAKE`

      추가 GNU `make` 옵션.

      `EXTRA_OEMAKE`의 기본값이 ""이므로, 설정을 해야 합니다.
      필요한 GNU 옵션을 지정하는 변수입니다.

      `PARALLEL_MAKE` 및
      `PARALLEL_MAKEINST`도 사용합니다.
      필수 플래그를 전달하려면 `EXTRA_OEMAKE`를 사용하세요.

### `EXTRA_OEMESON`

      추가 `Meson <https://mesonbuild.com/>` 옵션은 다음을 참조하세요.
      추가 정보는 `ref-classes-meson` 클래스를 참조하세요.

      표준 Meson 옵션 외에도 다음과 같은 옵션이 있습니다.
      `Meson 빌드 옵션 <https://mesonbuild.com/Build-options.html>`__
      빌드할 소스의 ``meson_options.txt`` 파일에 정의되어 있습니다.
      다음은 예시입니다.

         EXTRA_OEMESON = "-Dpython=disabled -Dvalgrind=disabled"

      Meson의 `--buildtype` 옵션에 대한 사용자 지정 값은 다음과 같습니다.
      `MESON_BUILDTYPE` 변수를 통해 설정해야 합니다.

### `EXTRA_OESCONS`

      `ref-classes-scons` 클래스를 상속받을 때, 이것은
      이 변수는 전달하고자 하는 추가 구성 옵션을 지정합니다.
      `scons` 명령줄로 이동합니다.

### `EXTRA_USERS_PARAMS`

      :ref:`ref-classes-extrausers`를 상속할 때
      클래스에서 이 변수는 이미지 수준의 사용자 및 그룹 작업을 제공합니다.
      이는 사용자와 그룹을 제공하는 보다 포괄적인 방법입니다.
      구성 방식과 사용 방식을 비교했을 때
      :ref:`ref-classes-useradd` 클래스는 사용자와 연결됩니다.
      특정 레시피에 맞춰 그룹 구성을 지정합니다.

      설정할 수 있는 명령어 목록은 다음과 같습니다.
      `EXTRA_USERS_PARAMS`는 다음과 같이 표시됩니다.
      :ref:`ref-classes-extrausers` 클래스. 이 명령들은 일반적인 명령에 매핑됩니다.
      같은 이름을 가진 유닉스 명령어들::

         # EXTRA_USERS_PARAMS = "\
         # useradd -p '' 테스터; \
         # 개발자 그룹 추가; \
         # 사용자 삭제 없음; \
         # 그룹델 -g 비디오; \
         # groupmod -g 1020 developers; \
         # usermod -s /bin/sh tester; \
         # "

      하드코딩된 비밀번호는 ``-p`` 매개변수를 통해 지원됩니다.
      `useradd` 또는 `usermod`를 사용하지만, 해시값만 사용됩니다.

      다음은 "tester-jim"과 "tester-sue"라는 두 사용자를 추가하고 권한을 할당하는 예입니다.
      비밀번호. 먼저 호스트에서 (이스케이프 처리된) 비밀번호 해시를 생성합니다.

         printf "%q" $(mkpasswd -m sha256crypt tester01)

      결과로 생성된 해시는 변수에 저장되고 `useradd` 명령의 매개변수로 사용됩니다.

         추가 사용자를 상속합니다.
         PASSWD = "\$X\$ABC123\$A-Long-Hash"
         EXTRA_USERS_PARAMS = "\
             useradd -p '${PASSWD}' tester-jim; \
             useradd -p '${PASSWD}' tester-sue; \
             "

      마지막으로, 루트 암호를 설정하는 예시를 보여드리겠습니다.

         추가 사용자를 상속합니다.
         EXTRA_USERS_PARAMS = "\
             usermod -p '${PASSWD}' root; \
             "

      .. 메모::

         보안 관점에서 볼 때 기본 비밀번호를 하드코딩하는 것은 바람직하지 않습니다.
         일반적으로 좋은 생각이며, 일부 관할 지역에서는 합법적이기도 합니다.
         프로덕션 환경을 구축하는 경우에는 이렇게 하지 않는 것이 좋습니다.
         영상.

      또한, 특별한 ``passwd-expire`` 명령어가 있습니다.
      사용자의 비밀번호가 만료되도록 하여 비밀번호를 변경하도록 강제합니다.
      예를 들어, 첫 로그인 시에:

         EXTRA_USERS_PARAMS += " useradd myuser; passwd-expire myuser;"

      .. 메모::

         현재로서는 `passwd-expire`는 다음과 같은 경우에만 원격 로그인에 대해 작동할 수 있습니다.
         Dropbear 대신 OpenSSH를 SSH 서버로 사용합니다.

### `EXTRANATIVEPATH`

      하위 디렉토리 목록
      ``${``\ `STAGING_BINDIR_NATIVE`\ ``}``
      환경 변수 `PATH`의 시작 부분에 추가되었습니다.
      예를 들어, 다음은 앞에 추가됩니다.
      "${STAGING_BINDIR_NATIVE}/foo:${STAGING_BINDIR_NATIVE}/bar:" ~
      ``경로``::

         EXTRANATIVEPATH = "foo bar"

### `FAKEROOT`

      BitBake 설명서에서 ``bitbake:FAKEROOT`를 참조하십시오.

### `FAKEROOTBASEENV`

      BitBake 설명서에서 ``bitbake:FAKEROOTBASEENV`를 참조하십시오.

### `FAKEROOTCMD`

      BitBake 설명서에서 ``bitbake:FAKEROOTCMD`를 참조하십시오.

### `가짜루트디어스`

      BitBake 설명서의 ``bitbake:FAKEROOTDIRS`를 참조하십시오.

### `FAKEROOTENV`

      BitBake 설명서에서 ``bitbake:FAKEROOTENV`를 참조하십시오.

### `FAKEROOTNOENV`

      BitBake 설명서에서 ``bitbake:FAKEROOTNOENV`를 참조하십시오.

### `FC`

      포트란 컴파일러를 실행하는 데 사용되는 최소한의 명령어와 인수입니다.

### `FEATURE_PACKAGES`

      특정 조건을 만족할 때 이미지에 포함할 하나 이상의 패키지를 정의합니다.
      해당 항목은 `IMAGE_FEATURES`에 포함되어 있습니다.
      값을 설정할 때, `FEATURE_PACKAGES`에는 다음과 같은 이름이 지정되어야 합니다.
      기능 항목을 재정의하는 방법입니다. 다음은 예시입니다.

         FEATURE_PACKAGES_widget = "package1 package2"

      이 예시에서, 만약 "widget"이 `IMAGE_FEATURES`에 추가된다면,
      package1과 package2는 이미지에 포함됩니다.

      .. 메모::

         `FEATURE_PACKAGES`를 통해 정의된 기능에 의해 설치된 패키지
         패키지 그룹인 경우가 많습니다. 이름은 비슷하지만, 혼동해서는 안 됩니다.
         `FEATURE_PACKAGES` 변수를 패키지 그룹과 혼동하는 것은
         자세한 내용은 문서의 다른 부분에서 설명합니다.

### `FEED_DEPLOYDIR_BASE_URI`

      서버의 기본 URL과 그 안의 위치를 ​​가리킵니다.
      메타데이터와 필요한 패키지를 제공하는 문서 루트
      OPKG는 IPK 패키지의 런타임 패키지 관리를 지원합니다. 설정은 다음과 같습니다.
      `local.conf` 파일에 이 변수를 추가하세요.

      다음 예를 생각해 보세요.

         FEED_DEPLOYDIR_BASE_URI = "http://192.168.7.1/BOARD-dir"

      이 예시는 여러분이 서비스를 제공하고 있다고 가정합니다.
      패키지는 HTTP를 통해 전송되며 데이터베이스는 디렉터리에 있습니다.
      HTTP 서버 아래에 있는 ``BOARD-dir``이라는 이름의 디렉토리입니다.
      document-root. 이 경우 OpenEmbedded 빌드 시스템은 다음을 생성합니다.
      대상 시스템에서 작동하는 구성 파일 세트입니다.
      피드.

### `FETCHCMD`

      BitBake 설명서에서 ``bitbake:FETCHCMD`를 참조하십시오.

### `FILE`

      BitBake 설명서에서 ``bitbake:FILE`을 참조하십시오.

### `FILES`

      패키지에 포함된 파일 및 디렉터리 목록입니다.
      `PACKAGES` 변수는 패키지 목록을 보여줍니다.
      레시피에 의해 생성됩니다.

      ``FILES` 변수를 사용하려면 패키지 이름 재정의를 제공해야 합니다.
      결과 패키지를 식별합니다. 그런 다음 공백으로 구분된 내용을 제공하십시오.
      포함시키려는 파일을 식별하는 파일 또는 경로 목록
      결과 패키지의 일부입니다. 다음은 예시입니다.

         파일:${PN} += "${bindir}/mydir1 ${bindir}/mydir2/myfile"

      .. 메모::

         - 파일이나 경로를 지정할 때 패턴 매칭을 사용할 수 있습니다.
            파이썬의
            `glob <https://docs.python.org/3/library/glob.html>`__
            구문. 구문에 대한 자세한 내용은 해당 문서에서 확인하세요.
            이전 링크를 따라가세요.

         - ``FILES` 변수의 일부로 경로를 지정할 때,
            적절한 경로 변수를 사용하는 것이 좋은 관행입니다. 예를 들어,
            `/etc` 또는 `${bindir}` 대신 `${sysconfdir}`를 사용하십시오.
            `/usr/bin` 대신에요. 이러한 목록은 여기에서 찾을 수 있습니다.
            ``meta/conf/bitbake.conf`` 파일 맨 위에 있는 변수들
            소스 디렉터리를 확인하세요. 또한
            다양한 ``FILES:*`` 변수의 기본값을 찾으세요.
            이 파일.

      ``FILES` 변수에 제공하는 파일 중 일부가 다음과 같은 경우
      편집 가능하며, 편집 중에 덮어쓰면 안 된다는 것을 알고 계실 겁니다.
      패키지 관리 시스템(PMS)에 의한 패키지 업데이트 프로세스,
      PMS가 해당 파일을 덮어쓰지 않도록 이러한 파일을 식별할 수 있습니다. 자세한 내용은 다음을 참조하십시오.
      CONFFILES 변수에 대한 정보는 다음을 참조하십시오.
      PMS에서 이러한 파일을 식별하는 방법은 무엇입니까?

### `FILES_SOLIBSDEV`

      일치시킬 파일 사양을 정의합니다.
      `SOLIBSDEV`. 다시 말해,
      `FILES_SOLIBSDEV`는 개발 파일의 전체 경로를 정의합니다.
      대상 플랫폼의 공유 라이브러리에 대한 심볼릭 링크(symlink)입니다.

      ``bitbake.conf`` 파일의 다음 문장은 그 방법을 보여줍니다.
      세트::

         FILES_SOLIBSDEV ?= "${base_libdir}/lib*${SOLIBSDEV} ${libdir}/lib*${SOLIBSDEV}"

### `FILESEXTRAPATHS`

      OpenEmbedded 빌드의 검색 경로를 확장하기 위한 콜론으로 구분된 목록입니다.
      레시피를 처리하는 동안 파일과 패치를 찾을 때 시스템이 사용하는 항목들입니다.
      파일을 추가합니다. BitBake가 처리할 때 사용하는 기본 디렉터리입니다.
      레시피는 처음에 `FILESPATH` 변수로 정의됩니다.
      `FILESEXTRAPATHS`를 사용하여 `FILESPATH` 변수를 확장합니다.

      모범 사례에 따르면 이를 달성하려면 다음을 사용해야 합니다.
      `.bbappend` 파일 내의 `FILESEXTRAPATHS`를 사용하면 다음과 같은 문제가 발생할 수 있습니다.
      경로 앞에 다음과 같이 추가하세요::

         FILESEXTRAPATHS:prepend := "${THISDIR}/${PN}:"

      위 예시에서 빌드 시스템은 먼저
      해당 디렉터리에서 이름이 같은 파일을 찾습니다.
      해당 추가 파일입니다.

      .. 메모::

         `FILESEXTRAPATHS`를 확장할 때는 반드시 즉시 실행 경로를 사용하십시오.
         확장 연산자(``:=``). 즉시 확장은 다음을 보장합니다.
         BitBake는 다음 시점에 `THISDIR`을 평가합니다.
         지시사항은 나중 시점이 아니라 바로 그 시점에 발견됩니다.
         확장으로 인해 해당 디렉터리가 포함되지 않은 디렉터리가 생성될 수 있습니다.
         필요한 파일입니다.

         또한, 만약 그렇다면 끝에 구분 콜론(:) 문자를 포함하십시오.
         앞에 붙는 것입니다. 뒤에 오는 콜론 문자는 다음과 같은 이유로 필요합니다.
         BitBake에게 디렉터리를 앞에 추가하여 경로를 확장하도록 지시하고 있습니다.
         검색 경로로 이동합니다.

      다음은 흔히 사용되는 또 다른 예입니다.

         FILESEXTRAPATHS:prepend := "${THISDIR}/files:"

      이 예시에서 빌드 시스템은 다음을 확장합니다.
      `FILESPATH` 변수에 `files`라는 이름의 디렉터리를 포함시키려면 다음과 같이 하면 됩니다.
      해당 추가 파일과 동일한 디렉터리에 있습니다.

      다음 예제는 구체적으로 세 개의 경로를 추가합니다.

         FILESEXTRAPATHS:prepend := "path_1:path_2:path_3:"

      마지막 예시에서는 검색 경로를 확장하고 포함하는 방법을 보여줍니다.
      `MACHINE`에 특화된 재정의 기능으로 유용합니다.
      BSP 레이어에서::

          FILESEXTRAPATHS:prepend:intel-x86-common := "${THISDIR}/${PN}:"

      이전 문장은 다음과 같습니다.
      ``linux-yocto-dev.bbappend`` 파일은 다음 위치에 있습니다.
      :ref:`overview-manual/development-environment:yocto project source repositories` in
      ``meta-intel/common/recipes-kernel/linux``. ​​여기서 머신은
      override는 특별한 `PACKAGE_ARCH`입니다.
      여러 개의 ``meta-intel`` 머신에 대한 정의입니다.

      .. 메모::

         단일 BSP를 지원하는 레이어의 경우 재정의는 다음과 같을 수 있습니다.
         `MACHINE`의 값.

      ``.bbappend`` 파일에 경로를 앞에 추가하면 여러 개의 파일을 추가할 수 있습니다.
      서로 다른 레이어에 있지만 동일한 용도로 사용되는 파일
      경로를 올바르게 확장하는 방법.

### `FILESOVERRIDES`

      콜론으로 구분된 목록은 `OVERRIDES`에서 사용되는 하위 집합을 지정합니다.
      OpenEmbedded 빌드 시스템은 `FILESPATH`를 생성합니다.
      `FILESOVERRIDES` 변수는 오버라이드를 사용하여 자동으로 확장합니다.
      `FILESPATH` 변수. 작동 방식에 대한 예는 다음을 참조하십시오.
      `FILESPATH` 변수에 대한 설명입니다. 또한, 더 많은 정보를 찾을 수 있습니다.
      오버라이드 처리 방식에 대한 정보
      ":ref:`bitbake-user-manual/bitbake-user-manual-metadata:조건부 구문(재정의)`"
      BitBake 사용자 설명서의 해당 섹션입니다.

      기본적으로 `FILESOVERRIDES` 변수는 다음과 같이 정의됩니다.

         FILESOVERRIDES = "${TRANSLATED_TARGET_ARCH}:${MACHINEOVERRIDES}:${DISTROOVERRIDES}"

      .. 메모::

         ``FILESOVERRIDES` 변수를 수동으로 편집하지 마십시오. 값이 일치해야 합니다.
         예상되는 재정의 사항이 있으며 예상되는 방식으로 사용됩니다.
         빌드 시스템.

### `FILESPATH`

      기본 디렉터리 집합을 지정하는 콜론으로 구분된 목록입니다.
      OpenEmbedded 빌드 시스템은 패치와 파일을 검색할 때 사용합니다.

      빌드 과정 중에 BitBake는 각 디렉터리를 검색합니다.
      파일을 찾을 때 지정된 순서대로 `FILESPATH`를 사용합니다.
      레시피의 각 ``file://`` URI에 지정된 패치
      `SRC_URI` 문.

      ``FILESPATH` 변수의 기본값은 다음과 같이 정의됩니다.
      :ref:`ref-classes-base` 클래스가 ``meta/classes-global``에서 발견되었습니다.
      `소스 디렉토리`::

         FILESPATH = "${@base_set_filespath(["${FILE_DIRNAME}/${BP}", \
             "${FILE_DIRNAME}/${BPN}", "${FILE_DIRNAME}/files"], d)}"

      그만큼
      `FILESPATH` 변수는 재정의를 사용하여 자동으로 확장됩니다.
      `FILESOVERRIDES` 변수에서 가져온 것입니다.

      .. 메모::

         - `FILESPATH` 변수를 수동으로 편집하지 마십시오. 만약 원하는 경우
            빌드 시스템이 기본 디렉터리 외의 다른 디렉터리를 검색하도록 합니다.
            `FILESPATH` 변수를 사용하여 확장합니다.
            `FILESEXTRAPATHS` 변수.

         - 기본 `FILESPATH` 디렉터리가 매핑되지 않는다는 점에 유의하십시오.
            사용자 지정 레이어의 디렉터리에 파일을 추가합니다.
            (``.bbappend``)가 사용됩니다. 빌드 시스템에서 찾으려면
            추가 파일과 함께 있는 패치 또는 파일이 필요합니다.
            `FILESPATH` 변수를 사용하여 확장하려면
            `FILESEXTRAPATHS` 변수.

      이러한 검색 동작을 유용하게 활용할 수 있습니다. 예를 들어,
      예를 들어, 다음과 같은 디렉토리 구조가 있는 경우를 생각해 보겠습니다.
      일반 구성 및 기종별 구성의 경우::

         파일/defconfig
         파일/MACHINEA/defconfig
         파일/MACHINEB/defconfig

      또한 예시에서 ``SRC_URI` 문에는 다음 내용이 포함되어 있습니다.
      "file://defconfig". 이러한 시나리오에서는 다음과 같이 설정할 수 있습니다.
      `MACHINE`을 "MACHINEA"로 변경하고 빌드를 실행합니다.
      `files/MACHINEA` 디렉터리의 파일을 사용하려면 시스템을 다음과 같이 설정하십시오. `MACHINE`을
      "MACHINEB"와 빌드 시스템은 ``files/MACHINEB``의 파일을 사용합니다.
      마지막으로, "MACHINEA"와 "MACHINEB"를 제외한 모든 기계의 경우,
      빌드 시스템은 `files/defconfig` 디렉터리의 파일을 사용합니다.

      패치 과정에 대한 자세한 내용은 다음에서 확인할 수 있습니다.
      ":ref:`overview-manual/concepts:patching`" 섹션
      Yocto 프로젝트 개요 및 개념 설명서와
      ":ref:`dev-manual/new-recipe:patching code`" 섹션의
      Yocto 프로젝트 개발 작업 매뉴얼을 참조하십시오.
      :ref:`ref-tasks-patch` 작업도 마찬가지입니다.

### `FILESYSTEM_PERMS_TABLES`

      이 기능을 사용하면 파일 권한 설정 테이블을 사용자 정의할 수 있습니다.
      패키징 프로세스에 대한 구성입니다. 예를 들어, 다음과 같다고 가정해 보겠습니다.
      그룹 집합에 대해 일관된 사용자 지정 권한 세트가 필요합니다.
      전체 작업 프로젝트의 사용자들을 대상으로 합니다. 이는 다음에서 수행하는 것이 가장 좋습니다.
      패키지 자체를 만들 수도 있지만 항상 가능한 것은 아닙니다.

      기본적으로 OpenEmbedded 빌드 시스템은 ``fs-perms.txt``를 사용합니다.
      ``fs-perms-volatile-log.txt``와 ``fs-perms-volatile-tmp.txt``는 다음과 같습니다.
      소스 디렉터리의 `meta/files` 폴더에 있습니다.
      권한 설정 테이블 파일을 직접 생성하는 경우, 해당 파일을 어디에 배치해야 할까요?
      레이어에 있는 사람들.

      `FILESYSTEM_PERMS_TABLES` 변수의 값을 재정의할 수 있습니다.
      배포 구성 파일에서 사용자 지정 경로를 가리키도록 설정하세요.
      권한 테이블 파일. 하나 이상의 파일 권한을 지정할 수 있습니다.
      테이블 설정. 이러한 파일에 지정하는 경로는 정의되어 있어야 합니다.
      `BBPATH` 변수 내에 있습니다.

      기본적으로 활성화되어 있는 휘발성 로그를 비활성화하려면 다음 단계를 따르세요.
      ``files/fs-perms-volatile-log.txt`` 값을 제거할 수 있습니다.
      ``FILESYSTEM_PERMS_TABLES``. 마찬가지로, 휘발성 기능을 비활성화하려면
      tmp 폴더에서 ``files/fs-perms-volatile-tmp.txt`` 값을 제거할 수 있습니다.

      파일 권한 설정을 사용자 지정하는 방법에 대한 안내는 다음을 참조하십시오.
      테이블을 살펴보고 기존의 ``fs-perms.txt`` 파일을 검토하십시오.
      ``fs-perms-volatile-log.txt`` 및 ``fs-perms-volatile-tmp.txt`` 파일.

### `FIRMWARE_COMPRESSION`

      `FIRMWARE_COMPRESSION` 옵션을 사용하면 제공된 펌웨어를 압축할 수 있습니다.
      ``linux-firmware`` 레시피에 의해 생성됩니다. 이 변수의 기본값은 다음과 같습니다.
      빈 문자열(압축 없음)이며, 가능한 값은 다음과 같습니다.
      ``xz``와 ``zst``를 사용하면 디스크 공간을 크게 절약할 수 있습니다.

      이를 위해서는 Linux 커널이 다음을 필요로 합니다.
      ``CONFIG_FW_LOADER_COMPRESS_XZ`` 또는 ``CONFIG_FW_LOADER_COMPRESS_ZSTD``
      설정할 구성 옵션입니다.

### `FIT_ADDRESS_CELLS`

      ``#address-cells`` 값의 값을 지정합니다.
      FIT 이미지에 대한 설명입니다.

      :ref:`ref-classes-kernel-fit-image`에 의해 기본값은 "1"로 설정됩니다.
      32비트 주소에 해당하는 클래스입니다.

      예를 들어 64비트 주소를 설정해야 하는 플랫폼의 경우
      `UBOOT_LOADADDRESS` 및 `UBOOT_ENTRYPOINT`를 사용하려면 다음이 필요합니다.
      이 값을 "2"로 설정하십시오. 32비트 값(셀) 두 개가 필요합니다.
      그러한 주소를 나타내기 위해.

      다음은 "0x400000000"을 로드 주소로 설정하는 예입니다.

         FIT_ADDRESS_CELLS = "2"
         UBOOT_LOADADDRESS = "0x04 0x00000000"

      `#address-cells에 대한 자세한 내용은 <https://elinux.org/Device_Tree_Usage#How_Addressing_Works>를 참조하세요.`

### `FIT_CONF_DEFAULT_DTB`

      FIT 이미지에 사용할 기본 장치 트리 바이너리(dtb) 파일을 지정합니다.
      여러 개의 값이 제공되는 경우.

      이 변수는 :ref:`ref-classes-kernel-fit-image` 클래스에서 사용됩니다.

### `FIT_CONF_PREFIX`

      `:ref:ref-classes-kernel-fit-image`를 사용할 때, 이것이 접두사입니다.
      FIT 구성 노드를 생성하는 데 사용됩니다. 기본값은 "conf-"입니다.

### `FIT_DESC`

      FIT 이미지에 인코딩된 설명 문자열을 지정합니다.
      기본값은 :ref:`ref-classes-kernel-fit-image` 클래스에 의해 설정됩니다.
      다음이 따릅니다::

         FIT_DESC ?= "${DISTRO_NAME}/${PV}/${MACHINE}용 U-Boot fitImage"

### `FIT_GENERATE_KEYS`

      FIT 이미지 서명용 키를 생성할지 여부를 결정합니다.
      해당 키는 이미 존재하지 않습니다. 키는 다음과 같이 생성됩니다.
      `UBOOT_SIGN_KEYDIR`. 기본값은 "0"으로 설정되어 있습니다.
      :ref:`ref-classes-kernel-fit-image` 클래스에 의해.

### `FIT_HASH_ALG`

      FIT 이미지를 생성하는 데 사용되는 해시 알고리즘을 지정합니다.
      이 변수는 기본적으로 "sha256"으로 설정됩니다.
      :ref:`ref-classes-kernel-fit-image` 클래스.

### `FIT_KERNEL_COMP_ALG`

      FIT 이미지 내부의 커널 이미지에 사용할 압축 알고리즘입니다.
      현재 지원되는 값은 "gzip"(기본값), "lzo" 또는 "none"뿐입니다.
      이 변수를 "없음" 이외의 값으로 설정하는 경우 추가 설정이 필요할 수 있습니다.
      `FIT_KERNEL_COMP_ALG_EXTENSION`을 설정하려면.

      이 변수는 :ref:`ref-classes-kernel-uboot` 클래스에서 사용됩니다.

### `FIT_KERNEL_COMP_ALG_EXTENSION`

      `FIT_KERNEL_COMP_ALG`에 해당하는 파일 확장자입니다. 기본값입니다.
      값은 `:ref:ref-classes-kernel-uboot` 클래스에 의해 ".gz"로 설정됩니다. 만약
      `FIT_KERNEL_COMP_ALG`를 "lzo"로 설정하세요. 이렇게 설정하는 것이 좋을 수 있습니다.
      변수를 ".lzo"로 변경합니다.

### `FIT_KERNEL_SIGN_ENABLE`

      이 변수는 :ref:`ref-classes-kernel-fit-image` 클래스에서 사용됩니다.
      FIT 이미지 서명 기능을 활성화 또는 비활성화합니다.
      `FIT_KERNEL_SIGN_ENABLE`의 기본값은 다음 값입니다.
      `UBOOT_SIGN_ENABLE`은 U-Boot FIT 이미지 서명 시 활성화됨을 의미합니다.
      FIT 기능이 활성화되면 빌드 시점에 FIT 이미지와 U-Boot에도 서명이 이루어집니다.
      실행 시점에 FIT 이미지 서명을 검증합니다.

      이 변수를 "1"로 설정하면 FIT 이미지는 다음을 사용하여 서명됩니다.
      디렉터리에서 `FIT_KERNEL_SIGN_KEYNAME`으로 지정된 키
      `FIT_KERNEL_SIGN_KEYDIR`.

      이 변수가 재정의되면 `FIT_KERNEL_SIGN_KEYDIR` 및
      `FIT_KERNEL_SIGN_KEYNAME` 변수도 적절하게 설정해야 합니다.

### `FIT_KERNEL_SIGN_KEYDIR`

      이 변수는 :ref:`ref-classes-kernel-fit-image` 클래스에서 사용됩니다.
      `FIT_KERNEL_SIGN_KEYDIR`의 기본값은 다음 값입니다.
      `UBOOT_SIGN_KEYDIR`은 커널이 빌드 시점에 서명되었음을 의미합니다.
      `UBOOT_SIGN_KEYDIR`에서 찾은 개인 키를 사용하면 U-Boot가 이를 가져옵니다.
      동일 디렉터리의 공개 키가 DTB에 삽입됩니다.
      FIT 이미지의 목표값 검증.

      이 변수가 재정의되면 `FIT_KERNEL_SIGN_ENABLE` 및
      `FIT_KERNEL_SIGN_KEYNAME` 변수도 적절하게 설정해야 합니다.

### `FIT_KERNEL_SIGN_KEYNAME`

      이 변수는 :ref:`ref-classes-kernel-fit-image` 클래스에서 사용됩니다.
      `FIT_KERNEL_SIGN_KEYNAME`의 기본값은 다음 값입니다.
      `UBOOT_SIGN_KEYNAME`이라는 용어는 커널이 서명되었음을 의미합니다.
      빌드 시간, 이름에 따라 지정된 개인 키를 사용합니다.
      `UBOOT_SIGN_KEYNAME` 명령어를 사용하면 U-Boot는 공개 키를 가져옵니다.
      대상 검증을 위해 동일한 이름이 DTB에 삽입됩니다.
      FIT 이미지의 일부입니다.

      이 변수가 재정의되면 `FIT_KERNEL_SIGN_ENABLE` 및
      `FIT_KERNEL_SIGN_KEYDIR` 변수도 적절하게 설정해야 합니다.

### `FIT_KEY_GENRSA_ARGS`

      RSA 개인 키를 생성하기 위한 `openssl genrsa` 명령어의 인수
      FIT 이미지에 서명합니다. 기본값은 "-F4"로 설정되어 있습니다.
      :ref:`ref-classes-kernel-fit-image` 클래스.

### `FIT_KEY_REQ_ARGS`

      서명용 인증서 생성을 위한 `openssl req` 함수의 인수
      FIT 이미지. 기본값은 "-batch -new"입니다.
      :ref:`ref-classes-kernel-fit-image` 클래스, "batch"
      비대화형 모드와 새 키 생성을 위한 "새로 만들기" 옵션이 있습니다.

### `FIT_KEY_SIGN_PKCS`

      FIT 이미지 서명에 사용되는 공개 키 인증서의 형식입니다.
      기본값은 "x509"로 설정되어 있습니다.
      :ref:`ref-classes-kernel-fit-image` 클래스.

### `FIT_PAD_ALG`

      FIT 이미지를 생성할 때 사용되는 패딩 알고리즘을 지정합니다.
      기본값은 "pkcs-1.5"로 설정되어 있습니다.
      :ref:`ref-classes-kernel-fit-image` 클래스.

### `FIT_SIGN_ALG`

      FIT 이미지를 생성하는 데 사용되는 서명 알고리즘을 지정합니다.
      이 변수는 기본적으로 "rsa2048"로 설정됩니다.
      :ref:`ref-classes-kernel-fit-image` 클래스.

### `FIT_SIGN_INDIVIDUAL`

      "1"로 설정하면 :ref:`ref-classes-kernel-fit-image` 클래스는 각 항목에 서명합니다.
      커널, DTB, RAM 디스크 및 기타 모든 요소를 ​​포함하여 이미지 노드를 개별적으로 검사합니다.
      FIT 이미지에 존재하는 다른 이미지 유형은 서명 외에도 포함됩니다.
      구성 노드.
      이는 서명을 외부에서 확인해야 할 때 유용할 수 있습니다.
      U-Boot 부팅 프로세스입니다. 기본적으로 이 변수는 "0"으로 설정되어 있습니다.

      만약 `UBOOT_SIGN_ENABLE`이 "1"로 설정되어 있다면
      `FIT_SIGN_INDIVIDUAL`은 기본값인 "0"으로 유지되며, 단지
      구성 노드는 서명되어 있습니다. 구성 노드에는 해시가 포함되어 있기 때문입니다.
      참조된 이미지 노드의 무결성으로 인해 전체 FIT 이미지의 무결성이 보장됩니다.
      이미지 노드가 구성 노드를 통해 로드되는 한 보장됩니다.
      그리고 이미지 노드의 해시값을 확인합니다. 보통은 그렇습니다.

      `FIT_SIGN_INDIVIDUAL`을 활성화하면 일반적으로 복잡성이 증가합니다.
      이점은 거의 없습니다. 이미지 노드와 같은 예외가 있을 수 있습니다.
      어떤 구성 노드에서도 참조되지 않으며, 어떤 목적으로든 직접 로드되지 않습니다.
      이유.
      대부분의 경우 이 변수를 "0"으로 설정하면 충분한 성능을 제공합니다.
      보안.

      자세한 내용은 U-Boot 공식 문서를 참조하십시오.
      `U-Boot fit 서명 <https://docs.u-boot.org/en/latest/usage/fit/signature.html>`__
      더 구체적으로는 다음과 같습니다.
      `U-Boot 서명된 구성 <https://docs.u-boot.org/en/latest/usage/fit/signature.html#signed-configurations>`__.

      이미지 노드에만 서명하는 기능은 의도적으로 구현되지 않았습니다.
      OpenEmbedded-Core(OE-Core)는 혼합 사용에 취약하기 때문에 문제가 발생할 수 있습니다.
      공격.

### `FIT_SIGN_NUMBITS`

      FIT 이미지에 사용된 개인 키의 크기(비트 수).
      이 변수의 기본값은 "2048"로 설정되어 있습니다.
      :ref:`ref-classes-kernel-fit-image` 클래스에 의해.

### `FIT_UBOOT_ENV`

      이 변수를 사용하면 U-Boot 스크립트를 텍스트 파일로 추가할 수 있습니다.
      FIT 이미지. 이러한 스크립트는 U-Boot 셸에서 실행할 수 있습니다.

      :ref:`ref-classes-kernel-fit-image` 클래스를 상속받을 때
      스크립트 파일은 Linux의 ``SRC_URI`에 포함되어야 합니다.
      커널 레시피.

      예:

      - Linux 커널 레시피에 `boot.cmd` 스크립트를 추가합니다.

            FIT_UBOOT_ENV = "boot.cmd"
            SRC_URI += "file://${FIT_UBOOT_ENV}"

      - U-Boot 셸에서 스크립트 파일을 사용하십시오. 스크립트 파일 이름은 다음과 같습니다.
         FIT 이미지는 ``bootscr-${FIT_UBOOT_ENV}``입니다. 이 예제는 FIT를 로드합니다.
         TFTP 서버에서 가져온 이미지::

            tftp $loadaddr $fit_tftp_path
            소스 $loadaddr#bootscr-boot.cmd

      자세한 내용은 U-Boot 공식 문서를 참조하십시오.
      `U-Boot 소스 명령 <https://docs.u-boot.org/en/latest/usage/cmd/source.html#fit-image.f>`__

### `FONT_EXTRA_RDEPENDS`

      `:ref:`ref-classes-fontcache` 클래스를 상속할 때,
      이 변수는 글꼴 패키지에 대한 런타임 종속성을 지정합니다.
      기본적으로 `FONT_EXTRA_RDEPENDS`는 "fontconfig-utils"로 설정되어 있습니다.

### `FONT_PACKAGES`

      `:ref:`ref-classes-fontcache` 클래스를 상속할 때, 이 변수는
      캐시해야 하는 글꼴 파일이 포함된 패키지를 식별합니다.
      글꼴 설정. 기본적으로 :ref:`ref-classes-fontcache` 클래스는 다음을 가정합니다.
      해당 글꼴이 레시피의 메인 패키지에 있습니다(예:
      ``${``\ `PN`\ ``}``). 글꼴을 사용하는 경우 이 변수를 사용하세요.
      필요한 파일은 메인 패키지가 아닌 다른 패키지에 있습니다.

### `FORCE_RO_REMOVE`

      ``ROOTFS_RO_UNNEEDED``에 나열된 패키지를 강제로 제거합니다.
      루트 파일 시스템 생성 중에 발생합니다.

      해당 패키지를 강제로 제거하려면 변수를 "1"로 설정하십시오.

### `FULL_OPTIMIZATION`

      `TARGET_CFLAGS`와 `CFLAGS`에 전달할 옵션은 다음과 같습니다.
      최적화된 시스템을 컴파일합니다. 이 변수의 기본값은 "-O2 -pipe"입니다.
      ${DEBUG_FLAGS}".

### `GCCPIE`

      GNU C 언어 내에서 위치 독립 실행 파일(PIE)을 활성화합니다.
      컴파일러(GCC). GCC에서 PIE를 활성화하면 반환 지향성이 향상됩니다.
      원격-컴퓨터 프로그래밍(ROP) 공격은 실행하기가 훨씬 더 어렵습니다.

      기본적으로 ``security_flags.inc`` 파일은 다음 설정을 통해 PIE를 활성화합니다.
      변수는 다음과 같습니다::

         GCCPIE ?= "--enable-default-pie"

### `GCCVERSION`

      GNU C 컴파일러(GCC)의 기본 버전을 지정합니다.
      컴파일. 기본적으로 `GCCVERSION`은 "8.x"로 설정됩니다.
      ``meta/conf/distro/include/tcmode-default.inc`` 포함 파일::

         GCCVERSION ?= "8.%"

      이 값은 설정값을 통해 재정의할 수 있습니다.
      `local.conf`와 같은 설정 파일.

### `GDB`

      GNU 디버거를 실행하기 위한 최소한의 명령어와 인수입니다.

### `GIR_EXTRA_LIBS_PATH`

      ``.so`` 파일에 대한 추가 검색 경로를 지정할 수 있습니다.
      GObject 인트로스펙션을 사용하는 GLib 관련 레시피에서,
      이 설정을 하지 않으면 컴파일되지 않습니다.
      ":ref:`dev-manual/gobject-introspection:enabling gobject introspection support`"를 참조하십시오.
      자세한 내용은 해당 섹션을 참조하십시오.

### `GITDIR`

      Git 저장소의 로컬 복사본이 저장되는 디렉터리
      복제될 때.

### `GITHUB_BASE_URI`

      :ref:`ref-classes-github-releases`를 상속할 때
      클래스는 GitHub 릴리스를 가져오기 위한 기본 URL을 지정합니다.
      소스를 가져올 프로젝트를 지정합니다. 기본값은 다음과 같습니다.

         GITHUB_BASE_URI ?= "https://github.com/${BPN}/${BPN}/releases/"

### `GLIBC_GENERATE_LOCALES`

      원하지 않을 경우 생성할 GLIBC 로케일 목록을 지정합니다.
      모든 LIBC 로컬 변수를 생성하는 것은 시간이 많이 걸릴 수 있습니다.

      .. 메모::

         `en_US.UTF-8` 로케일을 명시적으로 제거하려면 다음 설정을 해야 합니다.
         `IMAGE_LINGUAS`를 적절하게 사용합니다.

      `local.conf` 파일에서 ``GLIBC_GENERATE_LOCALES`를 설정할 수 있습니다.
      기본적으로 모든 지역 설정이 생성됩니다.

         GLIBC_GENERATE_LOCALES = "en_GB.UTF-8 en_US.UTF-8"

### `GO_IMPORT`

      `ref-classes-go` 클래스를 상속할 때, 이 필수 변수는 다음과 같습니다.
      이 코드는 생성될 Go 패키지의 임포트 경로를 설정합니다.
      빌드하려면 소스 디렉터리에 `go.mod` 파일이 있는 경우 이 파일을 사용하십시오.
      일반적으로 이 파일의 ``module`` 줄에 있는 경로와 일치합니다.

      이 패키지를 가져오는 다른 Go 프로그램은 이 경로를 사용합니다.

      다음은 설정 예시입니다.
      :yocto_git:`go-helloworld_0.1.bb </poky/tree/meta/recipes-extended/go-examples/go-helloworld_0.1.bb>`
      레시피::

          GO_IMPORT = "golang.org/x/example"

### `GO_INSTALL`

      `ref-classes-go` 클래스를 상속할 때, 이 선택적 변수는 다음과 같습니다.
      소스 코드에서 어떤 패키지를 컴파일해야 하는지 지정합니다.
      Go 빌드 공간에 설치됨
      `go install <https://go.dev/ref/mod#go-install>`__ 명령어입니다.

      다음은 설정 예시입니다.
      :oe_git:`crucible </meta-openembedded/tree/meta-oe/recipes-support/crucible/>`
      레시피::

         GO_INSTALL = "\
             ${GO_IMPORT}/cmd/crucible \
             ${GO_IMPORT}/cmd/habtool \
         "

      기본적으로 `GO_INSTALL`은 다음과 같이 정의됩니다.

         GO_INSTALL ?= "${GO_IMPORT}/..."

      와일드카드 ``...``는 모든 경우를 포괄한다는 의미입니다.
      소스에서 발견된 패키지입니다.

      `GO_INSTALL_FILTEROUT` 변수를 참조하십시오.
      원치 않는 패키지를 필터링합니다
      `GO_INSTALL` 값에서 찾았습니다.

### `GO_INSTALL_FILTEROUT`

      Go의 "vendor" 메커니즘을 사용하여 Go 프로젝트에 필요한 종속성을 가져올 때
      패키지의 기본 `GO_INSTALL` 설정은 ``...``을 사용합니다.
      와일드카드를 사용하면 벤더링된 패키지가 빌드에 포함되어 결과물이 생성됩니다.
      잘못된 결과입니다.

      Go 패키지 중에는 구조가 제대로 되어 있지 않은 것도 있습니다.
      와일드카드를 사용하면 예제 또는 테스트 코드가 생성되는데, 이는 바람직하지 않은 결과를 초래할 수 있습니다.
      빌드에 포함될 수도 있고, 포함되지 않을 수도 있습니다.

      이 선택적 변수를 사용하면 소스의 하위 집합을 필터링할 수 있습니다.
      기본적으로 `vendor` 하위 디렉터리 아래의 모든 항목을 제외합니다.
      패키지의 메인 디렉토리 아래에 있습니다. 이곳은 벤더링된 파일이 위치하는 일반적인 위치입니다.
      패키지에 대한 설정이지만, 레시피를 통해 다른 패키지를 필터링하도록 재정의할 수 있습니다.
      필요한 경우 하위 디렉토리를 추가하세요.

### `GO_WORKDIR`

      Go Modules를 사용할 때 현재 작업 디렉터리는 반드시 해당 디렉터리여야 합니다.
      `go.mod` 파일 또는 해당 하위 디렉터리 중 하나를 포함하는 경우.
      `go` 도구를 사용하면 자동으로 `go.mod` 파일을 찾습니다.
      Go 작업 디렉터리 또는 상위 디렉터리에 있지만, 다음 디렉터리에는 없습니다.
      하위 디렉토리.

      Go 모듈을 사용하기 위해 `:ref:`ref-classes-go-mod` 클래스를 사용할 때,
      선택 사항인 `GO_WORKDIR` 변수는 기본값을 갖습니다.
      `GO_IMPORT` 명령어를 사용하면 다른 Go 작업 디렉토리를 지정할 수 있습니다.

### `GROUPADD_PARAM`

      :ref:`ref-classes-useradd` 클래스를 상속할 때,
      이 변수는 패키지에 대해 어떤 매개변수가 사용되어야 하는지를 지정합니다.
      그룹을 추가하려면 `groupadd` 명령에 해당 옵션을 전달합니다.
      패키지가 설치될 때 시스템입니다.

      다음은 ``dbus`` 레시피의 예입니다.

         GROUPADD_PARAM:${PN} = "-r netde v"

      서로 다른 집합들을 각각 분리하면 둘 이상의 그룹을 추가할 수 있습니다.
      그룹 매개변수는 세미콜론으로 구분합니다.

      다음은 `useradd-example.bb` 파일에서 가져온 여러 그룹을 추가하는 예시입니다.
      ``메타 스켈레톤`` 레이어의 파일::

         GROUPADD_PARAM:${PN} = "-g 880 그룹1; -g 890 그룹2"

      표준 Linux 셸 명령에 대한 정보는 다음을 참조하십시오.
      ``groupadd``에 대한 자세한 내용은 https://linux.die.net/man/8/groupadd를 참조하십시오.

### `GROUPMEMS_PARAM`

      :ref:`ref-classes-useradd` 클래스를 상속할 때,
      이 변수는 패키지에 대해 어떤 매개변수가 사용되어야 하는지를 지정합니다.
      멤버를 수정하려면 `groupmems` 명령에 해당 옵션을 전달하십시오.
      패키지가 설치될 때 그룹의 일부입니다.

      표준 Linux 셸 명령 `groupmems`에 대한 자세한 내용은 다음을 참조하십시오.
      자세한 내용은 https://linux.die.net/man/8/groupmems를 참조하십시오.

### `GRUB_GFXSERIAL`

      GNU GRUB(GNU GRand Unified Bootloader)에 그래픽 기능을 활성화하도록 구성합니다.
      부팅 메뉴에서 시리얼 번호를 입력하세요. 이 변수를 "1"로 설정하십시오.
      그래픽을 활성화하려면 `local.conf` 또는 배포판 구성 파일을 사용하세요.
      그리고 메뉴에서 시리얼 번호를 선택하세요.

      자세한 내용은 :ref:`ref-classes-grub-efi` 클래스를 참조하세요.
      이 변수가 어떻게 사용되는지에 대한 정보입니다.

### `GRUB_MKIMAGE_OPTS`

      이 변수는 ``grub-mkimage``에 전달되는 추가 옵션을 제어합니다.
      GNU GRand Unified Bootloader(GRUB) 레시피의 명령은 다음과 같습니다.
      ``do_mkimage`` 작업.

### `GRUB_OPTS`

      GNU 통합 부트로더(GRUB)에 추가할 수 있는 추가 옵션
      설정입니다. 세미콜론 문자(``;``)를 사용하여 구분하세요.
      여러 가지 옵션이 있습니다.

      `GRUB_OPTS` 변수는 선택 사항입니다. 자세한 내용은 다음을 참조하십시오.
      자세한 내용은 :ref:`ref-classes-grub-efi` 클래스를 참조하세요.
      이 변수가 어떻게 사용되는지에 대하여.

### `GRUB_TIMEOUT`

      기본 ``LABEL``을 실행하기 전의 시간 제한을 지정합니다.
      GNU 통합 부트로더(GRUB).

      `GRUB_TIMEOUT` 변수는 선택 사항입니다. 자세한 내용은 다음을 참조하십시오.
      자세한 내용은 :ref:`ref-classes-grub-efi` 클래스를 참조하세요.
      이 변수가 어떻게 사용되는지에 대하여.

### `GRUB_TITLE`

      `LABELS`에 정의된 GRUB 레이블에 대한 사용자 지정 제목을 지정합니다. 자세한 내용은 다음을 참조하십시오.
      자세한 내용은 :ref:`ref-classes-grub-efi` 클래스를 참조하세요.
      변수가 사용됩니다.

### `GTKIMMODULES_PACKAGES`

      :ref:`ref-classes-gtk-immodules-cache` 클래스를 상속받을 때,
      이 변수는 GTK+ 입력이 포함된 패키지를 지정합니다.
      모듈이 다른 패키지에 있을 때 메서드 모듈이 설치됩니다.
      메인 패키지보다.

### `HGDIR`

      BitBake 설명서에서 `bitbake:HGDIR`을 참조하십시오.

   홈페이지
      해당 레시피 소프트웨어에 대한 자세한 정보가 있는 웹사이트입니다.
      건물을 찾을 수 있습니다.

### `HOST_ARCH`

      대상 아키텍처의 이름은 일반적으로 다음과 같습니다.
      `TARGET_ARCH`. OpenEmbedded 빌드 시스템
      다양한 아키텍처를 지원합니다. 다음은 지원되는 아키텍처의 예시 목록입니다.
      지원되는 기능입니다. 이 목록은 아키텍처가 다양하기 때문에 결코 완전한 목록이 아닙니다.
      구성 가능:

      - 팔
      - i586
      - x86_64
      - 파워PC
      - 파워PC64
      - 밉스
      - 밉셀

### `HOST_AS_ARCH`

      아키텍처별 어셈블러 플래그를 지정합니다.

      `HOST_AS_ARCH`의 기본 초기화는 설정에 따라 다릅니다.
      건설 중입니다:

      - 빌드 시 `TARGET_AS_ARCH`를 사용합니다.
         목표

      - 빌드 호스트용으로 빌드할 때 `BUILD_AS_ARCH`를 사용합니다.
         ``-네이티브``)

      - SDK용 빌드 시 `SDK_AS_ARCH` 옵션 사용 (예: `nativesdk-`)

### `HOST_CC_ARCH`

      아키텍처별 컴파일러 플래그를 지정합니다. 이 플래그는 컴파일러에 전달됩니다.
      C 컴파일러.

      `HOST_CC_ARCH`의 기본 초기화는 무엇에 따라 달라지나요?
      건설 중입니다:

      - 빌드 시 `TARGET_CC_ARCH`를 사용합니다.
         목표

      - 빌드 호스트용으로 빌드할 때 `BUILD_CC_ARCH`를 사용합니다.
         ``-네이티브``)

      - SDK(예: ``nativesdk-``)용으로 빌드할 때 `SDK_CC_ARCH`를 사용합니다.

### `HOST_LD_ARCH`

      아키텍처별 링커 플래그를 지정합니다.

      `HOST_LD_ARCH`의 기본 초기화는 대상에 따라 다릅니다.
      건설 중입니다:

      - 타겟 빌드 시 `TARGET_LD_ARCH`

      - 빌드 호스트(예: )용으로 빌드할 때 `BUILD_LD_ARCH`를 사용합니다.
         ``-네이티브``)

      - SDK(예: ``nativesdk-``)용으로 빌드할 때 `SDK_LD_ARCH`를 사용합니다.

### `HOST_OS`

      대상 운영 체제의 이름을 지정합니다. 일반적으로 이는 다음과 같습니다.
      `TARGET_OS`와 동일합니다. 변수는 다음과 같습니다.
      `glibc` 기반 시스템의 경우 "linux"로, 다른 시스템의 경우 "linux-musl"로 설정해야 합니다.
      `musl`. ARM/EABI 타겟의 경우 "linux-gnueabi"도 있습니다.
      "linux-musleabi" 값의 가능성.

### `HOST_PREFIX`

      크로스 컴파일 툴체인에 사용할 접두사를 지정합니다. `HOST_PREFIX`
      일반적으로 `TARGET_PREFIX`와 동일합니다.

### `HOST_SYS`

      시스템 아키텍처 및 운영 체제를 포함한 시스템 사양을 명시합니다.
      빌드가 진행되는 시스템의 컨텍스트는 다음과 같습니다.
      현재 레시피.

      OpenEmbedded 빌드 시스템은 이 변수를 자동으로 설정합니다.
      `HOST_ARCH`에서,
      `HOST_VENDOR`, 그리고
      `HOST_OS` 변수.

      .. 메모::

         변수를 직접 설정할 필요가 없습니다.

      다음 두 가지 예를 살펴보세요.

      - 32비트 x86 Linux 운영 체제에서 실행되는 네이티브 레시피가 주어졌을 때,
         값은 "i686-linux"입니다.

      - 리틀 엔디안 MIPS 타겟용으로 빌드 중인 레시피를 가정해 보겠습니다.
         Linux의 경우 값은 "mipsel-linux"일 수 있습니다.

### `HOST_VENDOR`

      벤더의 이름을 지정합니다. `HOST_VENDOR`는 일반적으로 다음과 같습니다.
      `TARGET_VENDOR`와 동일합니다.

### `HOSTTOOLS`

      빌드 호스트의 도구 목록(필터)을 공백으로 구분하여 표시합니다.
      빌드 작업 내에서 호출할 수 있도록 허용해야 합니다. 이를 사용하면
      필터는 호스트 오염 가능성을 줄이는 데 도움이 됩니다. 도구가
      빌드에서 `HOSTTOOLS` 값에 지정된 항목을 찾을 수 없습니다.
      호스트에서 OpenEmbedded 빌드 시스템이 오류를 발생시키고 빌드가 중단됩니다.
      시작되지 않았습니다.

      자세한 내용은 다음을 참조하십시오.
      `HOSTTOOLS_NONFATAL`.

### `HOSTTOOLS_NONFATAL`

      빌드 호스트의 도구 목록(필터)을 공백으로 구분하여 표시합니다.
      빌드 작업 내에서 호출할 수 있도록 허용해야 합니다. 이를 사용하면
      필터는 숙주 오염 가능성을 줄이는 데 도움이 됩니다.
      `HOSTTOOLS`, OpenEmbedded 빌드 시스템
      값에 지정된 도구가 있는 경우 오류가 발생하지 않습니다.
      빌드 호스트에서 `HOSTTOOLS_NONFATAL`을 찾을 수 없습니다. 따라서 다음을 수행할 수 있습니다.
      선택적 호스트 도구를 필터링하려면 `HOSTTOOLS_NONFATAL`을 사용하십시오.

### `IMAGE_BASENAME`

      이미지 출력 파일의 기본 이름입니다. 이 변수의 기본값은 다음과 같습니다.
      레시피 이름(``${``\ `PN`\ ``}``).

### `IMAGE_BOOT_FILES`

      부트 파티션에 설치된 파일 목록을 공백으로 구분하여 표시합니다.
      Wic 도구를 사용하여 이미지를 준비할 때
      ``bootimg_partition`` 소스 플러그인. 기본적으로,
      파일들은
      소스 파일과 동일한 이름으로 설치됩니다. 변경하려면
      설치된 이름과 원래 이름을 세미콜론으로 구분합니다.
      (;). 소스 파일은 다음 위치에 있어야 합니다.
      `DEPLOY_DIR_IMAGE`. 여기에 두 가지가 있습니다.
      예시::

         IMAGE_BOOT_FILES = "u-boot.img uImage;kernel"
         IMAGE_BOOT_FILES = "u-boot.${UBOOT_SUFFIX} ${KERNEL_IMAGETYPE}"

      또는 글로브 패턴을 사용하여 소스 파일을 선택할 수도 있습니다.
      이 경우 대상 파일의 이름은 기본 파일과 동일해야 합니다.
      소스 파일 경로의 이름입니다. 파일을 디렉터리에 설치하려면 이 경로를 사용합니다.
      대상 위치 내에서 세미콜론(;) 뒤에 해당 이름을 전달합니다.
      다음은 두 가지 예입니다.

         IMAGE_BOOT_FILES = "bcm2835-bootfiles/*"
         IMAGE_BOOT_FILES = "bcm2835-bootfiles/*;boot/"

      첫 번째 예시
      `${DEPLOY_DIR_IMAGE}/bcm2835-bootfiles` 경로의 모든 파일을 설치합니다.
      대상 파티션의 루트에 설치합니다. 두 번째 예제는 설치 과정을 보여줍니다.
      대상 파티션 내의 "boot" 디렉터리에 동일한 파일을 저장합니다.

      Wic 도구 사용 방법에 대한 정보는 다음에서 찾을 수 있습니다.
      ":ref:`dev-manual/wic:wic를 사용하여 파티션된 이미지 생성`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션을 참조하십시오.
      Wic 관련 자료는 다음 위치에 있습니다.
      ":doc:`/ref-manual/kickstart`" 장.

### `IMAGE_BUILDINFO_FILE`

      :ref:`ref-classes-image-buildinfo` 클래스를 사용할 때,
      이미지 내에서 빌드 정보를 기록할 파일을 지정합니다.
      기본값은 "``${sysconfdir}/buildinfo``"입니다.

### `IMAGE_BUILDINFO_VARS`

      :ref:`ref-classes-image-buildinfo` 클래스를 사용할 때,
      빌드 구성에 포함할 변수 목록을 지정합니다.
      출력 파일의 섹션(공백으로 구분된 목록). 기본값은 다음과 같습니다.
      "`DISTRO` `DISTRO_VERSION`".

### `IMAGE_CLASSES`

      모든 이미지가 상속해야 하는 클래스 목록입니다. 일반적으로 다음과 같은 용도로 사용됩니다.
      모든 이미지 레시피에서 기능을 활성화하기 위해서입니다.

      `IMAGE_CLASSES`에 지정된 클래스는 다음 위치에 있어야 합니다.
      `classes-recipe/` 또는 `classes/` 하위 디렉토리.

### `IMAGE_CMD`

      특정 이미지에 대한 이미지 파일을 생성하는 명령을 지정합니다.
      타입은 설정된 값에 해당합니다.
      `IMAGE_FSTYPES`, (예: ``ext3``,
      ``btrfs`` 등). 이 변수를 설정할 때는 다음을 사용해야 합니다.
      관련 형식에 대한 재정의입니다. 다음은 예시입니다.

         IMAGE_CMD:jffs2 = "mkfs.jffs2 --root=${IMAGE_ROOTFS} --faketime \
             --출력=${IMGDEPLOYDIR}/${IMAGE_NAME}${IMAGE_NAME_SUFFIX}.jffs2 \
             ${EXTRA_IMAGECMD}"

      일반적으로 값을 추가하는 경우가 아니면 이 변수를 설정할 필요가 없습니다.
      새로운 이미지 유형에 대한 지원입니다. 설정 방법에 대한 자세한 예시는 다음을 참조하세요.
      변수에 대한 자세한 내용은 :ref:`ref-classes-image_types`를 참조하십시오.
      클래스 파일은 ``meta/classes-recipe/image_types.bbclass``입니다.

### `IMAGE_DEVICE_TABLES`

      사용자 지정 장치 테이블이 포함된 하나 이상의 파일을 지정합니다.
      이미지 생성 과정의 일부로 `makedevs` 명령에 전달됩니다.
      이 파일들은 아래에 생성해야 할 기본 장치 노드 목록을 보여줍니다.
      이미지 내의 ``/dev``입니다. 만약 `IMAGE_DEVICE_TABLES`가 설정되어 있지 않다면,
      ``files/device_table-minimal.txt`` 파일이 사용되며, 이 파일은 다음 위치에 있습니다.
      `BBPATH`. 작성 방법에 대한 자세한 내용은 다음을 참조하세요.
      장치 테이블 파일에 대한 자세한 내용은 ``meta/files/device_table-minimal.txt``를 참조하십시오.
      예.

### `IMAGE_EFI_BOOT_FILES`

      부트 파티션에 설치된 파일 목록을 공백으로 구분하여 표시합니다.
      Wic 도구를 사용하여 이미지를 준비할 때
      ``bootimg_efi`` 소스 플러그인. 기본적으로,
      파일들은
      소스 파일과 동일한 이름으로 설치됩니다. 변경하려면
      설치된 이름과 원래 이름을 세미콜론으로 구분합니다.
      (;). 소스 파일은 다음 위치에 있어야 합니다.
      `DEPLOY_DIR_IMAGE`. 여기에 두 가지가 있습니다.
      예시::

         IMAGE_EFI_BOOT_FILES = "${KERNEL_IMAGETYPE};bz2"
         IMAGE_EFI_BOOT_FILES = "${KERNEL_IMAGETYPE} microcode.cpio"

      또는 글로브 패턴을 사용하여 소스 파일을 선택할 수도 있습니다.
      이 경우 대상 파일의 이름은 기본 파일과 동일해야 합니다.
      소스 파일 경로의 이름입니다. 파일을 디렉터리에 설치하려면 이 경로를 사용합니다.
      대상 위치 내에서 세미콜론(;) 뒤에 해당 이름을 전달합니다.
      다음은 두 가지 예입니다.

         IMAGE_EFI_BOOT_FILES = "boot/loader/*"
         IMAGE_EFI_BOOT_FILES = "boot/loader/*;boot/"

      첫 번째 예시
      `${DEPLOY_DIR_IMAGE}/boot/loader/` 경로의 모든 파일을 설치합니다.
      대상 파티션의 루트에 설치합니다. 두 번째 예제는 설치 과정을 보여줍니다.
      대상 파티션 내의 "boot" 디렉터리에 동일한 파일을 저장합니다.

      Wic 도구 사용 방법에 대한 정보는 다음에서 찾을 수 있습니다.
      ":ref:`dev-manual/wic:wic를 사용하여 파티션된 이미지 생성`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션을 참조하십시오.
      Wic 관련 자료는 다음 위치에 있습니다.
      ":doc:`/ref-manual/kickstart`" 장.

### `IMAGE_EXTRA_PARTITION_FILES`

      추가 파티션에 설치된 파일 목록을 공백으로 구분하여 표시합니다.
      Wic 도구를 사용하여 이미지를 준비할 때
      ``extra_partition`` 소스 플러그인. 기본적으로,
      파일들은
      소스 파일과 동일한 이름으로 설치됩니다. 변경하려면
      설치된 이름과 원래 이름을 세미콜론으로 구분합니다.
      (;). 소스 파일은 다음 위치에 있어야 합니다.
      `DEPLOY_DIR_IMAGE`. 여기에 있습니다.
      예::

         IMAGE_EXTRA_PARTITION_FILES = "foobar file.conf;config"

      위 예시에서 `foobar` 파일은 원래 이름 그대로 설치됩니다.
      `foobar`가 실행되는 동안 `file.conf` 파일은 설치되고 `config`로 이름이 변경됩니다.

      또는 글로브 패턴을 사용하여 소스 파일을 선택할 수도 있습니다.
      하지만 숨겨진 파일은 무시되며, 해당 패턴은 재귀적이지 않습니다.
      (하위 디렉터리는 무시됩니다.)
      최종 파일의 이름은 기본 파일과 동일합니다.
      소스 파일 경로의 이름입니다. 이름을 변경한 디렉터리에 파일을 설치하려면 이 경로를 사용하십시오.
      대상 위치 내에서 세미콜론(;) 뒤에 해당 이름을 전달합니다.
      다음은 두 가지 예입니다.

         IMAGE_EXTRA_PARTITION_FILES = "foo/*"
         IMAGE_EXTRA_PARTITION_FILES = "foo/*;bar/"

      이 예제의 첫 번째 줄
      `foo` 디렉토리의 모든 파일을 설치합니다.
      대상 파티션의 루트에 설치합니다. 이 예제의 두 번째 줄은 설치 과정을 보여줍니다.
      동일한 파일을 대상 파티션 내의 "bar" 디렉터리에 저장합니다.
      ``bar/`` 디렉토리가 존재하지 않으면 자동으로 생성됩니다.

      대상을 지정할 때는 레이블, UUID 또는 파티션 이름(여러 개인 경우)을 사용할 수도 있습니다.
      추가 파티션이 공존합니다. 다음 예를 살펴보겠습니다. 이것은 다음과 같습니다.
      현재 빌드 중인 이미지의 WKS 파일입니다.

         파트 --소스 추가 파티션 --fstype=ext4 --레이블 foo
         파트 --소스 추가 파티션 --fstype=ext4 --uuid e7d0824e-cda3-4bed-9f54-9ef5312d105d
         part --source extra_partition --fstype=ext4 --part-name config

      그리고 다음과 같은 구성입니다::

         IMAGE_EXTRA_PARTITION_FILES_label-foo = "foo/*"
         IMAGE_EXTRA_PARTITION_FILES_uuid-e7d0824e-cda3-4bed-9f54-9ef5312d105d = "foo/*;bar/"
         IMAGE_EXTRA_PARTITION_FILES_part-name-config = "config"

      그 다음에:

      - "foo"라고 표시된 파티션에는 "foo" 디렉터리의 모든 파일이 저장됩니다.
         예배 규칙서.

      - UUID가 "e7d0824e-cda3-4bed-9f54-9ef5312d105d"인 파티션
         `foo` 디렉토리의 모든 파일을 가져와서 설치합니다.
         ``bar`` 디렉토리.

      - "config"라는 이름의 파티션에는 `config` 파일이 저장됩니다.

      Wic 도구 사용 방법에 대한 정보는 다음에서 찾을 수 있습니다.
      ":ref:`dev-manual/wic:wic를 사용하여 파티션된 이미지 생성`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션을 참조하십시오.
      Wic 관련 자료는 다음 위치에 있습니다.
      ":doc:`/ref-manual/kickstart`" 장.

### `IMAGE_FEATURES`

      이미지에 포함할 주요 특징 목록입니다. 일반적으로 다음과 같습니다.
      이미지 레시피에서 이 변수를 구성하세요. 이렇게 사용할 수도 있지만요.
      `local.conf` 파일의 변수를 사용하세요. 이 변수는 다음 위치에 있습니다.
      `빌드 디렉토리`의 경우, 모범 사례에 따르면 다음과 같이 해야 합니다.
      아니다.

      .. 메모::

         이미지 레시피 외부에서 추가 기능을 활성화하려면 다음을 사용하십시오.
         `EXTRA_IMAGE_FEATURES` 변수.

      Yocto 프로젝트에 포함된 이미지 기능 목록은 다음을 참조하세요.
      ":ref:`ref-features-image`" 섹션.

      이 예시를 통해 이미지를 사용자 지정하는 방법을 알아보겠습니다.
      변수에 대한 자세한 내용은 ":ref:`dev-manual/customizing-images:custom \`\`image_features\`\` 및 \`\`extra_image_features\`\``를 참조하세요."
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `IMAGE_FSTYPES`

      OpenEmbedded 빌드 시스템이 사용하는 형식을 지정합니다.
      루트 파일 시스템을 생성할 때 빌드합니다. 예를 들어, 설정은 다음과 같습니다.
      다음과 같이 ``IMAGE_FSTYPES`를 지정하면 빌드 시스템이 루트를 생성합니다.
      파일 시스템은 `.ext3` 및 `.tar.bz2` 두 가지 형식을 사용합니다.

         IMAGE_FSTYPES = "ext3 tar.bz2"

      지원되는 이미지 형식의 전체 목록을 보려면 다음을 참조하십시오.
      선택하려면 `IMAGE_TYPES`를 참조하세요.

      .. 메모::

         - 이미지 레시피에 "이미지 상속" 줄이 사용되었고 다음과 같은 경우
            레시피 내에서 `IMAGE_FSTYPES` 설정을 하려면 다음 조건을 만족해야 합니다.
            `이미지 상속` 줄을 사용하기 전에 `IMAGE_FSTYPES`를 사용하십시오.

         - OpenEmbedded 빌드 시스템의 처리 방식 때문에
            변수의 경우 `:append`를 사용하여 내용을 업데이트할 수 없습니다.
            또는 ``:prepend``를 사용하세요. 하나를 추가하려면 ``+=`` 연산자를 사용해야 합니다.
            `IMAGE_FSTYPES` 변수에 대한 추가 옵션입니다.

### `IMAGE_INSTALL`

      레시피에서 이미지에 설치할 패키지를 지정하는 데 사용됩니다.
      `ref-classes-image` 클래스를 통해 사용합니다.
      순서 오류를 방지하기 위해 `IMAGE_INSTALL` 변수를 주의해서 사용하십시오.

      이미지 레시피는 패키지를 지정하기 위해 `IMAGE_INSTALL` 설정을 사용합니다.
      `ref-classes-image`를 통해 이미지에 설치합니다. 또한,
      `ref-classes-core-image`와 같은 "도우미" 클래스가 있습니다.
      `IMAGE_FEATURES`와 함께 사용되는 리스트를 받아 변환할 수 있는 클래스
      또한, 해당 항목들을 `IMAGE_INSTALL`에 자동 생성된 항목으로 추가합니다.
      기본 설정값으로 되돌립니다.

      이 변수를 사용할 때는 다음과 같이 사용하는 것이 가장 좋습니다.

         IMAGE_INSTALL:append = " 패키지 이름"

      공백을 꼭 포함하세요
      따옴표 문자와 패키지 이름 시작 부분 사이 또는
      이름들.

      .. 메모::

         - ~와 함께 일할 때
            :ref:`core-image-minimal-initramfs <ref-manual/images:images>`
            이미지의 경우, `IMAGE_INSTALL` 변수를 사용하여 지정하지 마십시오.
            설치용 패키지를 사용하세요. 대신 다음을 사용하세요.
            `PACKAGE_INSTALL` 변수,
            초기 RAM 파일 시스템(Initramfs) 레시피에서 다음을 사용할 수 있도록 합니다.
            고정된 패키지 세트이며 `IMAGE_INSTALL`의 영향을 받지 않습니다.
            Initramfs를 생성하는 방법에 대한 자세한 내용은 다음을 참조하십시오.
            ":ref:`dev-manual/building:초기 RAM 파일 시스템(Initramfs) 이미지 빌드`"
            Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

         - `IMAGE_INSTALL`을 사용하여
            :ref:`+= <bitbake-user-manual/bitbake-user-manual-metadata:공백을 추가(+=)하고 앞에 추가(=+)>`
            ``/conf/local.conf`` 파일 내의 BitBake 연산자 또는
            이미지 레시피 내에서 이 연산자를 사용하는 것은 권장되지 않습니다.
            이러한 방식은 주문 문제를 야기할 수 있습니다. 왜냐하면
            :ref:`ref-classes-core-image`는 `IMAGE_INSTALL`을 다음과 같이 설정합니다.
            기본값을 사용하여
            :ref:`?= <bitbake-user-manual/bitbake-user-manual-metadata:기본값 설정(?=)>`
            연산자, `IMAGE_INSTALL`에 대해 ``+=`` 연산을 사용합니다.
            사용 시 예상치 못한 동작이 발생합니다.
            `conf/local.conf`. 또한, 동일한 작업을 내부에서 수행하면
            이미지 레시피는 특정 상황에 따라 성공할 수도 있고 실패할 수도 있습니다.
            상황에 대한 것입니다. 두 경우 모두 행동은 상황과 정반대입니다.
            대부분의 사용자는 ``+=`` 연산자가 작동할 것으로 기대합니다.

### `IMAGE_LINGUAS`

      이미지에 설치할 로케일 목록을 지정합니다.
      루트 파일 시스템 구축 프로세스. OpenEmbedded 빌드 시스템
      로컬라이제이션에 사용되는 로케일 파일을 자동으로 분할합니다.
      별도의 패키지로 분리합니다. `IMAGE_LINGUAS` 변수를 설정합니다.
      이미 존재하는 패키지에 해당하는 모든 로케일 패키지를 보장합니다.
      이미지에 설치하도록 선택된 항목들도 설치됩니다. 다음은 그 예입니다.
      예시:

         IMAGE_LINGUAS = "pt-br de-de"

      이 예시에서 빌드 시스템은 모든 브라질 포르투갈어를 보장합니다.
      이미지에 포함된 패키지에 해당하는 독일어 로케일 파일은 다음과 같습니다.
      설치된 것 (예: ``*-locale-pt-br`` 및 ``*-locale-de-de``)
      일부 소프트웨어 패키지에서 ``*-locale-pt`` 및 ``*-locale-de``를 사용할 수 있습니다.
      언어별 로케일 파일만 제공하고 국가별 파일은 제공하지 마십시오.
      언어).

      `GLIBC_GENERATE_LOCALES`를 참조하십시오.
      GLIBC 로케일 생성에 대한 정보를 담은 변수입니다.


### `IMAGE_LINK_NAME`

      출력 이미지 심볼릭 링크의 이름(다음은 포함되지 않음)
      버전 부분은 ``IMAGE_NAME`과 같습니다. 기본값
      IMAGE_BASENAME을 사용하여 파생됩니다.
      `IMAGE_MACHINE_SUFFIX` 변수::

         IMAGE_LINK_NAME ?= "${IMAGE_BASENAME}${IMAGE_MACHINE_SUFFIX}"

      .. 메모::

         심볼릭 링크 생성을 비활성화하려면 이 값을 ""로 설정할 수 있습니다.
         하지만, 여전히 이미지 이름을 사용하려면 `IMAGE_NAME`도 설정해야 합니다.
         합리적인 값 예시:

            IMAGE_LINK_NAME = ""
            IMAGE_NAME = "${IMAGE_BASENAME}${IMAGE_MACHINE_SUFFIX}${IMAGE_VERSION_SUFFIX}"

### `IMAGE_MACHINE_SUFFIX`

      이미지 파일 이름에 기본적으로 적용되는 기기별 접미사를 지정합니다.
      (확장 전). 기본값은 다음과 같이 설정됩니다.

         IMAGE_MACHINE_SUFFIX ??= "-${MACHINE}"

      기본값인 `DEPLOY_DIR_IMAGE`에는 이미 `MACHINE`이 있습니다.
      하위 디렉터리이므로 이 접미사를 포함할 필요가 없을 수도 있습니다.
      모든 이미지 파일 이름에 접미사가 붙습니다. 접미사를 제거하고 싶으시면,
      이 변수를 빈 문자열로 설정할 수 있습니다.

         IMAGE_MACHINE_SUFFIX = ""

      (이미지 이름 접미사와 혼동하지 마십시오.)

### `IMAGE_MANIFEST`

      이미지의 매니페스트 파일입니다. 이 파일에는 설치된 모든 항목이 나열됩니다.
      이미지를 구성하는 패키지들입니다. 파일에는 패키지들이 포함되어 있습니다.
      다음과 같이 패키지별 세부 정보가 제공됩니다.

          패키지 이름 패키지 아키텍처 버전

      `:ref:rootfs-postcommands <ref-classes-rootfs*>` 클래스는 매니페스트를 정의합니다.
      다음과 같이 파일을 작성하십시오::

         IMAGE_MANIFEST = "${IMGDEPLOYDIR}/${IMAGE_NAME}${IMAGE_NAME_SUFFIX}.manifest"

      위치는 다음과 같습니다.
      `IMGDEPLOYDIR`을 사용하여 파생됨
      그리고 `IMAGE_NAME` 변수들을 찾을 수 있습니다.
      이미지 생성 방법에 대한 정보는 ":ref:`overview-manual/concepts:image generation`"에서 확인할 수 있습니다.
      Yocto 프로젝트 개요 및 개념 설명서의 해당 섹션을 참조하십시오.

### `IMAGE_NAME`

      출력 이미지 파일의 이름에서 확장자를 제외한 값입니다. 기본값은 다음과 같습니다.
      이 변수는 ``IMAGE_LINK_NAME`을 사용하여 설정됩니다.
      `IMAGE_VERSION_SUFFIX` 변수::

         IMAGE_NAME ?= "${IMAGE_LINK_NAME}${IMAGE_VERSION_SUFFIX}"

### `IMAGE_NAME_SUFFIX`

      이미지 출력 파일 이름에 사용되는 접미사 --- 기본값은 ``".rootfs"``입니다.
      이미지 파일을 이미지 생성 중에 생성된 다른 파일과 구별하기 위해
      건물; 하지만 이 접미사가 불필요하거나 원하지 않는 경우 다음과 같이 할 수 있습니다.
      이 변수의 값을 초기화합니다(값을 ""로 설정). 예를 들어,
      이 문제는 일반적으로 Initramfs 이미지 레시피에서 해결됩니다.

### `IMAGE_OUTPUT_MANIFEST`

      :ref:`ref-classes-image` 클래스를 직접 또는 간접적으로 상속할 때
      :ref:`ref-classes-core-image` 클래스, `IMAGE_OUTPUT_MANIFEST`
      생성된 이미지 목록을 담고 있는 매니페스트 ``json`` 파일을 가리킵니다.
      다양한 이미지 생성 작업(문서 `IMAGE_FSTYPES`에 정의된 대로)
      변수). 이는 :ref:`ref-classes-image` 클래스에서 다음과 같이 설정됩니다.

          IMAGE_OUTPUT_MANIFEST = "${IMAGE_OUTPUT_MANIFEST_DIR}/manifest.json"

### `IMAGE_OUTPUT_MANIFEST_DIR`

      :ref:`ref-classes-image` 클래스를 직접 또는 간접적으로 상속할 때
      :ref:`ref-classes-core-image` 클래스에서 `IMAGE_OUTPUT_MANIFEST_DIR`은 다음을 가리킵니다.
      매니페스트 ``json`` 파일이 저장된 디렉터리로, 해당 파일에는 무엇이 나열되어 있습니다.
      이미지는 다양한 이미지 생성 작업(정의된 바와 같이)을 통해 생성되었습니다.
      `IMAGE_FSTYPES` 변수). 이는 :ref:`ref-classes-image`에 설정됩니다.
      다음과 같이 분류됩니다::

          IMAGE_OUTPUT_MANIFEST_DIR = "${WORKDIR}/deploy-image-output-manifest"

### `IMAGE_OVERHEAD_FACTOR`

      빌드 시스템이 초기값에 적용하는 승수를 정의합니다.
      이미지 크기는 반환된 디스크에 곱해지는 곱셈의 경우에 해당합니다.
      이미지의 사용 가치는 합계보다 큽니다.
      `IMAGE_ROOTFS_SIZE` 및 `IMAGE_ROOTFS_EXTRA_SPACE`. 결과는 다음과 같습니다.
      초기 이미지 크기에 적용되는 배율은 디스크 공간을 확보합니다.
      이미지의 공간을 오버헤드로 사용합니다. 기본적으로 빌드 프로세스는 다음을 사용합니다.
      이 변수에 1.3의 승수가 적용됩니다. 이 기본값은 다음과 같은 결과를 가져옵니다.
      이 방법을 사용하면 이미지에 30%의 여유 디스크 공간이 추가됩니다.
      최종 생성 이미지 크기를 결정합니다. 다음 사항에 유의해야 합니다.
      설치 후 스크립트와 패키지 관리 시스템은 디스크를 사용합니다.
      이 머리 위 공간 내부에 공간이 있습니다. 따라서 승수는 다음과 같습니다.
      이론상 모든 여유 디스크 공간을 활용하여 이미지를 생성하지 않습니다. 참조
      빌드 시스템의 정보 확인 방법은 `IMAGE_ROOTFS_SIZE`를 참조하세요.
      전체 이미지 크기를 결정합니다.

      일반적으로 기본 설정값인 30%의 여유 디스크 공간은 이미지 저장에 충분한 공간을 제공합니다.
      부팅을 지원하고 기본적인 설치 후 작업을 허용하면서도 여전히 여유 공간을 남겨둡니다.
      디스크 여유 공간이 부족합니다. 30%의 여유 공간이 부족하다면,
      기본값을 높일 수 있습니다. 예를 들어, 다음 설정은 다음과 같습니다.
      이미지에 50%의 여유 공간이 추가됩니다.

         이미지 오버헤드 계수 = "1.5"

      또는 특정 용량의 여유 디스크 공간을 확보할 수도 있습니다.
      `IMAGE_ROOTFS_EXTRA_SPACE`를 사용하여 이미지에 추가됨
      변하기 쉬운.

      Wic 도구를 사용할 때 두 번째 오버헤드 요소가 적용된다는 점에 유의하십시오.
      이 오버헤드 값은 `--overhead-factor` 옵션에 의해 정의됩니다.
      생략 시 기본값은 "1.3"입니다. 자세한 내용은 다음을 참조하십시오.
      :ref:`ref-manual/kickstart:command: part or partition` 챕터
      자세한 내용은 :doc:`/ref-manual/kickstart`를 참조하세요.

### `IMAGE_PKGTYPE`

      사용되는 패키지 유형(예: DEB, RPM 또는 IPK)을 정의합니다.
      OpenEmbedded 빌드 시스템. 해당 변수는 적절하게 정의되어 있습니다.
      :ref:`ref-classes-package_deb`, :ref:`ref-classes-package_rpm` 중 하나,
      또는 :ref:`ref-classes-package_ipk` 클래스.

      :ref:`ref-classes-populate-sdk-*` 및 :ref:`ref-classes-image`
      클래스는 이미지 및 SDK 패키징에 `IMAGE_PKGTYPE`을 사용합니다.

      `IMAGE_PKGTYPE` 속성을 수동으로 설정해서는 안 됩니다. 대신,
      변수는 적절한 경로를 통해 간접적으로 설정됩니다.
      :ref:`package_* <ref-classes-package>` 클래스를 사용하여
      `PACKAGE_CLASSES` 변수.
      OpenEmbedded 빌드 시스템은 첫 번째 패키지 유형(예: DEB, RPM)을 사용합니다.
      또는 IPK) 변수와 함께 나타나는

### `IMAGE_POSTPROCESS_COMMAND`

      OpenEmbedded 빌드가 완료되면 호출할 함수 목록을 지정합니다.
      시스템은 최종 이미지 출력 파일을 생성합니다. 다음과 같이 지정할 수 있습니다.
      함수들을 공백으로 구분하세요::

         IMAGE_POSTPROCESS_COMMAND += "function"

      루트 파일 시스템 경로를 명령에 전달해야 하는 경우
      이 함수에서는 `${IMAGE_ROOTFS}`를 사용할 수 있으며, 이는 해당 경로를 가리킵니다.
      루트 파일 시스템 이미지가 되는 디렉터리입니다. 자세한 내용은 다음을 참조하십시오.
      `IMAGE_ROOTFS` 변수에 대한 자세한 내용은 다음을 참조하십시오.
      정보.

### `IMAGE_PREPROCESS_COMMAND`

      OpenEmbedded 빌드 전에 호출할 함수 목록을 지정합니다.
      시스템은 최종 이미지 출력 파일을 생성합니다. 다음과 같이 지정할 수 있습니다.
      함수들을 공백으로 구분하세요::

         IMAGE_PREPROCESS_COMMAND += "function"

      루트 파일 시스템 경로를 명령에 전달해야 하는 경우
      이 함수에서는 `${IMAGE_ROOTFS}`를 사용할 수 있으며, 이는 해당 경로를 가리킵니다.
      루트 파일 시스템 이미지가 되는 디렉터리입니다. 자세한 내용은 다음을 참조하십시오.
      `IMAGE_ROOTFS` 변수에 대한 자세한 내용은 다음을 참조하십시오.
      정보.

### `IMAGE_ROOTFS`

      루트 파일 시스템이 구축되는 동안의 위치
      (즉, :ref:`ref-tasks-rootfs` 작업 중에).
      이 변수는 설정할 수 없습니다. 변경하지 마십시오.

### `IMAGE_ROOTFS_ALIGNMENT`

      출력 이미지 파일의 정렬 크기를 킬로바이트 단위로 지정합니다.
      이미지 크기가 이 값의 배수가 아니면 크기는 다음과 같습니다.
      값의 가장 가까운 배수로 올림됩니다. 기본값은 다음과 같습니다.
      "1". `IMAGE_ROOTFS_SIZE`를 참조하세요.
      추가 정보.

### `IMAGE_ROOTFS_EXTRA_SPACE`

      이미지에 생성된 추가 사용 가능한 디스크 공간을 킬로바이트(KB) 단위로 정의합니다.
      기본적으로 이 변수는 "0"으로 설정됩니다. 이 여유 디스크 공간이 추가됩니다.
      빌드 시스템이 이미지 크기를 결정한 후 이미지에 다음과 같이 표시합니다.
      `IMAGE_ROOTFS_SIZE`에 설명되어 있습니다.

      이 변수는 특히 다음 사항을 보장하고자 할 때 유용합니다.
      특정 용량의 여유 디스크 공간이 장치에 사용 가능합니다.
      이미지가 설치되어 실행 중입니다. 예를 들어, 5GB의 용량이 필요한지 확인하려면
      디스크 여유 공간이 있으면 변수를 다음과 같이 설정하세요.

         IMAGE_ROOTFS_EXTRA_SPACE = "5242880"

      예를 들어, Yocto Project Build Appliance는 다음과 같이 구체적으로 요청합니다.
      40GB의 추가 공간이 다음 줄에 있습니다::

         IMAGE_ROOTFS_EXTRA_SPACE = "41943040"

### `IMAGE_ROOTFS_MAXSIZE`

      생성될 이미지의 최대 허용 크기를 킬로바이트 단위로 정의합니다.
      생성된 이미지 크기가 이 값을 초과하면 빌드가 실패합니다.

      생성된 이미지 크기는 최종 크기가 되기 전에 여러 계산 단계를 거칩니다.
      `IMAGE_ROOTFS_MAXSIZE`와 비교합니다.
      첫 번째 단계에서는 ``IMAGE_ROOTFS`가 가리키는 디렉터리의 크기를 확인합니다.
      계산됩니다.
      두 번째 단계에서는 첫 번째 단계의 결과에 를 곱합니다.
      `IMAGE_OVERHEAD_FACTOR`에 의해 결정됩니다.
      세 번째 단계에서는 두 번째 단계의 결과를 다음과 비교합니다.
      `IMAGE_ROOTFS_SIZE`. 이 값들 중 더 큰 값이 추가됩니다.
      `IMAGE_ROOTFS_EXTRA_SPACE`.
      네 번째 단계에서는 세 번째 단계의 결과를 확인합니다.
      소수 부분이 있는 경우, 다음 정수로 반올림됩니다.
      그렇지 않은 경우, 단순히 정수로 변환됩니다.
      다섯 번째 단계에서는 결과에 ``IMAGE_ROOTFS_ALIGNMENT`가 추가됩니다.
      네 번째 단계에서 "1"을 뺀 값입니다.
      여섯 번째 단계에서는 결과 사이의 나눗셈의 나머지가 계산됩니다.
      다섯 번째 단계부터 `IMAGE_ROOTFS_ALIGNMENT`가 빼집니다.
      다섯 번째 단계의 결과입니다. 이와 같이 네 번째 단계의 결과는 다음과 같습니다.
      `IMAGE_ROOTFS_ALIGNMENT`의 가장 가까운 배수로 반올림됩니다.

      따라서, `IMAGE_ROOTFS_MAXSIZE`가 설정된 경우, 결과와 비교됩니다.
      위 계산 결과는 최종 이미지 유형과 무관합니다.
      `IMAGE_ROOTFS_MAXSIZE`에는 기본값이 설정되어 있지 않습니다.

      제한된 공간에 맞춰야 하는 이미지의 경우 이 변수를 설정하는 것이 좋습니다.
      저장 공간(예: SD 카드, 고정 크기 파티션 등).

### `IMAGE_ROOTFS_SIZE`

      생성된 이미지의 크기를 킬로바이트 단위로 정의합니다. OpenEmbedded
      빌드 시스템은 생성된 이미지의 최종 크기를 결정합니다.
      초기 디스크 공간 사용량을 고려하는 알고리즘
      생성된 이미지, 요청된 이미지 크기 및 요청된
      이미지에 추가할 여유 디스크 공간입니다. 프로그램적으로,
      빌드 시스템은 생성된 이미지의 최종 크기를 다음과 같이 결정합니다.
      다음이 따릅니다::

         이미지-du * 오버헤드가 루트 파일 시스템 크기보다 작으면:
             내부 루트 파일 시스템 크기 = 루트 파일 시스템 크기 + xspace
         또 다른:
             내부 루트 파일 시스템 크기 = (이미지 듀티 사이클 * 오버헤드) + xspace
         어디:
             image-du = 이미지에 대한 du 명령의 반환 값입니다.
             오버헤드 = 이미지 오버헤드 계수
             루트 파일 시스템 크기 = 이미지_루트 파일 시스템 크기
             internal-rootfs-size = 수정 전 초기 루트 파일 시스템 크기입니다.
             xspace = IMAGE_ROOTFS_EXTRA_SPACE

      `IMAGE_OVERHEAD_FACTOR`를 참조하십시오.
      및 `IMAGE_ROOTFS_EXTRA_SPACE`
      관련 정보를 위한 변수입니다.

### `IMAGE_TYPEDEP`

      한 이미지 유형이 다른 이미지 유형에 의존하는 관계를 지정합니다. 다음은 그 예입니다.
      :ref:`ref-classes-image-live` 클래스의 예시::

         IMAGE_TYPEDEP:live = "ext3"

      이전 예시에서 해당 변수는 "live"일 때를 보장합니다.
      `IMAGE_FSTYPES` 변수에 나열되어 있습니다.
      OpenEmbedded 빌드 시스템은 우선 ``ext3`` 이미지를 생성합니다.
      실시간 이미지의 구성 요소 중 하나는 ``ext3`` 형식의 파일입니다.
      루트 파일 시스템이 포함된 파티션입니다.

### `IMAGE_TYPES`

      기본적으로 지원되는 이미지 유형의 전체 목록을 지정합니다.

      - btrfs
      - 컨테이너
      - cpio
      - cpio.gz
      - cpio.lz4
      - cpio.lzma
      - cpio.xz
      - 경련
      - 에로프스
      - erofs-lz4
      - erofs-lz4hc
      - ext2
      - ext2.bz2
      - ext2.gz
      - ext2.lzma
      - ext3
      - ext3.gz
      - ext4
      - ext4.gz
      - f2fs
      - hddimg
      - ISO
      - jffs2
      - jffs2.sum
      - 멀티유비
      - 스쿼시프스
      - 스쿼시fs-lz4
      - 스쿼시fs-lzo
      - 스쿼시fs-xz
      - 타르
      - tar.bz2
      - tar.gz
      - tar.lz4
      - tar.xz
      - tar.zst
      - 유비
      - 우비프스
      - wic
      - wic.bz2
      - wic.gz
      - wic.lzma
      - wic.zst

      이러한 유형의 이미지에 대한 자세한 내용은 다음을 참조하십시오.
      소스 디렉터리에 ``meta/classes-recipe/image_types*.bbclass`` 파일이 있습니다.

### `IMAGE_VERSION_SUFFIX`

      기본 `IMAGE_NAME`에 포함된 버전 접미사 및
      `KERNEL_ARTIFACT_NAME` 값.
      기본값은 ``"-${DATETIME}"``이지만, 다른 값으로 설정할 수도 있습니다.
      외부 빌드 환경에서 가져온 버전 문자열입니다.
      원하는 대로 하면 이 접미사가 일관되게 사용될 것입니다.
      빌드 결과물.

### `IMGDEPLOYDIR`

      `ref-classes-image` 클래스를 직접 상속할 때 또는
      `ref-classes-core-image` 클래스를 통해,
      `IMGDEPLOYDIR`은 배포된 파일을 위한 임시 작업 영역을 가리킵니다.
      이는 ``image`` 클래스에 다음과 같이 설정되어 있습니다.

         IMGDEPLOYDIR = "${WORKDIR}/deploy-${PN}-image-complete"

      `ref-classes-image` 클래스를 상속받는 레시피는 복사해야 합니다.
      배포할 파일은 `IMGDEPLOYDIR` 디렉터리에 저장되며, 클래스는 해당 디렉터리를 사용하게 됩니다.
      나중에 해당 파일들을 `DEPLOY_DIR_IMAGE` 디렉터리에 복사하는 것을 잊지 마세요.

### `IMGMANIFESTDIR`

      :ref:`ref-classes-image` 클래스를 직접 또는 간접적으로 상속할 때
      :ref:`ref-classes-core-image` 클래스, `IMGMANIFESTDIR` 설정
      매니페스트 ``json`` 파일을 저장하는 임시 영역을 가리키며, 해당 파일에는 목록이 있습니다.
      다양한 이미지 생성 작업(정의된 바에 따라)을 통해 어떤 이미지가 생성되었습니까?
      `IMAGE_FSTYPES` 변수에 설정됩니다.
      :ref:`ref-classes-image` 클래스는 다음과 같습니다::

          IMGMANIFESTDIR = "${WORKDIR}/image-task-manifest"

### `INCOMPATIBLE_LICENSE`

      라이선스 이름 목록을 공백으로 구분하여 지정합니다(예: 라이선스 이름).
      라이선스 문서(LICENSE)에 나타나는 내용은 제외되어야 합니다.
      빌드에서 가져온 정보(전역적으로 설정된 경우) 또는 이미지에서 가져온 정보(로컬로 설정된 경우)
      이미지 레시피에서).

      해당 변수가 전역적으로 설정되면, 나열된 레시피에 대한 대안을 제공하지 않는 레시피가 표시됩니다.
      호환되지 않는 라이선스는 빌드되지 않습니다. 개별적으로 제공되는 패키지는 빌드되지 않습니다.
      지정된 호환되지 않는 라이선스로 라이선스가 부여된 파일은 삭제됩니다.
      대부분의 경우 이로 인해 실행 가능한 빌드가 불가능해집니다(불가능해지기 때문입니다).
      빌드 시간 종속성을 충족하기 위해) 권장되는 방법은 다음과 같습니다.
      라이선스 제한을 구현하려면 특정 변수를 설정해야 합니다.
      제한 사항이 적용되어야 하는 이미지 레시피입니다. 그렇게 하면 됩니다.
      빌드 시간 제한은 없지만 라이선스 확인은 여전히 ​​필요합니다.
      이미지의 파일 시스템이 패키지로부터 조립될 때 수행됩니다.

      이 변수 값에는 와일드카드 사용이 일부 지원됩니다.
      하지만 특정 라이선스에 한해서만 사용 가능합니다. 현재는 다음만 해당됩니다.
      다음 와일드카드는 허용되며 다음과 같이 확장됩니다.

      - ``AGPL-3.0*"``: ``AGPL-3.0 전용``, ``AGPL-3.0 이상``
      - ``GPL-3.0*``: ``GPL-3.0 전용``, ``GPL-3.0 이상``
      - ``LGPL-3.0*``: ``LGPL-3.0 전용``, ``LGPL-3.0 이상``

      .. 메모::

         이 기능은 다음을 사용하여 정기적으로 테스트됩니다.
         환경::

                 INCOMPATIBLE_LICENSE = "GPL-3.0* LGPL-3.0* AGPL-3.0*"


         다른 설정을 사용할 수도 있지만, 다음과 같은 설정이 필요할 수 있습니다.
         구성 요소에 대한 의존성을 제거하거나 (또는 ​​대안을 제공합니다)
         기능적인 시스템 이미지를 생성하려면 다음이 필요합니다.

### `INCOMPATIBLE_LICENSE_EXCEPTIONS`

      패키지와 라이선스 쌍을 공백으로 구분하여 지정합니다.
      라이선스가 명시되어 있더라도 사용이 허용됩니다.
      `호환되지 않는 라이선스`. 패키지와 라이선스 쌍은 다음과 같습니다.
      콜론으로 구분합니다. 예시:

         INCOMPATIBLE_LICENSE_EXCEPTIONS = "gdbserver:GPL-3.0-only gdbserver:LGPL-3.0-only"

### `INHERIT`

      지정된 클래스 또는 클래스들이 전역적으로 상속되도록 합니다. 익명
      해당 클래스 또는 클래스 내의 함수는 기본 실행 시 실행되지 않습니다.
      구성 및 각 개별 레시피에서. OpenEmbedded 빌드
      시스템은 개별 레시피의 ``INHERIT`에 대한 변경 사항을 무시합니다.
      ``INHERIT`를 사용하여 상속된 클래스는 다음 위치에 있어야 합니다.
      `classes-global/` 또는 `classes/` 하위 디렉터리.

      `INHERIT`에 대한 자세한 내용은 다음을 참조하십시오.
      :ref:`bitbake-user-manual/bitbake-user-manual-metadata:\`\`inherit\`\` 구성 지시문`"
      BitBake 사용자 설명서의 해당 섹션입니다.

### `INHERIT_DISTRO`

      배포 수준에서 상속될 클래스 목록입니다.
      이 변수를 수정하고 싶지 않을 가능성이 높습니다.

      `INHERIT_DISTRO`에 지정된 클래스는 다음 위치에 있어야 합니다.
      `classes-global/` 또는 `classes/` 하위 디렉터리.

      해당 변수의 기본값은 다음과 같이 설정됩니다.
      ``meta/conf/distro/defaultsetup.conf`` 파일::

         INHERIT_DISTRO ?= "debian devshell sstate license remove-libtool create-spdx"

### `INHIBIT_AUTOTOOLS_DEPS`

      :ref:`ref-classes-autotools` 클래스가 자동으로 추가하는 것을 방지합니다.
      기본 빌드 시 종속성입니다.

      레시피가 `:ref:`ref-classes-autotools` 클래스를 상속받으면 여러 가지 문제가 발생합니다.
      `autoconf-native`, `automake-native`와 같은 네이티브 크로스 툴
      `libtool-native`와 `libtool-cross`가 `DEPENDS`에 추가되었습니다.
      `autotools` 빌드 프로세스를 지원합니다.

      빌드 시스템이 이러한 종속성을 자동으로 추가하는 것을 방지하려면,
      `INHIBIT_AUTOTOOLS_DEPS` 변수를 다음과 같이 설정하십시오::

         INHIBIT_AUTOTOOLS_DEPS = "1"

      기본적으로 ``INHIBIT_AUTOTOOLS_DEPS` 값은 비어 있습니다. 설정하려면
      값을 "0"으로 설정해도 억제 기능이 비활성화되지 않습니다. 빈 문자열로 설정해야만 억제 기능이 비활성화됩니다.
      금지.

### `INHIBIT_DEFAULT_DEPS`

      기본 종속성, 즉 C 컴파일러와 표준을 방지합니다.
      C 라이브러리(libc)가 `DEPENDS`에 추가되는 것을 방지합니다.
      이 변수는 일반적으로 아무런 조건이 필요하지 않은 레시피에서 사용됩니다.
      C 컴파일러를 사용한 컴파일.

      기본 종속성을 방지하려면 변수를 "1"로 설정하십시오.
      추가되고 있습니다.

### `INHIBIT_DEFAULT_RUST_DEPS`

      `ref-classes-rust` 클래스가 자동으로 추가되는 것을 방지합니다.
      기본 빌드 시 종속성입니다.

      레시피가 `:ref:`ref-classes-rust` 클래스를 상속받으면 여러 가지가 발생합니다.
      `rust-native` 및 `${RUSTLIB_DEP}`와 같은 도구(크로스 컴파일 시에만 추가됨)가 추가됩니다.
      `rust` 빌드 프로세스를 지원하기 위해 `DEPENDS`를 추가합니다.

      빌드 시스템이 이러한 종속성을 자동으로 추가하는 것을 방지하려면,
      `INHIBIT_DEFAULT_RUST_DEPS` 변수를 다음과 같이 설정하십시오::

         INHIBIT_DEFAULT_RUST_DEPS = "1"

      기본적으로 ``INHIBIT_DEFAULT_RUST_DEPS` 값은 비어 있습니다. 설정하려면
      값을 "0"으로 설정해도 억제 기능이 비활성화되지 않습니다. 빈 문자열로 설정해야만 억제 기능이 비활성화됩니다.
      금지.

### `INHIBIT_PACKAGE_DEBUG_SPLIT`

      OpenEmbedded 빌드 시스템에서 디버그를 분리하는 것을 방지합니다.
      패키징 중 정보. 기본적으로 빌드 시스템은 이를 분리합니다.
      디버깅 정보
      :ref:`ref-tasks-package` 작업. 자세한 내용은 다음을 참조하세요.
      디버그 정보가 어떻게 분리되는지는 다음을 참조하세요.
      `패키지 디버그 분할 스타일`
      변하기 쉬운.

      빌드 시스템이 디버그 정보를 분리하는 것을 방지하기 위해
      패키징 중에 ``INHIBIT_PACKAGE_DEBUG_SPLIT` 변수를 다음과 같이 설정하십시오.
      다음이 따릅니다::

         INHIBIT_PACKAGE_DEBUG_SPLIT = "1"

### `INHIBIT_PACKAGE_STRIP`

      "1"로 설정하면 빌드 결과에서 바이너리 파일을 제거하지 않습니다.
      패키지를 구성하고 ``-dbg`` 패키지에 소스가 포함되지 않도록 합니다.
      파일들.

      기본적으로 OpenEmbedded 빌드 시스템은 바이너리에서 불필요한 부분을 제거하고
      디버깅 기호를 ``${``\ `PN`\ ``}-dbg``에 입력합니다.
      따라서, 패키지 스트립을 사용할 때는 ``INHIBIT_PACKAGE_STRIP`을 설정해서는 안 됩니다.
      전반적인 디버깅 계획을 세웁니다.

### `INHIBIT_SYSROOT_STRIP`

      "1"로 설정하면 빌드 시 바이너리에서 해당 부분을 제거하지 않습니다.
      결과적으로 생성되는 sysroot.

      기본적으로 OpenEmbedded 빌드 시스템은 바이너리에서 불필요한 부분을 제거합니다.
      결과적으로 생성되는 sysroot. 특정 설정을 할 경우
      레시피에서 `INHIBIT_SYSROOT_STRIP` 변수를 "1"로 설정하면 억제됩니다.
      이 스트립쇼.

      이 변수를 사용하려면 `:ref:ref-classes-staging`을 포함하세요.
      클래스입니다. 이 클래스는 `sys_strip()` 함수를 사용하여 변수를 테스트합니다.
      그리고 그에 따라 행동합니다.

      .. 메모::

         ``INHIBIT_SYSROOT_STRIP` 변수의 사용은 드물게 발생합니다.
         특별한 상황입니다. 예를 들어, 건물을 짓고 있다고 가정해 보세요.
         외부 GCC 툴체인을 사용하여 베어메탈 펌웨어를 빌드합니다. 또한,
         툴체인의 바이너리 파일을 제거할 수 있더라도 다른 파일들이 있습니다.
         빌드에 필요하지만 제거할 수 없는 요소입니다.

### `INHIBIT_UPDATERCD_BBCLASS`

      :ref:`ref-classes-update-rc.d` 클래스가 자동으로 실행되는 것을 방지합니다.
      패키지용 SysV 초기화 스크립트 설치 및 등록.

      레시피가 `ref-classes-update-rc.d` 클래스를 상속받으면 초기화됩니다.
      스크립트는 일반적으로 다음 목록에 있는 패키지에 대해 설치 및 등록됩니다.
      `INITSCRIPT_PACKAGES`. 이렇게 하면 관련 항목이 보장됩니다.
      서비스는 적절한 실행 레벨에서 시작 및 중지됩니다.
      기존 SysV 초기화 시스템.

      빌드 시스템이 이러한 스크립트와 구성을 추가하는 것을 방지하려면
      자동으로 `INHIBIT_UPDATERCD_BBCLASS` 변수를 다음과 같이 설정합니다.

         INHIBIT_UPDATERCD_BBCLASS = "1"

      기본적으로 ``INHIBIT_UPDATERCD_BBCLASS` 값은 비어 있습니다. 설정하려면
      값을 "0"으로 설정해도 억제 기능이 비활성화되지 않습니다. 빈 문자열로 설정해야만 억제 기능이 비활성화됩니다.
      금지.

### `INIT_MANAGER`

      사용할 시스템 초기화 관리자를 지정합니다. 사용 가능한 옵션은 다음과 같습니다.

      - ``sysvinit``
      - ``systemd``
      - ``mdev-busybox``

      `sysvinit`을 사용하면 초기화 관리자가 설정됩니다.
      :wikipedia:`SysVinit <Init#SysV 스타일>`, 전통적인 UNIX 초기화 프로그램
      시스템입니다. 이는 Poky 배포판에서 기본적으로 선택되는 옵션이며, 다음과 함께 사용됩니다.
      Udev 장치 관리자(":ref:`device-manager`" 섹션 참조).

      `systemd`를 사용하면 초기화 관리자가 `systemd <Systemd>`가 됩니다.
      이는 위키피디아에 나와 있는 udev(<Udev>) 장치 관리자와 함께 제공됩니다.

      ``mdev-busybox``를 사용하면 초기화 관리자가 훨씬 더 간단한 BusyBox가 됩니다.
      BusyBox mdev 장치 관리자와 함께 init을 실행합니다. 이것이 가장 간단한 방법입니다.
      가장 가벼운 솔루션이며, 저가형 시스템에 가장 적합한 선택일 것입니다.
      CPU 속도가 다소 느리고 RAM 용량도 제한적입니다.

      더 구체적으로 말하면, 이것은 포함하기 위해 사용됩니다.
      `conf/distro/include/init-manager-${INIT_MANAGER}.inc`를 전역 변수에 추가합니다.
      구성입니다. 다음 내용을 확인해 보세요.
      :yocto_git:`meta/conf/distro/include/init-manager-*.inc </poky/tree/meta/conf/distro/include>`
      자세한 내용은 파일을 참조하시고, ":ref:`init-manager`"도 확인해 보세요.
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `INITRAMFS_DEPLOY_DIR_IMAGE`

      :ref:`ref-tasks-bundle_initramfs`에서 사용하는 배포 디렉토리를 나타냅니다.
      `INITRAMFS_IMAGE` 변수는 어디에서 가져올 것인가를 지정합니다. 이 변수는 다음과 같습니다.
      기본값은 ``${DEPLOY_DIR_IMAGE}``로 설정됩니다.
      :ref:`ref-classes-kernel` 클래스는 다음과 같은 경우에만 변경되도록 되어 있습니다.
      별도의 multiconfig를 통해 `Initramfs` 이미지를 빌드합니다.
      `INITRAMFS_MULTICONFIG`.

### `INITRAMFS_FSTYPES`

      초기 RAM 파일 시스템의 출력 이미지 형식을 정의합니다.
      (`Initramfs`)는 부팅 중에 사용됩니다. 지원되는 형식은 다음과 같습니다.
      지지하는 것들과 동일한 것들
      `IMAGE_FSTYPES` 변수.

      이 변수의 기본값은 다음과 같이 설정됩니다.
      ``meta/conf/bitbake.conf`` 구성 파일
      `소스 디렉토리`는 "cpio.gz"입니다. 리눅스 커널의
      초기 RAM 파일 시스템과는 대조적으로 `Initramfs` 메커니즘을 사용합니다.
      :wikipedia:`initrd <Initrd>` 메커니즘은 다음을 예상합니다.
      선택적으로 압축된 cpio 아카이브입니다.

### `INITRAMFS_IMAGE`

      이미지의 `PROVIDES` 이름을 지정합니다.
      초기 RAM 파일 시스템(Initramfs)을 구축하는 데 사용되는 레시피
      이미지. 다시 말해, `INITRAMFS_IMAGE` 변수는 이미지를 생성합니다.
      루트에 대한 종속성으로 빌드될 추가 레시피
      사용 중인 파일 시스템 레시피(예: ``core-image-sato``)가 있을 수 있습니다.
      제공하시는 Initramfs 이미지 레시피는 다음과 같이 설정되어야 합니다.
      `IMAGE_FSTYPES`를
      `INITRAMFS_FSTYPES`.

      Initramfs 이미지는 임시 루트 파일 시스템을 제공합니다.
      초기 시스템 초기화(예: 위치를 찾는 데 필요한 모듈 로딩)
      그리고 "실제" 루트 파일 시스템을 마운트합니다.

      .. 메모::

         ``meta/recipes-core/images/core-image-minimal-initramfs.bb`` 파일을 참조하세요.
         소스 디렉터리에 있는 레시피
         예시로 `Initramfs` 레시피를 살펴보겠습니다. 이 샘플 레시피를 선택하려면
         Initramfs 이미지를 제공하도록 빌드된 것을 사용하려면 INITRAMFS_IMAGE를 설정하십시오.
         "core-image-minimal-initramfs"로 이동합니다.

      더 자세한 정보는 다음을 참조하시면 찾을 수 있습니다.
      ``meta-poky/conf/templates/default/local.conf.sample.extended``
      소스 디렉터리의 구성 파일인 :ref:`ref-classes-image`
      클래스와 :ref:`ref-classes-kernel` 클래스를 참조하여 사용 방법을 확인하세요.
      `INITRAMFS_IMAGE` 변수.

      `INITRAMFS_IMAGE`가 비어있는 경우(기본값)에는 아무것도 없습니다.
      `Initramfs` 이미지가 빌드되었습니다.

      더 자세한 정보를 원하시면 다음을 참조하세요.
      `INITRAMFS_IMAGE_BUNDLE`
      생성된 이미지를 내부에 묶을 수 있도록 하는 변수입니다.
      커널 이미지. 또한, Initramfs 생성에 대한 정보는 다음을 참조하십시오.
      이미지에 대한 자세한 내용은 ":ref:`dev-manual/building:building an initial ram filesystem (Initramfs) image`" 섹션을 참조하십시오.
      Yocto 프로젝트 개발 작업 매뉴얼에 있습니다.

### `INITRAMFS_IMAGE_BUNDLE`

      지정된 이미지 레시피를 사용할지 여부를 제어합니다.
      `INITRAMFS_IMAGE`는 다음을 통해 실행됩니다.
      추가 패스
      (:ref:`ref-tasks-bundle_initramfs`) 동안
      커널 컴파일은 다음을 포함하는 단일 바이너리를 빌드하기 위한 것입니다.
      커널 이미지와 초기 RAM 파일 시스템(Initramfs) 모두
      이미지. 이것은 다음을 활용합니다.
      `CONFIG_INITRAMFS_SOURCE` 커널
      특징.

      .. 메모::

         Initramfs를 커널과 함께 묶으면 코드가 혼합됩니다.
         `Initramfs`는 GPLv2 라이선스가 적용된 Linux 커널 바이너리를 사용합니다. 따라서 GPLv2만 해당됩니다.
         호환 소프트웨어는 번들로 제공되는 `Initramfs`의 일부일 수 있습니다.

      .. 메모::

         Initramfs를 번들링하기 위해 추가 컴파일 단계를 사용하면 다음을 방지할 수 있습니다.
         커널 레시피와 Initramfs 간의 순환 종속성
         레시피에 Initramfs를 포함해야 할까요? 그래야 할까요?
         이 경우, `Initramfs` 레시피는 커널에 의존합니다.
         커널 모듈이며, 커널은 Initramfs 레시피에 의존합니다.
         Initramfs가 커널 이미지에 포함되어 있기 때문입니다.

      결합된 바이너리 파일은 ``tmp/deploy`` 디렉터리에 저장됩니다.
      이는 빌드 디렉터리의 일부입니다.

      설정 파일에서 변수를 "1"로 설정하면 다음과 같은 현상이 발생합니다.
      OpenEmbedded 빌드 시스템을 사용하여 커널 이미지를 생성합니다.
      `INITRAMFS_IMAGE`에 지정된 `Initramfs`는 다음 안에 포함되어 있습니다::

         INITRAMFS_IMAGE_BUNDLE = "1"

      기본적으로 `:ref:`ref-classes-kernel` 클래스는 이 변수를 다음과 같이 설정합니다.
      다음과 같은 빈 문자열::

         INITRAMFS_IMAGE_BUNDLE ?= ""

      .. 메모::

         ``INITRAMFS_IMAGE_BUNDLE` 변수를 설정해야 합니다.
         설정 파일입니다. 레시피 파일에서는 변수를 설정할 수 없습니다.

      보세요
      :yocto_git:`local.conf.sample.extended </poky/tree/meta-poky/conf/templates/default/local.conf.sample.extended>`
      추가 정보는 파일을 참조하십시오. 또한 생성 방법에 대한 정보는 해당 파일을 참조하십시오.
      Initramfs에 대한 자세한 내용은 ":ref:dev-manual/building:building an initial ram filesystem (Initramfs) image" 섹션을 참조하십시오.
      Yocto 프로젝트 개발 작업 매뉴얼에 있습니다.

### `INITRAMFS_IMAGE_NAME`

      이 값은 `IMAGE_LINK_NAME`과 동기화되어야 하지만,
      `IMAGE_BASENAME` 대신 `INITRAMFS_IMAGE`를 사용하십시오. 기본값은 다음과 같습니다.
      다음과 같이 설정됩니다:

         INITRAMFS_IMAGE_NAME ?= "${@['${INITRAMFS_IMAGE}${IMAGE_MACHINE_SUFFIX}', ''][d.getVar('INITRAMFS_IMAGE') == '']}"

      즉, `INITRAMFS_IMAGE`가 설정된 경우, 값은
      `INITRAMFS_IMAGE_NAME`은 다음을 기반으로 설정됩니다.
      `INITRAMFS_IMAGE` 및 `IMAGE_MACHINE_SUFFIX`.


### `INITRAMFS_LINK_NAME`

      초기 RAM 파일 시스템 이미지의 링크 이름입니다. 이 변수는 다음과 같습니다.
      ``meta/classes-recipe/kernel-artifact-names.bbclass`` 파일에 다음과 같이 설정됩니다.
      다음이 따릅니다::

         INITRAMFS_LINK_NAME ?= "initramfs-${KERNEL_ARTIFACT_LINK_NAME}"

      가치
      ``KERNEL_ARTIFACT_LINK_NAME`` 변수는 동일한 위치에 설정됩니다.
      해당 파일에는 다음과 같은 값이 있습니다.

         KERNEL_ARTIFACT_LINK_NAME ?= "${MACHINE}"

      자세한 내용은 `MACHINE` 변수를 참조하십시오.
      정보.

### `INITRAMFS_MAXSIZE`

      Initramfs 이미지의 최대 허용 크기를 킬로바이트(KB) 단위로 정의합니다.
      Initramfs 이미지 크기가 이 값을 초과하면 빌드가 실패합니다.

      Initramfs 이미지 크기는 여러 계산 단계를 거친 후에 결정됩니다.
      `INITRAMFS_MAXSIZE`와 비교됩니다.
      이 단계는 `IMAGE_ROOTFS_MAXSIZE`에 사용되는 단계와 동일합니다.
      해당 항목에 자세히 설명되어 있습니다.

      따라서 `INITRAMFS_MAXSIZE`는 계산 결과와 비교됩니다.
      또한 최종 이미지 유형(예: 압축)과는 무관합니다.
      `INITRAMFS_MAXSIZE`의 기본값은 다음과 같이 설정됩니다.
      :oe_git:`meta/conf/bitbake.conf </openembedded-core/tree/meta/conf/bitbake.conf>`.

### `INITRAMFS_MULTICONFIG`

      멀티구성 종속성을 생성하여 사용할 멀티구성을 정의합니다.
      :ref:`ref-classes-kernel` 클래스.

      이를 통해 커널은 다음에서 오는 `INITRAMFS_IMAGE`를 번들로 묶을 수 있습니다.
      별도의 멀티구성으로, 이는 `INITRAMFS_DEPLOY_DIR_IMAGE`와 함께 사용하기 위한 것입니다.

      별도의 이미지에서 `Initramfs` 이미지를 번들링하는 방법에 대한 자세한 내용은 다음을 참조하십시오.
      멀티 구성에 대한 자세한 내용은 ":ref:`dev-manual/building:별도의 멀티 구성에서 Initramfs 이미지 번들링`"을 참조하십시오.
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `INITRAMFS_NAME`

      초기 RAM 파일 시스템 이미지의 기본 이름입니다. 이 변수는 다음과 같습니다.
      ``meta/classes-recipe/kernel-artifact-names.bbclass`` 파일에 다음과 같이 설정됩니다.
      다음이 따릅니다::

         INITRAMFS_NAME ?= "initramfs-${KERNEL_ARTIFACT_NAME}"

      자세한 내용은 `KERNEL_ARTIFACT_NAME`을 참조하십시오.

### `INITRD`

      연결하여 사용할 파일 시스템 이미지 목록을 나타냅니다.
      초기 RAM 디스크(``initrd``).

      ``INITRD` 변수는 선택적으로 사용되는 변수입니다.
      :ref:`ref-classes-image-live` 클래스.

### `INITRD_IMAGE`

      "라이브" 부팅 가능 이미지를 빌드할 때 (즉,
      `IMAGE_FSTYPES`에는 "live"가 포함되어 있습니다.
      `INITRD_IMAGE`는 빌드해야 할 이미지 레시피를 지정합니다.
      초기 RAM 디스크 이미지를 제공합니다. 기본값은 다음과 같습니다.
      "core-image-minimal-initramfs".

      자세한 내용은 :ref:`ref-classes-image-live` 클래스를 참조하세요.

### `INITSCRIPT_NAME`

      설치된 초기화 스크립트의 파일 이름
      ``${sysconfdir}/init.d``.

      이 변수는 :ref:`ref-classes-update-rc.d`를 사용할 때 레시피에서 사용됩니다.
      해당 변수는 필수 항목입니다.

### `INITSCRIPT_PACKAGES`

      initscripts가 포함된 패키지 목록입니다. 패키지가 여러 개인 경우
      지정된 경우, 다른 항목에 패키지 이름을 추가해야 합니다.
      ``INITSCRIPT_*``를 재정의합니다.

      이 변수는 :ref:`ref-classes-update-rc.d`를 사용할 때 레시피에서 사용됩니다.
      해당 변수는 선택 사항이며 기본값은 `PN`입니다.
      변하기 쉬운.

### `INITSCRIPT_PARAMS`

      `update-rc.d`에 전달할 옵션을 지정합니다. 다음은 예시입니다.

         INITSCRIPT_PARAMS = "start 99 5 2 . stop 20 0 1 6 ."

      이 예시에서 스크립트의 실행 레벨은 99이며, 스크립트를 시작합니다.
      initlevels 2와 5에서는 스크립트가 실행되고, 레벨 0, 1, 6에서는 스크립트 실행이 중지됩니다.

      해당 변수의 기본값은 "defaults"이며, 이는 다음과 같이 설정됩니다.
      :ref:`ref-classes-update-rc.d` 클래스.

      ``INITSCRIPT_PARAMS`의 값은 그대로 전달됩니다.
      `update-rc.d` 명령어를 사용하세요. 유효한 매개변수에 대한 자세한 내용은 다음을 참조하세요.
      매뉴얼 페이지를 참조하십시오: :manpage:`update-rc.d <update-rc.d(8)>`.

### `INSANE_SKIP`

      특정 패키지에 대해 건너뛸 QA 검사를 지정합니다.
      레시피. 예를 들어, 심볼릭 링크 ``.so``에 대한 검사를 건너뛰려면
      레시피의 메인 패키지에 있는 파일에 다음 내용을 추가하세요.
      레시피입니다. 패키지 이름 재정의를 사용해야 하며, 이 예시에서는 다음과 같습니다.
      ``${PN}``입니다::

         INSANE_SKIP:${PN} += "dev-so"

      자세한 내용은 ":ref:`ref-classes-insane`" 섹션을 참조하세요.
      이 변수를 사용하여 지정할 수 있는 유효한 QA 검사 목록입니다.

### `INSTALL_TIMEZONE_FILE`

      기본적으로 `tzdata` 레시피는 `/etc/timezone` 파일을 패키징합니다.
      `INSTALL_TIMEZONE_FILE` 변수를 "0"으로 설정하십시오.
      이 동작을 비활성화하는 구성 수준입니다.

### `IPK_FEED_URIS`

      IPK 백엔드가 사용 중이고 패키지 관리가 활성화된 경우
      대상에서 이 변수를 사용하여 ``opkg``를 설정할 수 있습니다.
      지정된 서버의 패키지 피드를 가리키도록 대상 이미지를 설정합니다.
      피드가 설정되면 설치 또는 업그레이드를 수행할 수 있습니다.
      실행 시 패키지 관리자를 사용합니다.

### `KARCH`

      커널을 어셈블할 때 사용되는 커널 아키텍처를 정의합니다.
      구성. 이번 릴리스에서 지원되는 아키텍처는 다음과 같습니다.

      - 파워PC
      - i386
      - x86_64
      - 팔
      - 케무
      - 밉스

      :ref:`kernel-dev/advanced:bsp 설명`에서 `KARCH` 변수를 정의합니다.

### `KBRANCH`

      빌드 프로세스에서 명시적으로 식별하기 위해 사용되는 정규 표현식
      검증, 패치 및 구성이 진행되는 커널 브랜치
      빌드. 정확한 커널 브랜치를 사용하려면 이 변수를 설정해야 합니다.
      원하는 것이 빌드 프로세스에서 사용되고 있습니다.

      이 변수의 값은 커널의 레시피 파일과
      커널의 추가 파일. 예를 들어, 다음과 같은 경우
      ``linux-yocto_4.12`` 커널의 커널 레시피 파일은 다음과 같습니다.
      ``meta/recipes-kernel/linux/linux-yocto_4.12.bb`` 파일. `KBRANCH`
      해당 커널 레시피 파일에서는 다음과 같이 설정되어 있습니다.

         KBRANCH ?= "표준/기본"

      이 변수는 커널의 추가 파일에서도 식별을 위해 사용됩니다.
      특정 머신 또는 대상에 특화된 커널 브랜치
      하드웨어. 이전 커널 예시를 계속해서 살펴보면, 커널의
      추가 파일은 다음 위치에 있습니다.
      특정 머신에 대한 BSP 레이어입니다. 예를 들어, 추가 파일은 다음과 같습니다.
      Beaglebone 및 32비트 및 64비트 IA의 일반 버전
      machines(``meta-yocto-bsp``)의 이름은 다음과 같습니다.
      ``meta-yocto-bsp/recipes-kernel/linux/linux-yocto_6.1.bbappend``.
      다음은 해당 추가 파일에서 가져온 관련 문장입니다.

         KBRANCH:genericx86 = "v6.1/표준/기본"
         KBRANCH:genericx86-64 = "v6.1/표준/베이스"
         KBRANCH:beaglebone-yocto = "v6.1/standard/beaglebone"

      `KBRANCH` 문장
      지원되는 각 항목에 대해 빌드할 때 사용할 커널 브랜치를 식별합니다.
      비에스피.

### `KBUILD_DEFCONFIG`

      :ref:`ref-classes-kernel-yocto`와 함께 사용할 경우
      클래스는 사용을 위한 "트리 내" 커널 구성 파일을 지정합니다.
      커널 빌드 중에.

      일반적으로 `defconfig`를 사용하여 커널을 구성할 때
      빌드할 때는 파일을 레이어에 배치하는 방식과 동일하게 하면 됩니다.
      패치 파일과 구성 조각 파일(예:
      "트리 외부"입니다. 하지만 `defconfig` 파일을 사용하려면 다음과 같은 방법이 있습니다.
      커널 트리의 일부(즉, "트리 내")이므로 다음을 사용할 수 있습니다.
      `KBUILD_DEFCONFIG` 변수가 가리키도록 지정합니다.
      ``defconfig`` 파일.

      해당 변수를 사용하려면 커널 레시피의 추가 파일에 설정하십시오.
      다음 형식을 사용하여::

         KBUILD_DEFCONFIG:<machine> ?= "defconfig_file"

      다음은 "raspberrypi2" `MACHINE` 빌드에서 사용되는 예시입니다.
      "bcm2709_defconfig"라는 이름의 ``defconfig`` 파일::

         KBUILD_DEFCONFIG:raspberrypi2 = "bcm2709_defconfig"

      대안으로, 추가 파일 내에 다음 내용을 사용할 수 있습니다.

         KBUILD_DEFCONFIG:pn-linux-yocto ?= "defconfig_file"

      더 많은 정보를 원하시면
      `KBUILD_DEFCONFIG` 변수 사용 방법에 대한 정보는 다음을 참조하십시오.
      ":ref:`kernel-dev/common:'트리 내' \`\`defconfig\`\` 파일 사용"
      Yocto Project Linux 커널 개발 매뉴얼의 해당 섹션입니다.

### `KCONF_AUDIT_LEVEL`

      `ref-classes-kernel-yocto` 클래스를 상속받을 때와
      `KMETA_AUDIT` 변수가 비어 있지 않은 문자열로 설정되었습니다.
      `KCONF_AUDIT_LEVEL` 변수는 커널을 보고할지 여부를 지정합니다.
      사용자가 지정한 값과 다른 구성 값.
      값은 양의 정수입니다(기본값: 1).

      - 0: 보고가 이루어지지 않습니다.

      - 1: 문제를 경고로 보고하고, 오류가 발생하면 오류를 발생시킵니다.
         `KMETA_AUDIT_WERROR`가 설정되었습니다.

      - 2: :ref:`ref-tasks-kernel_configme`가 생성에 실패한 경우
         `.config` 파일의 내용을 출력하고, `merge_config_build.log` 파일의 내용을 출력합니다.
         오류가 포함된 파일의 경로만 제공하는 대신, 해당 파일 자체를 제공해야 합니다.
         그 파일.

      자세한 내용은 :ref:`ref-classes-kernel-yocto` 클래스와 다음을 참조하십시오.
      :yocto_git:`symbol_why.py </yocto-kernel-tools/tree/tools/symbol_why.py>`
      :yocto_git:`yocto-kernel-tools </yocto-kernel-tools>`에 있는 스크립트입니다.

### `KCONF_BSP_AUDIT_LEVEL`

      `ref-classes-kernel-yocto` 클래스를 상속받을 때와
      `KMETA_AUDIT` 변수가 비어 있지 않은 문자열로 설정되었습니다.
      `KCONF_BSP_AUDIT_LEVEL` 변수를 설정하여 보고할 수 있습니다.

      #. 최종 버전에 포함되지 않은 사용자 지정 커널 구성
          커널 구성.

      #. 서로 다른 값을 가진 여러 입력 파일에 정의된 구성.

      이 값은 양의 정수입니다(기본값: 0).

      - 0: 보고가 이루어지지 않습니다.

      - 1: 포함되지 않은 구성 옵션 보고
         최종 구성이 완료되었으며 현재 설정에 국한되지 않습니다.
         (``ARCH``) 아키텍처가 사용 중입니다.

      - 2: 포함되지 않은 구성 옵션 보고
         최종 구성이 완료되었으며 현재 상태로 엄격하게 제한됩니다.
         (``ARCH``) 아키텍처가 사용 중입니다.

      - 3: 이 변수가 2일 때 발견된 문제점을 보고하고, 또한
         여러 입력 파일에 정의된 보고서 구성 옵션
         서로 다른 값들.

      값이 1, 2, 3인 경우 `KMETA_AUDIT_WERROR` 오류가 발생합니다.
      설정되었습니다.

      자세한 내용은 :ref:`ref-classes-kernel-yocto` 클래스와 다음을 참조하십시오.
      :yocto_git:`symbol_why.py </yocto-kernel-tools/tree/tools/symbol_why.py>`
      :yocto_git:`yocto-kernel-tools </yocto-kernel-tools>`에 있는 스크립트입니다.

### `KCONFIG_MODE`

      :ref:`ref-classes-kernel-yocto`와 함께 사용할 경우
      클래스는 옵션에 사용할 커널 구성 값을 지정합니다.
      제공된 ``defconfig`` 파일에 지정되지 않았습니다. 유효한 옵션은 다음과 같습니다.

         KCONFIG_MODE = "alldefconfig"
         KCONFIG_MODE = "allnoconfig"

      `alldefconfig` 모드에서는 명시적으로 지정되지 않은 옵션은 다음과 같습니다.
      Kconfig 기본값이 할당되었습니다. ``allnoconfig`` 모드에서는
      명시적으로 지정되지 않은 옵션은 커널에서 비활성화됩니다.
      설정.

      `KCONFIG_MODE`가 설정되지 않은 경우 ``defconfig`` 파일을 참조하십시오.
      ``allnoconfig`` 모드로 처리됩니다.

      `allnoconfig` 모드와 호환되는 `defconfig` 파일은 다음과 같습니다.
      정상 작동하는 리눅스 커널의 ``.config`` 파일을 복사하여 생성되었습니다.
      빌드한 파일을 ``defconfig``로 이름을 바꾸고 Linux 폴더에 넣습니다.
      메타 레이어를 통해 커널 ``${WORKDIR}``을 실행합니다. `KCONFIG_MODE`는 다음과 같습니다.
      명시적으로 설정할 필요가 없습니다.

      `alldefconfig` 모드와 호환되는 `defconfig` 파일은 다음과 같습니다.
      생성됨
      :ref:`ref-tasks-savedefconfig`
      해당 작업을 Linux 커널의 ``${WORKDIR}``에 배치합니다.
      메타 레이어. `KCONFIG_MODE`::를 명시적으로 설정하세요.

         KCONFIG_MODE = "alldefconfig"

### `KERNEL_ALT_IMAGETYPE`

      생성할 대체 커널 이미지 유형을 지정합니다.
      `KERNEL_IMAGETYPE`를 사용하여 지정된 커널 이미지 유형 및
      `KERNEL_IMAGETYPES` 변수.

### `KERNEL_ARTIFACT_NAME`

      빌드 결과물의 이름을 지정합니다. 이 이름은 변경할 수 있습니다.
      아티팩트의 이름을 변경하려면 ``KERNEL_ARTIFACT_NAME`을 수정하십시오.
      변하기 쉬운.

      `KERNEL_ARTIFACT_NAME`의 값은 다음과 같이 설정됩니다.
      ``meta/classes-recipe/kernel-artifact-names.bbclass`` 파일에는 다음 내용이 있습니다.
      다음 기본값::

         KERNEL_ARTIFACT_NAME ?= "${PKGE}-${PKGV}-${PKGR}${IMAGE_MACHINE_SUFFIX}${IMAGE_VERSION_SUFFIX}"

      `PKGE`, `PKGV`, `PKGR`, `IMAGE_MACHINE_SUFFIX`를 참조하십시오.
      추가 정보는 `IMAGE_VERSION_SUFFIX` 변수를 참조하십시오.

### `KERNEL_CLASSES`

      커널 이미지 유형을 정의하는 클래스 목록
      :ref:`ref-classes-kernel` 클래스는 상속해야 합니다. 일반적으로
      확장된 이미지 유형을 활성화하려면 이 변수를 추가하세요.
      사용자 지정 커널 이미지 유형을 등록할 수 있습니다.
      :ref:`ref-classes-kernel` 클래스가 이 변수를 사용합니다.

### `KERNEL_CONSOLE`

     ``KERNEL_CONSOLE` 변수는 `console`의 값을 저장합니다.
     커널 명령줄의 매개변수이며 다음과 같은 곳에서 사용할 수 있습니다.
     :ref:`Wic 이미지 <dev-manual/wic:creating에 대한 ``wks`` 설명 파일
     wic>`를 사용하여 분할된 이미지.

     이 변수의 기본값은 첫 번째 콘솔에서 추출됩니다.
     장치 및 설정은 `SERIAL_CONSOLES`의 터미널에서 확인하십시오. 아무것도 찾을 수 없는 경우
     `SERIAL_CONSOLES`의 기본값은 ``ttyS0,115200``으로 설정되어 있습니다.

     자세한 내용은 '커널 명령줄 문서'를 참조하십시오.
     <https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html>`__.

### `KERNEL_DANGLING_FEATURES_WARN_ONLY`

      일부 커널 구성 조각이 누락된 경우
      레이어 또는 BSP에 의해 지정된 `KERNEL_FEATURES`
      커널 빌드 및 구성 중 오류가 발생하여 중단됩니다.

      설정을 통해 이러한 오류를 경고로 바꿀 수 있습니다.
      `conf/local.conf`에 다음 내용이 있습니다.

         KERNEL_DANGLING_FEATURES_WARN_ONLY = "1"

      실행 중에 문제가 발생할 수 있다는 경고 메시지가 계속 표시됩니다.
      하지만 적어도 커널 구성과 빌드 프로세스는 진행될 것입니다.
      계속 진행하도록 허용됩니다.

### `KERNEL_DEBUG_TIMESTAMPS`

      "1"로 설정하면 빌드 중에 타임스탬프 기능이 활성화됩니다.
      커널입니다. 재현성을 위해 기본값은 "0"으로 설정되어 이 기능을 비활성화합니다.
      이유.

### `KERNEL_DEPLOY_DEPEND`

      이미지 레시피의 종속성을 제어하는 ​​수단을 제공합니다.
      커널에서 사용됩니다. 기본값은 "virtual/kernel:do_deploy"입니다.
      하지만 작은 initramfs 이미지나 기타 이미지의 경우에는 그렇지 않습니다.
      커널이 필요한 경우 이미지 레시피에서 ""로 설정할 수 있습니다.

### `KERNEL_DEVICETREE`

      생성된 Linux 커널 장치 트리의 이름을 지정합니다(예:
      ``.dtb``) 파일.

      .. 메모::

         장치의 전체 경로를 지정하는 기존 방식이 지원됩니다.
         트리 구조입니다. 하지만 ``.dtb`` 파일만 제공해 주시면 더욱 좋습니다.

      이 변수를 사용하려면 :ref:`ref-classes-kernel-devicetree`를 사용해야 합니다.
      클래스는 상속되어야 합니다.

### `KERNEL_DEVICETREE_BUNDLE`

      이 변수를 "1"로 설정하면 Linux 커널을 번들에 포함할 수 있습니다.
      그리고 장치 트리 바이너리를 하나의 파일로 함께 제공합니다.

      이 기능은 현재 "arm"(32비트) 아키텍처에서만 지원됩니다.
      건축학.

      이 변수는 기본적으로 "0"으로 설정됩니다.
      :ref:`ref-classes-kernel-devicetree` 클래스.

### `KERNEL_DTB_LINK_NAME`

      커널 장치 트리 바이너리(DTB)의 링크 이름입니다. 이 변수는...
      ``meta/classes-recipe/kernel-artifact-names.bbclass`` 파일에 다음과 같이 설정되어 있습니다.
      다음이 따릅니다::

         KERNEL_DTB_LINK_NAME ?= "${KERNEL_ARTIFACT_LINK_NAME}"

      그만큼
      ``KERNEL_ARTIFACT_LINK_NAME`` 변수의 값은 다음과 같이 설정됩니다.
      같은 파일에는 다음과 같은 값이 있습니다.

         KERNEL_ARTIFACT_LINK_NAME ?= "${MACHINE}"

      자세한 내용은 `MACHINE` 변수를 참조하십시오.
      정보.

### `KERNEL_DTB_NAME`

      커널 장치 트리 바이너리(DTB)의 기본 이름입니다. 이 변수는...
      ``meta/classes-recipe/kernel-artifact-names.bbclass`` 파일에 다음과 같이 설정되어 있습니다.
      다음이 따릅니다::

         KERNEL_DTB_NAME ?= "${KERNEL_ARTIFACT_NAME}"

      자세한 내용은 `KERNEL_ARTIFACT_NAME`을 참조하십시오.

### `KERNEL_DTBDEST`

      이 변수는 :ref:`ref-classes-kernel-devicetree`에서 사용됩니다.
      이 클래스는 DTB의 설치 디렉토리를 변경할 수 있도록 합니다.
      (장치 트리 바이너리) 파일.

      기본값은 "${KERNEL_IMAGEDEST}"로 설정되어 있습니다.
      :ref:`ref-classes-kernel` 클래스.

### `KERNEL_DTBVENDORED`

      이 변수는 :ref:`ref-classes-kernel-devicetree`에서 사용됩니다.
      DTB 설치 시 벤더 하위 디렉터리를 무시할 수 있도록 합니다.
      (장치 트리 바이너리) 파일은 "false"로 설정된 경우에 생성됩니다.

      벤더 하위 디렉터리를 유지하려면 이 변수를 "true"로 설정하십시오.

      :ref:`ref-classes-kernel` 클래스에 의해 기본값이 "false"로 설정되어 있습니다.

### `KERNEL_DTC_FLAGS`

      Linux 커널 빌드에 전달되는 `dtc` 플래그를 지정합니다.
      장치 트리를 생성할 때 시스템 (``DTC_FLAGS`` 환경 변수를 통해)
      변하기 쉬운).

      이 변수를 사용하려면 :ref:`ref-classes-kernel-devicetree`를 사용해야 합니다.
      클래스는 상속되어야 합니다.

### `KERNEL_EXTRA_ARGS`

      OpenEmbedded에 대한 추가 `make` 명령줄 인수를 지정합니다.
      커널 컴파일 시 빌드 시스템이 다음 단계로 넘어갑니다.

### `KERNEL_FEATURES`

      추가 커널 메타데이터가 포함되어 있습니다. OpenEmbedded 빌드에서
      시스템의 기본 보드 지원 패키지(BSP)
      `메타데이터`는 다음을 통해 제공됩니다.
      `KMACHINE` 및 `KBRANCH`
      변수. 내부에서 `KERNEL_FEATURES` 변수를 사용할 수 있습니다.
      커널 레시피 또는 커널 추가 파일을 사용하여 메타데이터를 추가로 추가합니다.
      모든 BSP 또는 특정 BSP.

      이 변수를 통해 추가하는 메타데이터에는 구성 조각이 포함됩니다.
      그리고 일반적으로 패치를 포함한 기능 설명이 있습니다.
      설정 조각입니다. 일반적으로 `KERNEL_FEATURES`를 재정의합니다.
      특정 기기에 대한 변수입니다. 이런 방식으로 제공할 수 있습니다.
      검증되었지만 선택 사항인 커널 구성 및 기능 세트입니다.

      예를 들어, ``linux-yocto-rt_4.12``의 다음 예제를 참조하십시오.
      커널 레시피는 모든 BSP에 "netfilter" 및 "taskstats" 기능을 추가합니다.
      또한 모든 QEMU 머신에 대한 "virtio" 구성도 포함됩니다. 마지막 두 가지
      명령은 대상 머신 유형에 특정 구성을 추가합니다.

         KERNEL_EXTRA_FEATURES ?= "features/netfilter/netfilter.scc features/taskstats/taskstats.scc"
         KERNEL_FEATURES:append = " ${KERNEL_EXTRA_FEATURES}"
         KERNEL_FEATURES:append:qemuall = " cfg/virtio.scc"
         KERNEL_FEATURES:append:qemux86 = " cfg/sound.scc cfg/paravirt_kvm.scc"
         KERNEL_FEATURES:append:qemux86-64 = " cfg/sound.scc"

### `KERNEL_FIT_LINK_NAME`

      커널 평면화 이미지 트리(FIT) 이미지의 링크 이름입니다.
      해당 변수는 ``meta/classes-recipe/kernel-artifact-names.bbclass``에 설정되어 있습니다.
      다음과 같이 파일을 작성하십시오::

         KERNEL_FIT_LINK_NAME ?= "${KERNEL_ARTIFACT_LINK_NAME}"

      가치
      ``KERNEL_ARTIFACT_LINK_NAME`` 변수는 동일한 위치에 설정됩니다.
      해당 파일에는 다음과 같은 값이 있습니다.

         KERNEL_ARTIFACT_LINK_NAME ?= "${MACHINE}"

      자세한 내용은 `MACHINE` 변수를 참조하십시오.
      정보.

### `KERNEL_FIT_NAME`

      커널 평면화 이미지 트리(FIT) 이미지의 기본 이름입니다.
      해당 변수는 ``meta/classes-recipe/kernel-artifact-names.bbclass``에 설정되어 있습니다.
      다음과 같이 파일을 작성하십시오::

         KERNEL_FIT_NAME ?= "${KERNEL_ARTIFACT_NAME}"

      자세한 내용은 `KERNEL_ARTIFACT_NAME`을 참조하십시오.

### `KERNEL_IMAGE_LINK_NAME`

      커널 이미지의 링크 이름입니다. 이 변수는 다음에서 설정됩니다.
      ``meta/classes-recipe/kernel-artifact-names.bbclass`` 파일은 다음과 같습니다.

         KERNEL_IMAGE_LINK_NAME ?= "${KERNEL_ARTIFACT_LINK_NAME}"

      가치
      동일한 위치에 설정된 ``KERNEL_ARTIFACT_LINK_NAME`` 변수
      해당 파일에는 다음과 같은 값이 있습니다.

         KERNEL_ARTIFACT_LINK_NAME ?= "${MACHINE}"

      자세한 내용은 `MACHINE` 변수를 참조하십시오.
      정보.

### `KERNEL_IMAGE_MAXSIZE`

      커널 이미지 파일의 최대 크기를 킬로바이트 단위로 지정합니다.
      `KERNEL_IMAGE_MAXSIZE`가 설정되면 커널 이미지 파일의 크기는 다음과 같습니다.
      설정된 값과 비교하여 확인됨
      :ref:`ref-tasks-sizecheck` 작업. 이 작업은 다음과 같은 경우 실패합니다.
      커널 이미지 파일 크기가 설정값보다 큽니다.

      `KERNEL_IMAGE_MAXSIZE`는 대상 장치에 유용합니다.
      커널 이미지를 저장해야 하는 공간이 제한되어 있습니다.

      기본적으로 이 변수는 설정되어 있지 않으므로 크기는 다음과 같습니다.
      커널 이미지는 검사되지 않습니다.

### `KERNEL_IMAGE_NAME`

      커널 이미지의 기본 이름입니다. 이 변수는 다음에서 설정됩니다.
      ``meta/classes-recipe/kernel-artifact-names.bbclass`` 파일은 다음과 같습니다.

         KERNEL_IMAGE_NAME ?= "${KERNEL_ARTIFACT_NAME}"

      자세한 내용은 `KERNEL_ARTIFACT_NAME`을 참조하십시오.

### `KERNEL_IMAGETYPE`

      기기용으로 빌드할 커널 유형으로, 일반적으로 기기에서 설정됩니다.
      구성 파일과 기본값은 "zImage"입니다. 이 변수는 사용됩니다.
      커널을 빌드할 때 `make` 명령어에 타겟으로 전달됩니다.
      짓다.

      추가 커널 이미지 유형을 빌드하려면 `KERNEL_IMAGETYPES`를 사용하십시오.

### `KERNEL_IMAGETYPES`

      이 목록에는 장치용으로 빌드할 추가 커널 이미지 유형이 나열됩니다.
      `KERNEL_IMAGETYPE`에 지정된 이미지 유형입니다. 일반적으로 설정됩니다.
      기기 구성 파일.

### `KERNEL_LOCALVERSION`

      이 변수를 사용하면 버전에 문자열을 추가할 수 있습니다.
      커널 이미지의 구성 요소입니다. 이는 ``CONFIG_LOCALVERSION``에 해당합니다.
      커널 구성 매개변수.

      이 변수는 커널 레시피를 사용할 때만 유용합니다.
      :ref:`ref-classes-kernel` 클래스를 상속받는 것과 그렇지 않은 것
      이미 로컬 버전을 설정했습니다. 따라서 이 변수를 설정하는 것은 의미가 없습니다.
      ``linux-yocto`` 커널에 미치는 영향.

### `KERNEL_MODULE_AUTOLOAD`

      부팅 시 자동 로드되어야 하는 커널 모듈 목록을 표시합니다.

      .. 메모::

         이 변수는 더 이상 사용되지 않는 ``module_autoload`를 대체합니다.
         변하기 쉬운.

      `KERNEL_MODULE_AUTOLOAD` 변수는 해당 변수가 필요한 모든 곳에서 사용할 수 있습니다.
      커널 레시피 또는 나무에서 분리된 커널을 통해 식별할 수 있습니다.
      모듈 레시피(예: 머신 구성 파일, 배포판)
      구성 파일, 레시피 추가 파일 또는 레시피
      그 자체).

      다음과 같이 명시하십시오::

         KERNEL_MODULE_AUTOLOAD += "module_name1 module_name2 module_name3"

      ``KERNEL_MODULE_AUTOLOAD`를 포함시키면 OpenEmbedded 빌드가 실행됩니다.
      ``/etc/modules-load.d/modname.conf`` 파일을 채우는 시스템
      부팅 시 자동으로 로드될 모듈 목록입니다. 모듈은 다음과 같이 표시됩니다.
      파일의 각 줄에 하나씩 입력하세요. 다음은 가장 일반적인 사용 예입니다.
      사례::

         KERNEL_MODULE_AUTOLOAD += "module_name"

      `modname.conf` 파일에 내용을 채우는 방법에 대한 정보는 다음을 참조하십시오.
      `modprobe.d` 구문 줄에 대해서는 `KERNEL_MODULE_PROBECONF` 변수를 참조하십시오.

### `KERNEL_MODULE_PROBECONF`

      OpenEmbedded 빌드 시스템에서 지원하는 모듈 목록을 제공합니다.
      ``module_conf_``\ modname 값이 지정될 것으로 예상합니다.
      각 모듈에 대한 구성입니다. 자세한 내용은 다음을 참조하세요.
      해당 모듈 구성을 제공하려면 다음을 참조하십시오.
      `module_conf_* <module_conf>` 변수.

### `KERNEL_PACKAGE_NAME`

      커널 패키지의 기본 이름을 지정합니다(예: "kernel").
      "kernel-modules", "kernel-image"와 같은 커널 패키지에서
      "kernel-dbg".

      이 변수의 기본값은 "kernel"로 설정되어 있습니다.
      :ref:`ref-classes-kernel` 클래스.

### `KERNEL_PATH`

      커널 소스의 위치입니다. 이 변수는 특정 값으로 설정됩니다.
      :ref:`ref-classes-module` 내의 `STAGING_KERNEL_DIR`의
      클래스입니다. 이 변수의 사용 방법에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`kernel-dev/common:트리 외부 모듈 통합`"
      Yocto Project Linux 커널 개발 매뉴얼의 해당 섹션입니다.

      빌드에 사용되는 외부 드라이버와의 호환성을 극대화하기 위해
      모듈 외에도 OpenEmbedded 빌드 시스템은 다음 모듈을 인식하고 사용합니다.
      `KERNEL_SRC` 변수는 다음과 같습니다.
      `KERNEL_PATH` 변수. 두 변수는 공통 변수입니다.
      외부 Makefile에서 커널 소스 디렉토리를 가리키는 데 사용됩니다.

### `KERNEL_SPLIT_MODULES`

      `ref-classes-kernel-module-split` 클래스를 상속할 때, 이것은
      이 변수는 커널 모듈을 별도의 패키지로 분할할지 여부를 제어합니다.
      또는 하나의 패키지로 묶여서 제공됩니다.

      일부 사용 사례의 경우, 단일 커널 모듈 패키지가 필요할 수 있습니다.
      `KERNEL_PACKAGE_NAME`은 빌드된 모든 모듈을 포함합니다.
      설치 속도를 높이려면 커널 소스를 사용하는 것이 좋습니다.

      기본적으로 이 변수는 ``1``로 설정되어 있어 패키지가 하나씩 생성됩니다.
      이 값을 다른 값으로 설정하면 단일 모듈이 생성됩니다. 다른 값으로 설정하면 하나의 모놀리식 모듈이 생성됩니다.
      커널 모듈 전체가 포함된 패키지입니다.

      .. 메모::

         `KERNEL_SPLIT_MODULES`가 0으로 설정되어 있어도 여전히 가능합니다.
         ``kernel-modules``를 추가하여 모든 커널 모듈을 한 번에 설치합니다(가정).
         `KERNEL_PACKAGE_NAME`은 ``kernel-modules``입니다. `IMAGE_INSTALL`로 이동합니다.
         작동 방식은 "kernel-modules"라는 자리 표시자 패키지가 생성되는 것입니다.
         생성되었으며 다른 모든 개별 커널 모듈 패키지에 의존합니다.

### `KERNEL_SRC`

      커널 소스의 위치입니다. 이 변수는 특정 값으로 설정됩니다.
      :ref:`ref-classes-module` 내의 `STAGING_KERNEL_DIR`의
      클래스입니다. 이 변수의 사용 방법에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`kernel-dev/common:트리 외부 모듈 통합`"
      Yocto Project Linux 커널 개발 매뉴얼의 해당 섹션입니다.

      빌드에 사용되는 외부 드라이버와의 호환성을 극대화하기 위해
      모듈 외에도 OpenEmbedded 빌드 시스템은 다음 모듈을 인식하고 사용합니다.
      `KERNEL_PATH` 변수는 동일합니다.
      `KERNEL_SRC` 변수에 대한 것입니다. 두 변수는 공통 변수입니다.
      외부 Makefile에서 커널 소스 디렉토리를 가리키는 데 사용됩니다.

### `KERNEL_STRIP`

      커널을 스트립하는 데 사용할 `strip` 명령어를 지정할 수 있습니다.
      바이너리 파일은 일반적으로 GNU binutils ``strip`` 또는 ``llvm-strip``을 사용합니다.

### `KERNEL_VERSION`

      `version.h`에서 추출한 커널 버전을 지정합니다.
      또는 커널 소스 내의 ``utsrelease.h`` 파일. 설정의 효과
      이 변수는 커널이 실행될 때까지 적용되지 않습니다.
      구성되었습니다. 따라서 이 변수를 참조하려고 하면
      구성 이전의 컨텍스트는 작동하지 않습니다.

### `KERNELDEPMODDEPEND`

      참조된 데이터가
      `PKGDATA_DIR`이 필요한지 여부.
      `KERNELDEPMODDEPEND`는 해당 데이터가 실행될지 여부를 제어하지 않습니다.
      존재한다는 사실 자체의 문제이지, 사용 여부의 문제는 아닙니다. 필요하지 않다면 사용하지 않아도 됩니다.
      데이터를 사용하고, `KERNELDEPMODDEPEND` 변수를 설정하세요.
      `Initramfs` 레시피. 데이터가 없을 때 변수를 설정합니다.
      필요한 것은 잠재적인 의존성 루프를 방지합니다.

### `KFEATURE_DESCRIPTION`

      구성 조각에 대한 간략한 설명을 제공합니다. 사용 방법은 다음과 같습니다.
      ``.scc`` 파일에 있는 이 변수는 구성을 설명합니다.
      조각 파일입니다. 다음은 `smp.scc`라는 파일에서 사용된 변수입니다.
      SMP가 활성화된 상태를 설명하려면:

          KFEATURE_DESCRIPTION을 "SMP 활성화"로 정의합니다.

### `KMACHINE`

      커널에서 인식하는 머신 이름입니다. 때때로 사용되는 머신 이름이기도 합니다.
      커널에서 사용하는 머신 이름이 일치하지 않습니다.
      OpenEmbedded 빌드 시스템. 예를 들어, 머신 이름은 다음과 같습니다.
      OpenEmbedded 빌드 시스템은 이를 ``core2-32-intel-common``으로 인식합니다.
      리눅스 Yocto 커널에서는 다른 이름으로 불립니다. 커널
      해당 기기를 "intel-core2-32"로 인식합니다. 이러한 경우,
      ``KMACHINE` 변수는 커널 머신 이름을 다음 변수에 매핑합니다.
      OpenEmbedded 빌드 시스템 머신 이름입니다.

      Yocto Linux에서는 서로 다른 이름 간의 이러한 매핑이 발생합니다.
      커널의 ``meta`` 브랜치입니다. 예를 들어 다음을 살펴보세요.
      ``common/recipes-kernel/linux/linux-yocto_3.19.bbappend`` 파일::

         LINUX_VERSION:core2-32-intel-common = "3.19.0"
         호환 가능 머신:core2-32-intel-common = "${MACHINE}"
         SRCREV_meta:core2-32-intel-common = "8897ef68b30e7426bc1d39895e71fb155d694974"
         SRCREV_machine:core2-32-intel-common = "43b9eced9ba8a57add36af07736344dcc383f711"
         KMACHINE:core2-32-intel-common = "intel-core2-32"
         KBRANCH:core2-32-intel-common = "standard/base"
         KERNEL_FEATURES:append:core2-32-intel-common = " ${KERNEL_FEATURES_INTEL_COMMON}"

      `KMACHINE` 문은 다음과 같습니다.
      커널이 머신 이름을 "intel-core2-32"로 인식한다는 것입니다.
      하지만 OpenEmbedded 빌드 시스템은 해당 머신을 다음과 같이 이해합니다.
      "core2-32-intel-common".

### `KMETA_AUDIT`

      `ref-classes-kernel-yocto` 클래스를 상속받을 때,
      `KMETA_AUDIT` 변수는 Linux 커널 감사 기능을 활성화 또는 비활성화합니다.
      구성. 이 변수의 기본값은 "예"이며 감사 기능이 있습니다.
      감사 기능이 활성화되어 있습니다. 감사 기능을 비활성화하려면 이 변수를 빈 문자열로 설정하십시오.

### `KMETA_AUDIT_WERROR`

      `ref-classes-kernel-yocto` 클래스를 상속받을 때와
      `KMETA_AUDIT` 및 `KMETA_AUDIT_WERROR` 변수가 설정되었습니다.
      Linux 커널 구성에서 비어 있지 않은 문자열로 변환하면 오류가 발생합니다.
      경고만 표시되는 것이 아니라 문제가 감지되었습니다. 자세한 내용은 다음을 참조하십시오.
      Linux 커널 구성 감사 기능에 대한 자세한 내용은 ``KCONF_AUDIT_LEVEL`을 참조하십시오.
      그리고 `KCONF_BSP_AUDIT_LEVEL`.

### `KMETA_CONFIG_FEATURES`

      `KMETA_CONFIG_FEATURES` 변수는 KMETA에 대해 활성화된 기능을 정의합니다.
      :ref:`ref-classes-kernel-yocto` 클래스. 다음은 기능 목록입니다.
      지원되는 항목:

      - ``prefer-modules``: 커널 구성이 ``m``으로 설정되도록 선호합니다.
         커널 구성이 다음과 같을 경우 기본값 ``y`` 대신
         다음과 같이 정의됩니다::

            CONFIG_FOO=y # 재정의:$MODULE_OR_Y

      이 변수의 기본값은 빈 문자열입니다.

### `KTYPE`

      구성 파일을 생성하는 데 사용할 커널 유형을 정의합니다.
      linux-yocto 레시피는 "standard", "tiny" 및 "preempt-rt"를 정의합니다.
      커널 유형에 대한 자세한 내용은 ":ref:`kernel-dev/advanced:kernel types`"를 참조하십시오.
      섹션 내
      자세한 내용은 Yocto Project Linux 커널 개발 매뉴얼을 참조하십시오.
      커널 유형.

      `KTYPE` 변수는 다음과 같이 정의합니다.
      :ref:`kernel-dev/advanced:bsp 설명`.
      사용하는 값은 에 사용된 값과 일치해야 합니다.
      `LINUX_KERNEL_TYPE` 값은 다음에서 사용됩니다.
      커널 레시피.

### `LABELS`

      자동 구성을 위한 대상 목록을 제공합니다.

      자세한 내용은 :ref:`ref-classes-grub-efi` 클래스를 참조하세요.
      이 변수가 어떻게 사용되는지에 대한 정보입니다.

### `LAYERDEPENDS`

      이 레이어가 의존하는 레이어 목록을 공백으로 구분하여 표시합니다.
      선택적으로, 종속성에 대해 특정 레이어 버전을 지정할 수 있습니다.
      레이어 이름 끝에 추가하면 됩니다. 예시는 다음과 같습니다.

         LAYERDEPENDS_mylayer = "anotherlayer (=3)"

      이전 예시에서,
      "anotherlayer" 버전 3과 비교됩니다.
      `레이어버전`\ ``_다른레이어``.

      필수 구성 요소가 누락되었거나 버전이 올바르지 않으면 오류가 발생합니다.
      숫자(지정된 경우)가 정확히 일치하지 않습니다. 이 변수는 다음과 같은 용도로 사용됩니다.
      `conf/layer.conf` 파일은 반드시 해당 이름으로 접미사가 붙어야 합니다.
      특정 레이어(예: ``LAYERDEPENDS_mylayer``).

### `LAYERDIR`

      `layer.conf` 설정 파일 내에서 사용될 때, 이 변수는
      현재 레이어의 경로를 제공합니다. 이 변수는 아닙니다.
      `layer.conf` 외부에서 사용 가능하며 참조가 확장됩니다.
      파일 파싱이 완료되는 즉시.

### `LAYERDIR_RE`

      BitBake 설명서에서 `bitbake:LAYERDIR_RE`를 참조하십시오.

### `LAYERRECOMMENDS`

      이 파일과 함께 사용하기에 권장되는 레이어 목록을 공백으로 구분하여 표시합니다.
      층.

      선택적으로 특정 레이어 버전을 지정할 수 있습니다.
      레이어 이름 끝에 버전을 추가하여 권장 사항을 제시합니다.
      다음은 예시입니다.

         LAYERRECOMMENDS_mylayer = "anotherlayer (=3)"

      이전 예시에서는 "anotherlayer" 버전 3을 비교했습니다.
      ``LAYERVERSION_anotherlayer``에 대항합니다.

      이 변수는 `conf/layer.conf` 파일에서 사용되며 반드시 입력해야 합니다.
      특정 레이어의 이름이 접미사로 붙습니다(예:
      ``LAYERRECOMMENDS_mylayer``).

### `LAYERSERIES_COMPAT`

      BitBake 설명서에서 `bitbake:LAYERSERIES_COMPAT`을 참조하십시오.

### `LAYERVERSION`

      선택적으로 레이어 버전을 단일 숫자로 지정할 수 있습니다.
      이것을 `LAYERDEPENDS` 내에서 사용할 수 있습니다.
      특정 버전의 레이어에 의존하기 위해 또 다른 레이어를 추가합니다.
      이 변수는 `conf/layer.conf` 파일에서 사용되며 반드시 입력해야 합니다.
      특정 레이어의 이름이 접미사로 붙습니다(예:
      ``LAYERVERSION_mylayer``).

### `LD`

      :manpage:`링커를 실행하는 데 사용되는 최소한의 명령과 인수입니다.
      <ld(1)>`.

### `LDFLAGS`

      링커에 전달할 플래그를 지정합니다. 이 변수는 내보내집니다.
      환경 변수에 저장되어 소프트웨어에서 사용할 수 있게 됩니다.
      컴파일 단계에서 빌드됩니다.

      `LDFLAGS`의 기본 초기화는 입력값에 따라 다릅니다.
      건설 중:

      - 빌드 시 `TARGET_LDFLAGS`를 사용합니다.
         목표

      - 빌드 시 `BUILD_LDFLAGS`를 사용합니다.
         호스트 빌드(예: ``-native``)

      - 빌드 시 `BUILDSDK_LDFLAGS`
         SDK(예: ``nativesdk-``)

### `LEAD_SONAME`

      컴파일된 기본 라이브러리 파일(예: ``.so``)을 지정합니다.
      :ref:`ref-classes-debian` 클래스가 적용하는 것
      여러 라이브러리를 패키징하는 레시피에 대한 명명 정책.

      이 변수는 :ref:`ref-classes-debian`과 함께 작동합니다.
      수업.

### `LIC_FILES_CHKSUM`

      레시피 소스 코드에 포함된 라이선스 텍스트의 체크섬입니다.

      이 변수는 소스 코드의 라이선스 텍스트 변경 사항을 추적합니다.
      파일입니다. 라이선스 텍스트가 변경되면 빌드가 트리거됩니다.
      실패는 개발자에게 검토할 기회를 제공합니다.
      라이선스 변경.

      이 변수는 모든 레시피에 대해 정의되어야 합니다(단, 예외적인 경우는 제외).
      라이선스가 "CLOSED"로 설정되어 있습니다.

      자세한 내용은 ":ref:`dev-manual/licenses:tracking license changes`"를 참조하세요.
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `LICENSE`

      레시피에 사용된 소스 라이선스 목록입니다. 다음 규칙을 준수하십시오.

      - 개별 라이선스 이름 내에 공백을 사용하지 마십시오.

      - 라이선스 이름을 선택할 수 있는 경우 \| (파이프)를 사용하여 구분하십시오.
         라이선스 간.

      - 라이선스 이름이 여러 개인 경우 & (앰퍼샌드)를 사용하여 구분하십시오.
         소스 코드의 각 부분에 대해 여러 개의 라이선스를 부여할 수 있습니다.

      - 라이선스 이름 사이에 공백을 사용할 수 있습니다.

      - 표준 라이선스의 경우, 다음 파일 이름을 사용하십시오.
         ``meta/files/common-licenses/`` 또는
         `SPDXLICENSEMAP` 플래그 이름은 다음과 같이 정의됩니다.
         ``meta/conf/licenses.conf``.

      다음은 몇 가지 예입니다.

         LICENSE = "LGPL-2.1 전용 | GPL-3.0 전용"
         LICENSE = "MPL-1.0 및 LGPL-2.1 전용"
         LICENSE = "GPL-2.0 이상"

      첫 번째 예시는 다음에서 가져온 것입니다.
      Qt용 레시피이며, 사용자는 이를 다음 중 하나로 배포할 수 있습니다.
      LGPL 버전 2.1 또는 GPL 버전 3. 두 번째 예시는 다음에서 가져온 것입니다.
      카이로에서는 두 개의 라이선스가 소스 코드의 서로 다른 부분을 포괄합니다.
      마지막 예시는 `sysstat`에서 가져온 것으로, 단일 결과를 보여줍니다.
      특허.

      패키지별로 라이선스를 지정하여 관리할 수도 있습니다.
      출력물의 구성 요소에 서로 다른 라이선스가 있는 상황.
      예를 들어, 코드가 GPLv2 라이선스에 따라 배포되는 소프트웨어.
      하지만 함께 제공되는 문서는 GNU 자유 라이선스에 따라 배포됩니다.
      문서 라이선스 1.2는 다음과 같이 명시할 수 있습니다.

         LICENSE = "GFDL-1.2 및 GPL-2.0 전용"
         LICENSE:${PN} = "GPL-2.0 전용"
         LICENSE:${PN}-doc = "GFDL-1.2"

### `LICENSE_CREATE_PACKAGE`

      `LICENSE_CREATE_PACKAGE`를 "1"로 설정하면 OpenEmbedded가 실행됩니다.
      추가 패키지를 생성하는 빌드 시스템 (예:
      각 레시피에 대해 ``${``\ `PN`\ ``}-lic``)를 추가하고
      해당 패키지들을
      `RRECOMMENDS`\ ``:${PN}``.

      ``${PN}-lic`` 패키지는 디렉토리를 설치합니다.
      `/usr/share/licenses``는 `${PN}``이라는 이름으로 되어 있으며, 이는 레시피의 기본입니다.
      이름을 지정하고 해당 디렉터리에 라이선스 및 관련 파일을 설치합니다.
      저작권 정보(즉, 해당 라이선스 파일 사본)
      ``meta/common-licenses``에서 지정된 라이선스와 일치하는 라이선스를 가져옵니다.
      레시피 메타데이터의 `LICENSE` 변수
      표시된 파일의 사본
      `LIC_FILES_CHKSUM`은 다음을 포함합니다.
      라이선스 텍스트).

      라이선스 문구 제공과 관련된 정보는 다음을 참조하십시오.
      `COPY_LIC_DIRS` 변수,
      `COPY_LIC_MANIFEST` 변수와
      ":ref:`dev-manual/licenses:라이선스 텍스트 제공`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `LICENSE_FLAGS`

      레시피에 대해 반드시 허용해야 하는 추가 플래그를 지정합니다.
      `LICENSE_FLAGS_ACCEPTED`에서
      레시피를 빌드하는 순서입니다. 여러 개의 플래그를 제공할 경우,
      공백으로 구분하세요.

      이 값은 `LICENSE`와는 무관하며 다음과 같습니다.
      일반적으로 추가 라이선스가 필요할 수 있는 레시피를 표시하는 데 사용됩니다.
      상업용 제품에 사용하기 위해서입니다. 더 자세한 정보는 다음을 참조하세요.
      보다
      ":ref:`개발자 매뉴얼/라이선스:상업적 라이선스가 부여된 레시피 활성화`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `LICENSE_FLAGS_ACCEPTED`

      지정된 경우 적용되는 라이선스 플래그 목록을 보여줍니다.
      레시피 내의 `LICENSE_FLAGS`는 허용되지 않습니다.
      해당 레시피가 빌드되지 않도록 방지합니다. 자세한 내용은 다음을 참조하세요.
      ":ref:`개발자 매뉴얼/라이선스:상업적 라이선스가 부여된 레시피 활성화`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `LICENSE_FLAGS_DETAILS`

      `LICENSE_FLAGS`에 플래그에 대한 세부 정보를 추가합니다. 이렇게 하면
      만약 그러한 플래그가 `LICENSE_FLAGS_ACCEPTED`를 통해 수락되지 않는다면,
      오류 메시지는 지정된 내용을 포함하여 더 자세한 정보를 제공할 것입니다.
      추가 정보.

      예를 들어, EULA가 포함된 레시피는 다음과 같이 설정할 수 있습니다.

         LICENSE_FLAGS = "FooBar-EULA"
         LICENSE_FLAGS_DETAILS[FooBar-EULA] = "자세한 내용은 https://example.com/eula를 참조하세요."

      `Foobar-EULA`가 `LICENSE_FLAGS_ACCEPTED`에 포함되어 있지 않으면,
      오류 메시지가 더 유용합니다.

        LICENSE_FLAGS_ACCEPTED에 나열되지 않은 'FooBar-EULA'라는 제한 라이선스가 있습니다.
        자세한 내용은 https://example.com/eula를 참조하십시오.

### `LICENSE_PATH`

      빌드 중에 사용되는 추가 라이선스의 경로입니다. 기본적으로,
      OpenEmbedded
       빌드 시스템은 `COMMON_LICENSE_DIR`을 사용하여 라이선스를 정의합니다.
      빌드 과정에서 사용되는 공통 라이선스 텍스트가 저장된 디렉토리입니다.
      `LICENSE_PATH` 변수를 사용하면 해당 위치를 다른 곳으로 확장할 수 있습니다.
      추가 라이선스가 필요한 지역::

         LICENSE_PATH += "추가 공통 라이선스 경로"

### `LINUX_KERNEL_TYPE`

      구성 파일을 생성하는 데 사용할 커널 유형을 정의합니다.
      linux-yocto 레시피는 "standard", "tiny" 및 "preempt-rt"를 정의합니다.
      커널 유형에 대한 자세한 내용은 ":ref:`kernel-dev/advanced:kernel types`"를 참조하십시오.
      섹션 내
      자세한 내용은 Yocto Project Linux 커널 개발 매뉴얼을 참조하십시오.
      커널 유형.

      `LINUX_KERNEL_TYPE`을 지정하지 않으면 기본값이 사용됩니다.
      "표준". `KMACHINE`과 함께,
      `LINUX_KERNEL_TYPE` 변수는 검색에 사용되는 인수를 정의합니다.
      커널 도구를 사용하여 해당 설명 내에서 적절한 설명을 찾습니다.
      커널 `메타데이터`를 사용하여 소스를 빌드합니다.
      및 구성.

### `LINUX_VERSION`

      ``kernel.org``에서 제공하는 Linux 버전 정보는 Linux 커널 이미지에 사용된 Linux 버전입니다.
      OpenEmbedded 빌드 시스템을 사용하여 빌드되는 것은 다음과 같습니다. 정의합니다.
      이 변수는 커널 레시피에 있습니다. 예를 들어,
      ``linux-yocto-3.4.bb`` 커널 레시피가 발견되었습니다.
      ``meta/recipes-kernel/linux``는 변수를 다음과 같이 정의합니다.

         LINUX_VERSION ?= "3.4.24"

      `LINUX_VERSION` 변수는 `PV`를 정의하는 데 사용됩니다.
      레시피는 다음과 같습니다.

         PV = "${LINUX_VERSION}+git"

### `LINUX_VERSION_EXTENSION`

      리눅스 버전 문자열에 컴파일되는 문자열 확장 기능
      OpenEmbedded 빌드 시스템으로 빌드된 커널입니다. 이 값은 사용자가 정의합니다.
      커널 레시피의 변수. 예를 들어, linux-yocto 커널
      모든 레시피는 변수를 다음과 같이 정의합니다.

         LINUX_VERSION_EXTENSION ?= "-yocto-${LINUX_KERNEL_TYPE}"

      이 변수를 정의하는 것은 기본적으로 리눅스 커널을 설정하는 것과 같습니다.
      구성 항목 ``CONFIG_LOCALVERSION``은 다음을 통해 볼 수 있습니다.
      `uname` 명령어입니다. 다음은 확장자를 보여주는 예입니다.
      이전에 표시된 대로 설정되어 있다고 가정하면:

         $ uname -r
         3.7.0-rc8-custom

### `LOG_DIR`

      OpenEmbedded 빌드 시스템이 데이터를 기록할 디렉토리를 지정합니다.
      전체 로그 파일입니다. 기본 디렉터리는 ``${TMPDIR}/log``입니다.

      각 작업별 로그가 포함된 디렉터리는 다음을 참조하십시오.
      `T` 변수.

### `MACHINE`

      이미지를 빌드할 대상 장치를 지정합니다. 이 설정은 사용자가 정의합니다.
      `local.conf` 파일에서 찾은 `MACHINE`
      `빌드 디렉터리`. 기본적으로 `MACHINE`은 다음과 같이 설정됩니다.
      "qemux86"은 에뮬레이션 대상인 x86 기반 아키텍처 머신입니다.
      QEMU 사용::

         MACHINE ?= "qemux86"

      해당 변수는 동일한 머신 구성 파일에 해당합니다.
      이 이름을 통해 기기별 구성이 설정됩니다. 따라서,
      `MACHINE`이 "qemux86"으로 설정된 경우, 해당되는 사항은 다음과 같습니다.
      ``qemux86.conf`` 머신 구성 파일은 다음 위치에서 찾을 수 있습니다.
      `소스 디렉터리`
      ``meta/conf/machine``.

      Yocto 프로젝트에서 지원하는 출하 기기 목록
      다음 사항을 포함하세요::

         MACHINE ?= "qemuarm"
         MACHINE ?= "qemuarm64"
         MACHINE ?= "qemumips"
         MACHINE ?= "qemumips64"
         MACHINE ?= "qemuppc"
         MACHINE ?= "qemux86"
         MACHINE ?= "qemux86-64"
         MACHINE ?= "genericx86"
         MACHINE ?= "genericx86-64"
         머신 ?= "비글본"

      마지막 다섯 개는 Yocto Project 레퍼런스 하드웨어입니다.
      ``meta-yocto-bsp`` 레이어에 제공되는 보드입니다.

      .. 메모::

         보드 지원 패키지(BSP) 레이어를 추가하려면
         구성에 `MACHINE`에 대한 새로운 설정 옵션이 추가되었습니다.

### `MACHINE_ARCH`

      머신별 아키텍처의 이름을 지정합니다.
      변수는 `MACHINE` 또는 ``에서 자동으로 설정됩니다.
      `TUNE_PKGARCH`. 직접 편집하지 마십시오.
      `MACHINE_ARCH` 변수.

### `MACHINE_ESSENTIAL_EXTRA_RDEPENDS`

      설치해야 할 필수 기기별 패키지 목록
      이미지가 빌드되고 있습니다. 빌드 프로세스는 다음 패키지에 의존합니다.
      존재하는 것. 더욱이 이것은 "기계에 필수적인" 요소이기 때문입니다.
      변수, 패키지 목록은 컴퓨터 부팅에 필수적입니다.
      이 변수의 영향은 이미지에 따라 달라집니다.
      ``packagegroup-core-boot``에는 ``core-image-minimal``이 포함됩니다.
      영상.

      이 변수는 다음과 유사합니다.
      `MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS` 변수에 예외가 있습니다.
      빌드 중인 이미지가 해당 변수에 대한 빌드 종속성을 가지고 있다는 것입니다.
      패키지 목록입니다. 다시 말해, 파일이 누락되면 이미지가 빌드되지 않습니다.
      이 목록에서 찾을 수 없습니다.

      예를 들어, 여러분이 제작하려는 기계를 생각해 보세요.
      부팅 시 `example-init`을 실행하여 초기화해야 합니다.
      하드웨어. 이 경우, 기기에서 다음을 사용합니다.
      ``.conf`` 설정 파일::

         MACHINE_ESSENTIAL_EXTRA_RDEPENDS += "example-init"

### `MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS`

      설치 과정의 일부로 권장되는 기기별 패키지 목록
      이미지가 빌드되고 있습니다. 빌드 프로세스는 이러한 요소에 의존하지 않습니다.
      패키지가 존재합니다. 하지만 이것은
      "기계 필수" 변수는 필수 패키지 목록을 나타냅니다.
      부팅 시 기기에 영향을 미칩니다. 이 변수는 이미지에 영향을 미칩니다.
      ``packagegroup-core-boot``에 대한 내용이며, ``core-image-minimal``도 포함됩니다.
      영상.

      이 변수는 `MACHINE_ESSENTIAL_EXTRA_RDEPENDS`와 유사합니다.
      빌드 중인 이미지에 해당 변수가 없다는 점을 제외하면 변수는 동일합니다.
      변수에 포함된 패키지 목록에 대한 빌드 종속성입니다. 다른 말로 하면
      즉, 이 목록에 있는 패키지가 설치되지 않더라도 이미지는 계속 빌드됩니다.
      발견되었습니다. 일반적으로 이 변수는 필수 커널을 처리하는 데 사용됩니다.
      모듈은 기능을 선택하여 내장할 수 있습니다.
      모듈이 아닌 커널로 생성되는 경우 패키지는 생성되지 않습니다.
      생산되었습니다.

      특정 기능을 가진 사용자 정의 커널이 있는 경우를 예로 들어 보겠습니다.
      기기를 사용하려면 터치스크린 드라이버가 필요합니다. 하지만
      드라이버는 모듈로 빌드하거나 커널에 통합할 수 있습니다.
      커널 구성입니다. 드라이버가 모듈로 빌드된 경우,
      설치되기를 원합니다. 하지만 드라이버가 내장되어 있는 경우에는 그렇지 않습니다.
      커널을 사용하더라도 빌드가 성공하기를 원한다면, 이 변수는 다음과 같이 설정합니다.
      "추천" 관계를 설정하여 후자의 경우 빌드가 실행되도록 합니다.
      패키지 누락으로 인해 오류가 발생하지 않도록 하려면, 이를 위해 다음과 같이 가정합니다.
      해당 모듈의 패키지 이름이 ``kernel-module-ab123``이었다면,
      머신의 ``.conf`` 설정 파일에 다음 내용을 사용하십시오.

         MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS += "kernel-module-ab123"

      .. 메모::

         이 예시에서 ``kernel-module-ab123`` 레시피는 다음을 필요로 합니다.
         BitBake가 제대로 작동하도록 하려면 `PACKAGES` 변수를 명시적으로 설정해야 합니다.
         커널 레시피의 `PACKAGES_DYNAMIC` 변수를 사용하지 않습니다.
         종속성을 만족시키세요.

      이러한 기계 필수 요소의 몇 가지 예로는 플래시, 화면 등이 있습니다.
      키보드, 마우스 또는 터치스크린 드라이버(기기에 따라 다름).

### `MACHINE_EXTRA_RDEPENDS`

      이미지 설치에 포함될 기기별 패키지 목록컴퓨터 부팅에 필수적이지 않은 부분이 
      생성되고 있습니다 . 하지만
      더욱 다양한 기능을 갖춘 이미지를 생성하기 위한 빌드 프로세스는 다음 요소에 따라 달라집니다.
      소포가 있는 상태입니다.

      이 변수는 ``packagegroup-base``를 기준으로 하는 모든 이미지에 영향을 미칩니다.
      ``core-image-minimal``을 포함하지 않는
      ``core-image-full-cmdline`` 이미지.

      해당 변수는 `MACHINE_EXTRA_RRECOMMENDS` 변수와 유사합니다.
      단, 빌드 중인 이미지에 빌드 종속성이 있는 경우는 예외입니다.
      변수의 패키지 목록에 추가됩니다. 다시 말해, 이미지는 다음과 같습니다.
      이 목록에 있는 파일을 찾을 수 없으면 빌드하지 않습니다.

      예를 들어 와이파이 기능이 있지만 필수적인 기능은 아닌 기계가 있습니다.
      머신이 이미지를 부팅하려면 필요합니다. 하지만 빌드하는 경우에는
      더욱 풍부한 기능을 갖춘 이미지를 보려면 Wi-Fi를 활성화해야 합니다. 패키지
      WiFi 하드웨어용 펌웨어를 포함하는 것은 항상 다음과 같은 것으로 예상됩니다.
      존재하므로 빌드 프로세스가 이에 의존하는 것은 허용됩니다.
      패키지를 찾는 것입니다. 이 경우, 해당 패키지가 다음과 같다고 가정합니다.
      펌웨어 이름은 ``wifidriver-firmware``였고, 사용하려면 다음을 사용해야 했습니다.
      머신의 ``.conf`` 파일에 다음과 같이 설정되어 있습니다.

         MACHINE_EXTRA_RDEPENDS += "wifidriver-firmware"

### `MACHINE_EXTRA_RRECOMMENDS`

      이미지 설치에 포함될 기기별 패키지 목록
      머신 부팅에 필수적이지 않은 파일들이 빌드되고 있습니다. 이미지
      빌드 중인 프로세스는 이 패키지 목록에 대한 빌드 종속성이 없습니다.

      이 변수는 ``packagegroup-base``를 기준으로 하는 이미지에만 영향을 미칩니다.
      ``core-image-minimal``을 포함하지 않는
      ``core-image-full-cmdline`` 이미지.

      이 변수는 `MACHINE_EXTRA_RDEPENDS` 변수와 유사합니다.
      단, 빌드 중인 이미지에 빌드 정보가 없는 경우는 예외입니다.
      변수의 패키지 목록에 대한 의존성. 다시 말해,
      이 목록에 있는 파일을 찾을 수 없으면 이미지가 빌드됩니다.

      예를 들어 와이파이 기능이 있지만 필수적인 기능은 아닌 기계가 있습니다.
      머신이 이미지를 부팅하려면. 하지만 빌드하는 경우에는
      더욱 풍부한 기능을 갖춘 이미지를 보려면 Wi-Fi를 활성화해야 합니다. 이 경우,
      WiFi 커널 모듈이 포함된 패키지는 다음과 같은 경우 생성되지 않습니다.
      WiFi 드라이버가 커널에 내장되어 있는 경우에도 여전히 다음과 같은 작업을 수행해야 합니다.
      패키지로 인해 빌드가 실패하는 대신 성공하도록 합니다.
      찾을 수 없습니다. 이를 해결하기 위해 해당 패키지가 있다고 가정합니다.
      모듈 이름이 ``kernel-module-examplewifi``였다면, 다음과 같이 사용했을 것입니다.
      머신의 ``.conf`` 파일에 다음과 같이 설정되어 있습니다.

         MACHINE_EXTRA_RRECOMMENDS += "kernel-module-examplewifi"

### `MACHINE_FEATURES`

      하드웨어 기능 목록을 지정합니다.
      `MACHINE`은 지원 가능합니다. 관련 내용은 다음과 같습니다.
      기능 활성화에 대한 자세한 내용은 다음을 참조하세요.
      `배포판_특징`,
      `COMBINED_FEATURES`, 및
      `이미지_특징` 변수.

      Yocto 프로젝트에서 지원하는 하드웨어 기능 목록은 다음과 같습니다.
      배송 관련 자세한 내용은 ":ref:`ref-features-machine`" 섹션을 참조하십시오.

### `MACHINE_FEATURES_BACKFILL`

      추가할 공백으로 구분된 기능 목록
      `MACHINE_FEATURES`가 존재하지 않는 경우
      `MACHINE_FEATURES_BACKFILL_CONSIDERED`.

      이 변수는 ``meta/conf/bitbake.conf`` 파일에 설정되어 있습니다. 그렇지 않습니다.
      사용자가 구성할 수 있도록 설계되었습니다. 가장 좋은 방법은 해당 항목을 참조하는 것입니다.
      어떤 기계 기능이 활성화되는지 확인하기 위한 변수입니다.
      :ref:`모든 머신 구성에 대해 <ref-features-backfill>`이 백필되었습니다.

### `MACHINE_FEATURES_BACKFILL_CONSIDERED`

      `MACHINE_FEATURES_BACKFILL`에서 가져온 공백으로 구분된 기능 목록
      그것은 :ref:`백필 <ref-features-backfill>` (즉, 추가됨)이 되어서는 안 됩니다.
      빌드 중에 `MACHINE_FEATURES`로 이동합니다.

      이는 옵트아웃 메커니즘에 해당합니다. 새 기본 머신이 설정될 때
      새로운 기능이 도입되면 머신 정의 유지 관리자가 검토할 수 있습니다.
      (그들을) 고려하고 제외하기로 결정하세요.
      :ref:`백필된 <ref-features-backfill>` 기능입니다. 따라서
      `MACHINE_FEATURES_BACKFILL`과 조합
      `MACHINE_FEATURES_BACKFILL_CONSIDERED`를 사용하면 가능합니다.
      기존 머신 정의를 손상시키지 않고 새로운 기본 기능을 추가합니다.

### `MACHINEOVERRIDES`

      현재 설정에 적용되는 재정의 목록을 콜론으로 구분하여 나열합니다.
      기계. 기본적으로 이 목록에는 다음 값이 포함됩니다.
      `기계`.

      `MACHINEOVERRIDES`를 확장하여 추가적인 오버라이드를 추가할 수 있습니다.
      머신에 적용되어야 합니다. 예를 들어, QEMU에서 에뮬레이션되는 모든 머신이 그렇습니다.
      (예: ``qemuarm``, ``qemux86`` 등)에는 다음과 같은 이름의 파일이 포함됩니다.
      ``meta/conf/machine/include/qemu.inc`` 파일에 다음 내용이 추가됩니다.
      `MACHINEOVERRIDES`::로 재정의하세요.

         MACHINEOVERRIDES =. "qemuall:"

      이것
      override를 사용하면 에뮬레이션되는 모든 머신에 대해 변수를 재정의할 수 있습니다.
      QEMU에서는 `connman-conf`의 다음 예시와 같습니다.
      레시피::

         SRC_URI:append:qemuall = " file://wired.config \
             파일://유선 설정 \
             "

      그 이면에 있는 기본 메커니즘
      `MACHINEOVERRIDES`는 기본 설정에 포함된다는 의미입니다.
      `OVERRIDES`의 값입니다.

### `MAINTAINER`

      배포 관리자의 이메일 주소입니다.

### `MESON_BUILDTYPE`

      Meson의 `--buildtype` 인수의 값
      :ref:`ref-classes-meson` 클래스입니다. 기본값은 ``debug``입니다.
      `DEBUG_BUILD`는 "1"로 설정되고, 그렇지 않으면 ``plain``으로 설정됩니다.

      `Meson 빌드 옵션 <https://mesonbuild.com/Builtin-options.html>`을 참조하세요.
      레시피에서 설정할 수 있는 값들입니다. 예를 들어 `plain`과 같은 값들이 있습니다.
      ``debug``, ``debugoptimized``, ``release`` 및 ``minsize``는 허용합니다.
      디버깅 심볼 포함 여부와 컴파일러를 지정해야 합니다.
      최적화(없음, 성능 또는 크기).

### `MESON_INSTALL_TAGS`

      :ref:`ref-classes-meson` 클래스에 대한 변수로, 이를 지정할 수 있습니다.
      `meson install` 명령어의 `--tags` 인수를 사용하여 태그를 설치합니다.

### `MESON_TARGET`

      :ref:`ref-classes-meson` 클래스에 대한 변수로, 선택할 수 있습니다.
      :ref:`ref-tasks-compile`에서 빌드할 Meson 타겟입니다. 그렇지 않으면,
      기본 타겟이 빌드됩니다.

### `METADATA_BRANCH`

      OpenEmbedded-Core 레이어에 대해 현재 체크아웃된 브랜치(경로)
      `COREBASE`에 의해 결정됨).

### `METADATA_REVISION`

      OpenEmbedded-Core 레이어에 대해 현재 체크아웃된 리비전(경로)
      `COREBASE`에 의해 결정됨).

### `MIME_XDG_PACKAGES`

      :ref:`ref-classes-mime-xdg`의 현재 구현
      클래스가 절대 경로로 설치된 `.desktop` 파일을 감지할 수 없습니다.
      심볼릭 링크. 이 설정을 사용하여 클래스가 설치 후 링크를 ​​생성하도록 합니다.
      어쨌든 이러한 패키지에 대한 제거 후 스크립트를 실행하려면 다음을 수행해야 합니다.
      ``데스크톱 데이터베이스 업데이트`` 명령.

### `MIRRORS`

      OpenEmbedded 빌드 시스템이 사용할 수 있는 추가 경로를 지정합니다.
      소스 코드를 가져옵니다. 빌드 시스템이 소스 코드를 검색할 때,
      먼저 로컬 다운로드 디렉토리를 시도합니다. 해당 위치에서 실패하면, 다음으로 넘어갑니다.
      빌드 시스템은 다음과 같이 정의된 위치를 시도합니다.
      `PREMIRRORS`, 상위 소스, 그리고 나서
      `MIRRORS`로 지정된 위치들이 해당 순서대로 나타납니다.

      `MIRRORS`의 기본값은 다음과 같이 정의됩니다.
      코어 메타데이터 레이어의 ``meta/classes-global/mirrors.bbclass`` 파일입니다.

### `MLPREFIX`

      `PN`에 접두사가 추가되었음을 지정합니다.
      레시피 또는 패키지의 특별 버전(예: Multilib 버전).
      변수는 접두사를 추가해야 하는 곳에서 사용됩니다.
      이름에서 제거됨(예: `BPN` 변수).
      `MLPREFIX`는 `PN`에 접두사가 추가될 때 설정됩니다.

      .. 메모::

         `MLPREFIX`에서 "ML"은 "MultiLib"을 의미합니다. 이 표현은 다음과 같습니다.
         이는 역사적인 사실이며 ":ref:`ref-classes-nativesdk`"가 존재했던 시대에서 유래되었습니다.
         레시피 이름에 접두사가 아니라 접미사로 붙었습니다.
         ":ref:`ref-classes-nativesdk`"가 접두사로 바뀌었는데, 그게 맞는 것 같다.
         또한 `MLPREFIX`를 설정해야 합니다.

      ``MLPREFIX`가 필요한 경우를 이해하려면 다음 사항을 고려해 보세요.
      `BBCLASSEXTEND`는 :ref:`ref-classes-nativesdk`를 제공하는 데 사용됩니다.
      목표 버전 외에 레시피의 다른 버전입니다. 만약 그 레시피가
      다른 레시피의 작업에 대한 빌드 시간 종속성을 선언합니다.
      `DEPENDS`를 사용하면 "foo"에 대한 종속성이 자동으로 추가됩니다.
      "nativesdk-foo"에 대한 의존성으로 재작성되었습니다. 하지만 다음과 같은 의존성은 문제가 될 수 있습니다.
      다음 내용은 자동으로 다시 작성되지 않습니다.

         do_foo[depends] += "recipe:do_foo"

      그러한 종속성도 변환되도록 하려면 다음과 같이 할 수 있습니다.
      수행원::

         do_foo[depends] += "${MLPREFIX}recipe:do_foo"

### `module_autoload`

      이 변수는 `KERNEL_MODULE_AUTOLOAD`로 대체되었습니다.
      변수입니다. `module_autoload`를 모두 바꿔야 합니다.
      예를 들어, `KERNEL_MODULE_AUTOLOAD`에 다음과 같은 추가 사항이 있습니다.

         module_autoload_rfcomm = "rfcomm"

      이제 다음으로 대체되어야 합니다::

         KERNEL_MODULE_AUTOLOAD += "rfcomm"

      자세한 내용은 `KERNEL_MODULE_AUTOLOAD` 변수를 참조하십시오.

### `module_conf`

      `modprobe.d <https://linux.die.net/man/5/modprobe.d>`를 지정합니다.
      ``/etc/modprobe.d/modname.conf``에 포함될 구문 줄
      파일.

      이 변수는 해당 변수가 인식될 수 있는 곳이라면 어디에서든 사용할 수 있습니다.
      커널 레시피 또는 트리 외부 커널 모듈 레시피(예: 머신)
      구성 파일, 배포 구성 파일, 추가 파일
      레시피 또는 레시피 자체에 대한 것입니다. 이 변수를 사용하면
      또한 모듈 이름을 반드시 명시해야 합니다.
      `KERNEL_MODULE_PROBECONF`
      변하기 쉬운.

      일반적인 구문은 다음과 같습니다.

         module_conf_module_name = "modprobe.d-syntax"

      커널 모듈 이름 재정의를 사용해야 합니다.

      자세한 내용을 알아보려면 셸에서 ``man modprobe.d``를 실행하세요.
      `module_conf`에 제공하려는 정확한 구문입니다.

      `module_conf`를 포함시키면 OpenEmbedded 빌드 시스템에서 다음과 같은 동작이 발생합니다.
      ``/etc/modprobe.d/modname.conf`` 파일에 다음 내용을 입력합니다.
      `modprobe.d` 구문입니다. 다음은 옵션을 추가하는 예입니다.
      ``mymodule``이라는 모듈에 대한 ``arg1`` 및 ``arg2``::

         module_conf_mymodule = "옵션 mymodule arg1=val1 arg2=val2"

      커널 모듈을 자동 로드하도록 지정하는 방법에 대한 자세한 내용은 다음을 참조하십시오.
      부팅 시 `KERNEL_MODULE_AUTOLOAD` 변수를 참조하십시오.

### `MODULE_TARBALL_DEPLOY`

      `modules-*.tgz` 파일 생성을 제어합니다. 이 변수를 설정하세요.
      이 파일의 생성을 비활성화하려면 "0"을 입력하십시오. 이 파일에는 모든 내용이 포함됩니다.
      커널 빌드 결과로 생성된 커널 모듈입니다.

### `MODULE_TARBALL_LINK_NAME`

      커널 모듈 tarball의 링크 이름입니다. 이 변수는 다음 위치에 설정됩니다.
      ``meta/classes-recipe/kernel-artifact-names.bbclass`` 파일은 다음과 같습니다.

         MODULE_TARBALL_LINK_NAME ?= "${KERNEL_ARTIFACT_LINK_NAME}"

      값
      ``KERNEL_ARTIFACT_LINK_NAME`` 변수는 다음과 같이 설정됩니다.
      같은 파일에 다음과 같은 값이 있습니다.

         KERNEL_ARTIFACT_LINK_NAME ?= "${MACHINE}"

      자세한 내용은 `MACHINE` 변수를 참조하십시오.

### `MODULE_TARBALL_NAME`

      커널 모듈 tarball의 기본 이름입니다. 이 변수는 다음 위치에 설정됩니다.
      ``meta/classes-recipe/kernel-artifact-names.bbclass`` 파일은 다음과 같습니다.

         MODULE_TARBALL_NAME ?= "${KERNEL_ARTIFACT_NAME}"

      자세한 내용은 `KERNEL_ARTIFACT_NAME`을 참조하십시오.

### `MOUNT_BASE`

      ``udev-extraconf``가 사용되는 systemd를 사용하지 않는 시스템에서는,
      파일 시스템을 자동 마운트할 기본 디렉터리를 지정합니다.
      기본값은 "/run/media"입니다.

### `MOUNT_GROUP`

      ``udev-extraconf``가 사용되는 systemd를 사용하지 않는 시스템에서는,
      파일 시스템을 자동 마운트할 마운트 그룹을 지정합니다.
      기본값은 "디스크"입니다.

### `MULTIMACH_TARGET_SYS`

      패키지가 적용될 대상 시스템의 유형을 고유하게 식별합니다.
      구축 중입니다. 이 변수를 사용하면 다양한 유형의 출력을 생성할 수 있습니다.
      대상 시스템을 동일한 디렉토리 내의 서로 다른 하위 디렉토리에 배치합니다.
      출력 디렉토리.

      이 변수의 기본값은 다음과 같습니다.

         ${PACKAGE_ARCH}${TARGET_VENDOR}-${TARGET_OS}

      일부 클래스(예: :ref:`ref-classes-cross-canadian`)는 다음을 수정합니다.
      `MULTIMACH_TARGET_SYS` 값.

      예시를 보려면 `STAMP` 변수를 참조하십시오.
      자세한 내용은 `STAGING_DIR_TARGET` 변수를 참조하십시오.

### `NATIVELSBSTRING`

      호스트 배포판을 식별하는 문자열입니다. 문자열은 다음과 같이 구성됩니다.
      호스트 배포업체 ID와 릴리스 정보가 뒤따릅니다.
      `lsb_release` 도구를 사용하거나 `/etc/lsb-release`에서 읽어온 내용을 기준으로 합니다.
      예를 들어, Ubuntu 12.10에서 빌드를 실행할 때 값은 다음과 같습니다.
      "Ubuntu-12.10". 이 정보를 확인할 수 없는 경우,
      값이 "알 수 없음"으로 확인됩니다.

      이 변수는 기본적으로 네이티브 공유 상태를 격리하는 데 사용됩니다.
      서로 다른 배포판용 패키지(예: 문제를 방지하기 위해)
      ``glibc`` 버전 비호환성). 또한, 해당 변수는 다음과 같습니다.
      대조해 보았습니다.
      `SANITY_TESTED_DISTROS` 만약 그렇다면
      변수가 설정되었습니다.

### `NM`

      :manpage:`nm <nm(1)>`을 실행하기 위한 최소 명령 및 인수입니다.

### `NO_GENERIC_LICENSE`

      일반적이지 않고 폐쇄형이 아닌 라이선스를 사용할 때 QA 오류를 방지합니다.
      레시피. 리눅스 펌웨어 패키지와 같이 다양한 패키지가 있습니다.
      전혀 일반적이지 않은 라이선스들이 있습니다. 또한, 새로운 라이선스들이 추가됩니다.
      일반적인 라이선스 파일을 많이 도입하는 것을 피하기 위해 때때로,
      이는 특정 패키지에만 적용됩니다.
      `NO_GENERIC_LICENSE`는 일반 라이선스를 복사할 수 있도록 허용하는 데 사용됩니다.
      일반적인 라이선스에는 존재하지 않습니다.

      다음 예시는 `NO_GENERIC_LICENSE`를 추가하는 방법을 보여줍니다.
      레시피::

         NO_GENERIC_LICENSE[license_name] = "가져온 소스의 라이선스 파일"

      다음은 그 예입니다.
      가져온 라이선스에서 ``LICENSE.Abilis.txt`` 파일을 사용합니다.
      원천::

         NO_GENERIC_LICENSE[펌웨어-Abilis] = "LICENSE.Abilis.txt"

### `NO_RECOMMENDATIONS`

      "권장 전용" 패키지의 설치를 모두 차단합니다.
      권장 전용 패키지는 권장 경로를 통해서만 설치되는 패키지입니다.
      `RRECOMMENDS` 변수). 설정
      `NO_RECOMMENDATIONS` 변수를 "1"로 설정하면 이 기능이 켜집니다.

         NO_RECOMMENDATIONS = "1"

      이 변수는 `local.conf` 파일에서 전역적으로 설정하거나,
      레시피 이름을 사용하여 특정 이미지 레시피에 첨부할 수 있습니다.
      보수::

         권장사항 없음:pn-target_image = "1"

      패키지를 설치하지 않기로 선택하는 경우 발생할 수 있는 문제점을 인지하는 것이 중요합니다.
      이 변수를 사용하는 것과 다른 몇몇 패키지들이 이 변수에 의존하고 있습니다.
      (예: 레시피의 `RDEPENDS`에 나열됨)
      변수) OpenEmbedded 빌드 시스템은 귀하의 요청을 무시합니다.
      종속성 오류를 방지하기 위해 필요한 패키지를 설치합니다.

      .. 메모::

         일부 시스템에서는 권장 패키지가 필요할 수 있습니다.
         커널 모듈과 같은 기능을 추가할 수 있습니다. 추가하는 것은 사용자에게 달려 있습니다.
         `IMAGE_INSTALL` 변수를 사용하는 패키지입니다.

      이 변수는 IPK 및 RPM을 사용할 때만 지원됩니다.
      패키징 백엔드. DEB는 지원되지 않습니다.

      `BAD_RECOMMENDATIONS`를 참조하십시오.
      `PACKAGE_EXCLUDE` 변수는 다음과 같습니다.
      관련 정보.

### `NOAUTOPACKAGEDEBUG`

      자동 패키지 생성 시 ``.debug`` 파일 분할을 비활성화합니다. 레시피가
      ``FILES:${PN}-dbg``를 수동으로 설정해야 합니다.
      `NOAUTOPACKAGEDEBUG`를 정의하면 다음을 정의할 수 있습니다.
      디버그 패키지의 내용입니다. 예를 들면 다음과 같습니다.

         NOAUTOPACKAGEDEBUG = "1"
         파일:${PN}-dev = "${includedir}/${QT_DIR_NAME}/Qt/*"
         파일:${PN}-dbg = "/usr/src/debug/"
         파일:${QT_BASE_NAME}-demos-doc = "${docdir}/${QT_DIR_NAME}/qch/qt.qch"

### `NON_MULTILIB_RECIPES`

      multilib용으로 빌드해서는 안 되는 레시피 목록입니다. OE-Core의
      `multilib.conf` 파일은 이를 위한 적절한 시작점을 정의합니다.
      다음이 포함된 목록::

         NON_MULTILIB_RECIPES = "grub grub-efi make-mod-scripts ovmf u-boot"

### `NVD_DB_VERSION`

      `NVD_DB_VERSION` 변수를 사용하면 CVE 피드를 선택할 수 있습니다.
      :ref:`ref-classes-cve-check` 클래스를 사용합니다. 다음 중 하나일 수 있습니다.

      - ``NVD2`` (기본값): API 버전 2를 사용하는 NVD 피드
      - ``FKIE``: `FKIE-CAD <https://github.com/fkie-cad/nvd-json-data-feeds>`__
         사료 재구성
      - ``NVD1``: NVD JSON 피드(더 이상 사용되지 않음)

      피드 이름 형식이 잘못된 경우 ``NVD2`` 피드가 선택됩니다.
      오류 메시지가 출력됩니다.

### `NVDCVE_API_KEY`

      CVE 데이터베이스에서 데이터를 검색할 때 사용되는 NVD API 키는 다음과 같습니다.
      :ref:`ref-classes-cve-check`를 사용합니다.

      기본적으로 API 키가 사용되지 않으므로 API 응답 간에 더 큰 지연이 발생합니다.
      요청 횟수와 공개된 요금 제한에 대한 쿼리 횟수를 제한합니다.
      `NVD 개발자 페이지 <https://nvd.nist.gov/developers/start-here>`에서 시작하세요.

      NVD API 키는 다음을 통해 요청할 수 있습니다.
      `API 키 요청하기 <https://nvd.nist.gov/developers/request-an-api-key>`__
      페이지입니다. `local.conf` 파일에서 이 변수를 NVD API 키로 설정할 수 있습니다.
      예::

          NVDCVE_API_KEY = "fe753&7a2-1427-347d-23ff-b2e2b7ca5f3"

### `OBJCOPY`

      :manpage:`objcopy <objcopy(1)>`를 실행하기 위한 최소 명령 및 인수입니다.

### `OBJDUMP`

      :manpage:`objdump <objdump(1)>`을 실행하기 위한 최소 명령 및 인수입니다.

### `OE_BINCONFIG_EXTRA_MANGLE`

      `ref-classes-binconfig` 클래스를 상속할 때,
      이 변수는 "sed"에 전달되는 추가 인수를 지정합니다.
      sed 명령어는 설정 스크립트의 경로를 변경합니다.
      컴파일 중에 설정된 것들입니다. 이 클래스를 상속합니다.
      결과적으로 이 스크립트의 모든 경로가 해당 위치를 가리키도록 변경됩니다.
      `sysroots/` 디렉터리를 생성하여 해당 스크립트를 사용하는 모든 빌드가 실행되도록 합니다.
      크로스 컴파일 레이아웃에 맞는 디렉토리 구조를 사용하십시오.

      ``meta/classes-recipe/binconfig.bbclass``를 참조하세요.
      이 클래스에 대한 자세한 내용은 소스 디렉토리를 참조하세요.
      이러한 추가 sed 명령 인수를 적용합니다.

### `OE_FRAGMENTS`

      `OE_FRAGMENTS` 변수에는 `구성` 목록이 저장됩니다.
      현재 빌드에 대해 `<구성 프래그먼트>`가 활성화되어 있습니다.
      프래그먼트 사용 방법에 대한 자세한 내용은 :doc:/ref-manual/fragments를 참조하세요.
      Yocto 프로젝트 참조 설명서의 해당 섹션입니다.

### `OE_FRAGMENTS_BUILTIN`

      `OE_FRAGMENTS_BUILTIN` 변수에는 목록이 저장됩니다.
      `내장 프래그먼트 <내장 프래그먼트>`를 설정할 수 있습니다.
      :oe_git:`bitbake-config-build </bitbake/tree/bin/bitbake-config-build>`.
      프래그먼트 사용 방법에 대한 자세한 내용은 :doc:`/ref-manual/fragments`를 참조하세요.
      Yocto 프로젝트 참조 설명서의 해당 섹션입니다.

### `OE_FRAGMENTS_METADATA_VARS`

      `OE_FRAGMENTS_METADATA_VARS` 변수에는 목록이 저장됩니다.
      표준 설정에서 설정해야 하는 변수
      Fragment` 파일입니다. `OpenEmbedded-Core(OE-Core)`에서 이러한 변수는 다음과 같습니다.
      `BB_CONF_FRAGMENT_SUMMARY` 및
      `BB_CONF_FRAGMENT_DESCRIPTION`.

### `OE_FRAGMENTS_PREFIX`

      `OE_FRAGMENTS_PREFIX` 변수는 접두사를 정의합니다.
      BitBake는 구성 조각을 찾으려고 시도합니다.
      `<Configuration Fragment>`는 `layers <Layer>`의 `layers`에 있습니다. 자세한 방법은 다음을 참조하세요.
      프래그먼트를 사용하려면 Yocto의 `:doc:/ref-manual/fragments` 섹션을 참조하세요.
      프로젝트 참조 설명서.

### `OE_INIT_ENV_SCRIPT`

      빌드 환경 설정 스크립트의 이름 (목적용)
      확장 가능한 SDK 내에서 환경을 설정합니다. 기본값은 다음과 같습니다.
      값은 "oe-init-build-env"입니다.

      빌드 환경 설정을 위해 사용자 지정 스크립트를 사용하는 경우, 다음을 설정하십시오.
      `OE_INIT_ENV_SCRIPT` 변수를 해당 이름으로 변경합니다.

### `OE_SHARED_UMASK`

      `OE_SHARED_UMASK` 변수에는 :manpage:`umask`가 포함되어 있습니다.
      공유 파일에 대한 정의(예: `SSTATE_DIR`에 있는 파일)
      `DL_DIR`).

### `OE_TERMINAL`

      OpenEmbedded 빌드 시스템이 인터랙티브 빌드 프로세스를 생성하는 방식을 제어합니다.
      호스트 개발 시스템의 터미널(예: BitBake 사용)
      ``-c devshell`` 명령줄 옵션을 사용하여 명령을 실행하십시오. 자세한 내용은 다음을 참조하십시오.
      자세한 내용은 ":ref:`dev-manual/development-shell:using a development shell`" 섹션을 참조하십시오.
      Yocto 프로젝트 개발 작업 매뉴얼.

      `OE_TERMINAL` 변수에 다음 값을 사용할 수 있습니다.

      - 자동
      - 노움
      - xfce
      - rxvt
      - 화면
      - 콘솔
      - 없음

### `OECMAKE_GENERATOR`

      :ref:`ref-classes-cmake` 클래스에 대한 변수로, 선택할 수 있습니다.
      CMake가 애플리케이션을 빌드하기 위해 생성할 백엔드는 무엇입니까?

      기본적으로 이 변수는 GNU보다 빠른 "Ninja"로 설정되어 있습니다.
      만들 수는 있지만, Ninja를 사용해도 건축 기능이 제대로 작동하지 않으면 레시피에서 이 방법을 사용할 수 있습니다.
      GNU make를 사용하도록 변수를 변경합니다.

         OECMAKE_GENERATOR = "Unix Makefiles"

### `OEQA_REPRODUCIBLE_TEST_LEAF_TARGETS`

      빌드 재현성 테스트를 위한 빌드 대상을 설정하되 활성화하십시오.
      :ref:`공유 상태 <overview-manual/concepts:공유 상태 캐시>` 빌드
      대부분의 종속성(즉, DEPENDS에 명시적으로 나열된 종속성)의 경우
      모든 종속성이 포함되지 않을 수 있습니다. [depends] varflags, PACKAGE_DEPENDS 등을 참조하세요.
      다른 구현 방식). :doc:`/test-manual/reproducible-builds`를 참조하세요.

### `OEQA_REPRODUCIBLE_TEST_PACKAGE`

      빌드 재현성 테스트를 위해 패키지 관리자를 설정하십시오.
      :yocto_git:`reproducible.py </poky/tree/meta/lib/oeqa/selftest/cases/reproducible.py>`를 참조하세요.
      그리고 :doc:`/test-manual/reproducible-builds`.

### `OEQA_REPRODUCIBLE_TEST_SSTATE_TARGETS`

      공유 상태 캐시(<overview-manual/concepts:shared state cache>)를 사용하여 다시 빌드할 수 있는 빌드 대상을 설정합니다.
      빌드 재현성 테스트를 실행할 때. 자세한 내용은 :doc:/test-manual/reproducible-builds를 참조하세요.

### `OEQA_REPRODUCIBLE_TEST_TARGET`

      빌드 재현성 테스트를 위한 빌드 대상을 설정합니다. 기본값은 다음과 같습니다.
      사용 가능한 모든 레시피는 "bitbake world"로 컴파일됩니다. 자세한 내용은 `EXCLUDE_FROM_WORLD`를 참조하십시오.
      그리고 :doc:`/test-manual/reproducible-builds`.

### `OEROOT`

      최상위 빌드 환경 설정 스크립트가 있는 디렉터리
      소스 코드입니다. Yocto Project는 최상위 빌드 환경을 제공합니다.
      설정 스크립트: :ref:`structure-core-script`. 이 스크립트를 실행하면
      스크립트에서 ``OEROOT` 변수는 해당 디렉터리를 가리킵니다.
      스크립트가 포함되어 있습니다.

      이 변수의 사용 방법에 대한 자세한 내용은 다음을 참조하십시오.
      초기화 스크립트.

### `OLDEST_KERNEL`

      생성된 Linux 커널의 가장 오래된 버전을 선언합니다.
      바이너리는 다음 기능을 지원해야 합니다. 이 변수는 빌드 과정에 전달됩니다.
      내장형 GNU C 라이브러리(``glibc``).

      이 변수의 기본값은 다음에서 가져옵니다.
      ``meta/conf/bitbake.conf`` 설정 파일입니다. 이 설정을 재정의할 수 있습니다.
      사용자 지정 배포에서 변수를 설정하여 기본값을 지정합니다.
      설정 파일.

### `OPKG_MAKE_INDEX_EXTRA_PARAMS`

      `opkg-make-index` 명령에 대한 추가 매개변수를 지정합니다.

### `OPKGBUILDCMD`

      변수 ``OPKGBUILDCMD`는 opkg를 빌드하는 데 사용되는 명령어를 지정합니다.
      `ref-classes-package_ipk` 클래스를 사용할 때 패키지를 지정합니다.
      :ref:`ref-classes-package_ipk`에 다음과 같이 정의됨::

          OPKGBUILDCMD ??= 'opkg-build -Z zstd -a "${ZSTD_DEFAULTS}"'

### `OVERLAYFS_ETC_DEVICE`

      :ref:`ref-classes-overlayfs-etc` 클래스가
      상속됨, 읽기/쓰기를 위해 마운트될 장치를 지정합니다.
      ``/etc``의 레이어입니다. 기본값이 없으므로 필요한 경우 설정해야 합니다.
      :ref:`ref-classes-overlayfs-etc`를 활성화하고 싶습니다.
      예를 들어, 원하는 장치가 ``/dev/mmcblk0p2``라고 가정해 보겠습니다.

         OVERLAYFS_ETC_DEVICE = "/dev/mmcblk0p2"

### `OVERLAYFS_ETC_EXPOSE_LOWER`

      :ref:`ref-classes-overlayfs-etc` 클래스가
      상속되며, "1"로 설정된 경우 원본에 대한 읽기 전용 액세스가 허용됩니다.
      `/etc`의 내용은 `/` 하위 디렉토리로 제공됩니다.
      `OVERLAYFS_ETC_MOUNT_POINT`. 기본값은 "0"입니다.

### `OVERLAYFS_ETC_FSTYPE`

      :ref:`ref-classes-overlayfs-etc` 클래스가
      상속됨, 읽기/쓰기에 사용할 파일 시스템 유형을 지정합니다.
      ``/etc``의 레이어입니다. 기본값이 없으므로 필요한 경우 설정해야 합니다.
      :ref:`ref-classes-overlayfs-etc`를 활성화하고 싶습니다.
      예를 들어 파일 시스템이 ext4::라고 가정해 보겠습니다.

         OVERLAYFS_ETC_FSTYPE = "ext4"

### `OVERLAYFS_ETC_MOUNT_OPTIONS`

      :ref:`ref-classes-overlayfs-etc` 클래스가
      상속됨, 읽기/쓰기 계층에 대한 마운트 옵션을 지정합니다.
      기본값은 "기본값"입니다.

### `OVERLAYFS_ETC_MOUNT_POINT`

      :ref:`ref-classes-overlayfs-etc` 클래스가
      inherited는 파일 시스템 계층에 대한 상위 마운트 경로를 지정합니다.
      기본값이 없으므로 활성화하려면 직접 설정해야 합니다.
      예를 들어 원하는 경로가 다음과 같을 경우 :ref:`ref-classes-overlayfs-etc`
      "/데이터"::

         OVERLAYFS_ETC_MOUNT_POINT = "/data"

### `OVERLAYFS_ETC_USE_ORIG_INIT_NAME`

      :ref:`ref-classes-overlayfs-etc` 클래스가 상속될 때, 컨트롤
      생성된 init 파일의 이름이 어떻게 지정될지 설명합니다. 자세한 내용은 다음을 참조하세요.
      :ref:`ref-classes-overlayfs-etc` 클래스 문서. 기본값
      "1"입니다.

### `OVERLAYFS_MOUNT_POINT`

      :ref:`ref-classes-overlayfs` 클래스를 상속받을 때,
      사용할 마운트 지점을 지정합니다. 예를 들면 다음과 같습니다.

         OVERLAYFS_MOUNT_POINT[data] = "/data"

      이는 다른 곳에 `data.mount` 시스템d 유닛이 정의되어 있다고 가정합니다.
      (예: `systemd-machine-units` 레시피에 있는) BSP가 설치되어 있습니다.
      이미지 안으로 들어갑니다. 자세한 내용은 :ref:`ref-classes-overlayfs`를 참조하세요.

      .. 메모::

         :ref:`ref-classes-overlayfs` 클래스는
         개별 레시피에 상속됨, `OVERLAYFS_MOUNT_POINT`
         해당 설정은 컴퓨터 구성에서 이루어져야 합니다.

### `OVERLAYFS_QA_SKIP`

      :ref:`ref-classes-overlayfs` 클래스를 상속받을 때,
      특정 오버레이에 대한 QA 검사를 비활성화할 수 있는 기능을 제공합니다.
      마운트. 예를 들면::

         OVERLAYFS_QA_SKIP[data] = "마운트 구성됨"

      .. 메모::

         :ref:`ref-classes-overlayfs` 클래스는
         개별 레시피에 의해 상속됨, `OVERLAYFS_QA_SKIP`
         해당 설정은 컴퓨터 구성에서 이루어져야 합니다.

### `OVERLAYFS_WRITABLE_PATHS`

      :ref:`ref-classes-overlayfs` 클래스를 상속받을 때,
      레시피 실행 시 사용되는 쓰기 가능한 경로를 지정합니다.
      예::

         OVERLAYFS_WRITABLE_PATHS[data] = "/usr/share/my-custom-application"

### `OVERRIDES`

      현재 적용되는 재정의 목록(콜론으로 구분). 재정의
      변수를 선택적으로 지정할 수 있도록 하는 BitBake 메커니즘입니다.
      구문 분석이 끝날 때 재정의됩니다. 재정의 집합은 다음과 같습니다.
      `OVERRIDES`는 빌드 중 "상태"를 나타내며, 여기에는 다음이 포함됩니다.
      현재 제작 중인 레시피, 그리고 그 레시피가 사용될 기계
      건축되었고, 등등.

      예를 들어, 문자열 "an-override"가 요소로 나타나는 경우
      `OVERRIDES`의 콜론으로 구분된 목록, 그 다음
      할당은 `FOO` 값을 "overridden" 값으로 덮어씁니다.
      구문 분석 종료::

         FOO:an-override = "재정의됨"

      보세요
      ":ref:`bitbake-user-manual/bitbake-user-manual-metadata:조건부 구문(재정의)`"
      자세한 내용은 BitBake 사용자 설명서의 해당 섹션을 참조하십시오.
      오버라이드 메커니즘.

      `OVERRIDES`의 기본값에는 다음 값이 포함됩니다.
      `클래스 오버라이드`,
      `MACHINEOVERRIDES`, 그리고
      `DISTROOVERRIDES` 변수. 또 다른
      기본적으로 포함된 중요한 재정의는 ``pn-${PN}``입니다. 이 재정의는
      설정 내에서 단일 레시피에 대한 변수를 설정할 수 있습니다.
      (``.conf``) 파일입니다. 다음은 예시입니다.

         FOO:pn-myrecipe = "myrecipe-specific 값"

      .. 메모::

         어떤 재정의 사항이 적용되는지 쉽게 확인하는 방법은 명령어를 실행하는 것입니다.
         ``bitbake-getvar -r myrecipe OVERRIDES``를 참조하세요.
         Yocto의 ":ref:`dev-manual/debugging:viewing variable values`" 섹션
         자세한 내용은 프로젝트 개발 작업 매뉴얼을 참조하십시오.

### `P`

      레시피 이름과 버전 `P`는 다음으로 구성됩니다::

         ${PN}-${PV}

### `P4DIR`

      BitBake 설명서에서 `bitbake:P4DIR`을 참조하십시오.

### `PACKAGE_ADD_METADATA`

      이 변수는 패키지에 추가할 추가 메타데이터를 정의합니다.

      패키지에 추가 메타데이터를 삽입해야 할 수도 있습니다.
      이 변수를 사용하면 주입된 데이터를 다음과 같이 설정하여 이를 수행할 수 있습니다.
      값. 콘텐츠를 분할하여 여러 필드를 추가할 수 있습니다.
      문자 그대로의 구분 기호 "\n".

      변수에 '_IPK', '_DEB' 또는 '_RPM' 접미사를 붙일 수 있습니다.
      패키지 유형별 설정을 할 수 있습니다. 패키지로 만들 수도 있습니다.
      패키지 이름을 접미사로 사용하여 특정합니다.

      이 변수를 적용하는 방법에 대한 자세한 내용은 다음에서 확인할 수 있습니다.
      ":ref:`dev-manual/packages:패키지에 사용자 지정 메타데이터 추가`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `PACKAGE_ARCH`

      결과 패키지 또는 패키지들의 아키텍처.

      기본적으로 이 변수의 값은 다음과 같이 설정됩니다.
      빌드 시 `TUNE_PKGARCH`를 사용하세요.
      대상, 빌드 시 `BUILD_ARCH`
      빌드 호스트와 빌드 시 "${SDK_ARCH}-${SDKPKGSUFFIX}"를 지정합니다.
      SDK.

      .. 메모::

         자세한 내용은 `SDK_ARCH`를 참조하십시오.

      하지만 레시피의 출력 패키지가 특정 환경에 맞게 빌드된 경우
      일반적으로 아키텍처보다는 대상 머신에 대한 것입니다.
      머신에서 `PACKAGE_ARCH` 값을 설정해야 합니다.
      레시피에서 `MACHINE_ARCH`는 다음과 같습니다.

         PACKAGE_ARCH = "${MACHINE_ARCH}"

### `PACKAGE_ARCHS`

      대상 시스템과 호환되는 아키텍처 목록을 지정합니다.
      이 변수는 자동으로 설정되므로 일반적으로는 변경해서는 안 됩니다.
      수작업으로 편집되었습니다. 항목들은 공백으로 구분되어 있으며 순서대로 나열되어 있습니다.
      우선순위. `PACKAGE_ARCHS`의 기본값은 "all any"입니다.
      noarch ${PACKAGE_EXTRA_ARCHS} ${MACHINE_ARCH}".

### `PACKAGE_BEFORE_PN`

      `${PN}` 앞에 ``PACKAGES`를 사용하여 패키지를 쉽게 추가할 수 있습니다.
      추가된 패키지들이 일반적으로는 포함되지 않는 파일들을 가져올 수 있다는 것입니다.
      기본 패키지에 포함되어 있습니다.

### `PACKAGE_CLASSES`

      이 변수는 ``local.conf`` 설정 파일에 설정되어 있습니다.
      `conf` 폴더에서 찾을 수 있습니다.
      `빌드 디렉터리`는 패키지 관리자를 지정합니다.
      OpenEmbedded 빌드 시스템은 데이터를 패키징할 때 사용합니다.

      다음 인수 중 하나 이상을 제공할 수 있습니다.
      변하기 쉬운::

         PACKAGE_CLASSES ?= "package_rpm package_deb package_ipk"

      빌드 시스템은 목록에서 첫 번째 인자만 사용합니다.
      이미지 또는 SDK를 생성할 때 패키지 관리자를 사용합니다. 하지만 패키지는
      사용자가 지정하는 추가 패키징 클래스를 사용하여 생성됩니다.
      예를 들어, `local.conf` 파일에 다음과 같이 입력하면 다음과 같습니다.

         PACKAGE_CLASSES ?= "package_ipk"

      OpenEmbedded 빌드 시스템은 다음을 사용합니다.
      IPK 패키지 관리자를 사용하여 이미지 또는 SDK를 생성합니다.

      패키징 및 빌드 성능 영향에 대한 정보는 다음과 같습니다.
      사용 중인 패키지 관리자의 결과를 참조하십시오.
      ":ref:`ref-classes-package`" 섹션.

### `PACKAGE_DEBUG_SPLIT_STYLE`

      디버그 및 소스 정보를 분할하고 패키징하는 방법을 결정합니다.
      GNU 프로젝트에서 사용할 디버깅 패키지를 만들 때
      디버거(GDB). 일반적으로 이 변수의 값에 따라,
      소스 코드와 디버그 정보를 하나의 패키지로 결합할 수 있습니다.
      소스 코드를 별도의 패키지로 분리할 수 있습니다.
      별도로 설치하거나, ​​소스를 설치하지 않도록 선택할 수도 있습니다.
      전혀 포장되지 않았습니다.

      `PACKAGE_DEBUG_SPLIT_STYLE` 변수의 가능한 값:

      - "``.debug``": 모든 디버깅 및 소스 정보가 하나의 폴더에 저장됩니다.
         ``*-dbg`` 패키지를 사용하면 디버그 심볼 파일이 다음 위치에 배치됩니다.
         바이너리가 설치된 경우 ``.debug`` 디렉터리에 바이너리가 저장됩니다.
         ``/bin``` 폴더에 해당 디버그 심볼 파일이 설치됩니다.
         `/bin/.debug`에 있습니다. 소스 파일은 동일한 `*-dbg`에 설치됩니다.
         ``/usr/src/debug`` 아래에 패키지가 있습니다.

      - "``debug-file-directory``": 위와 같이 모든 디버깅 및 소스 정보가 포함됩니다.
         디버그 심볼 파일은 하나의 ``*-dbg`` 패키지에 포함됩니다.
         ``/usr/lib/debug`` 디렉토리 아래에 완전히 배치되고 분리됩니다.
         바이너리가 설치된 경로를 기준으로 하므로, 바이너리가
         `/bin`에 설치되며, 해당 디버그 심볼도 설치됩니다.
         ``/usr/lib/debug/bin`` 등에 있습니다. 위와 같이 소스가 설치됩니다.
         ``/usr/src/debug`` 아래의 동일한 패키지에 있습니다.

      - "``debug-with-srcpkg``": 디버깅 정보가 표준에 배치됩니다.
         ``*-dbg`` 패키지는 ``.debug`` 값과 동일하며, 소스는 다음과 같습니다.
         별도의 ``*-src`` 패키지에 포함되어 있으며, 설치 가능합니다.
         독립적으로 작동합니다. 이것이 이 변수의 기본 설정입니다.
         Poky의 ``bitbake.conf`` 파일에 정의된 대로입니다.

      - "``debug-without-src``": ``.debug``를 사용했을 때와 동일한 동작을 합니다.
         설정은 되어 있지만 소스 코드는 전혀 패키징되지 않았습니다.

      .. 메모::

         위의 패키지 분할 대부분은 다음을 통해 재정의할 수 있습니다.
         `INHIBIT_PACKAGE_DEBUG_SPLIT` 변수 사용.

      GDB를 사용한 디버깅에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`dev-manual/debugging:GNU 프로젝트 디버거(gdb)를 이용한 원격 디버깅`" 섹션
      Yocto 프로젝트 개발 작업 매뉴얼에 있습니다.

### `PACKAGE_EXCLUDE`

      이미지에 설치해서는 안 되는 패키지 목록입니다.
      예::

         PACKAGE_EXCLUDE = "package_name package_name package_name ..."

      이 변수는 `local.conf` 파일에서 전역적으로 설정하거나,
      레시피 이름을 사용하여 특정 이미지 레시피에 첨부할 수 있습니다.
      보수::

         PACKAGE_EXCLUDE:pn-target_image = "package_name"

      이 변수를 사용하여 패키지를 설치하지 않기로 선택하는 경우,
      다른 패키지는 그것에 의존합니다 (예: 레시피에 나열됨).
      `RDEPENDS` 변수), OpenEmbedded 빌드
      시스템에서 치명적인 설치 오류가 발생했습니다. 빌드 시스템 때문입니다.
      치명적인 오류로 프로세스가 중단되는 경우, 변수를 사용할 수 있습니다.
      특정 구성 요소를 제거하기 위한 반복적인 개발 프로세스
      체계.

      이 변수는 IPK 및 RPM을 사용할 때만 지원됩니다.
      패키징 백엔드. DEB는 지원되지 않습니다.

      `NO_RECOMMENDATIONS` 및 다음을 참조하십시오.
      `BAD_RECOMMENDATIONS` 변수
      관련 정보.

### `PACKAGE_EXCLUDE_COMPLEMENTARY`

      특정 패키지가 설치되지 않도록 방지합니다.
      추가 패키지를 설치합니다.

      특정 패키지의 설치를 막고 싶을 수도 있습니다.
      추가 패키지를 설치할 때. 예를 들어, 다음과 같은 경우
      설치하려면 `IMAGE_FEATURES`를 사용합니다.
      ``dev-pkgs``에서 모든 패키지를 설치하고 싶지 않을 수도 있습니다.
      특히 멀티라이브러리의 경우, 이러한 상황에 처하게 되면 다음과 같이 할 수 있습니다.
      `PACKAGE_EXCLUDE_COMPLEMENTARY` 변수를 사용하여 정규 패키지를 지정하십시오.
      제외하려는 패키지와 일치하는 표현식입니다.

### `PACKAGE_EXTRA_ARCHS`

      장치 CPU와 호환되는 아키텍처 목록을 지정합니다.
      이 변수는 여러 기기용 앱을 개발할 때 유용합니다.
      XScale 및 ARM926-EJS와 같은 다양한 프로세서를 사용합니다.

### `PACKAGE_FEED_ARCHS`

      선택적으로 패키지 아키텍처를 지정합니다.
      빌드 중 패키지 피드 URI입니다. 사용될 경우,
      `PACKAGE_FEED_ARCHS` 변수가 최종 패키지 피드에 추가됩니다.
      URI는 다음을 사용하여 구성됩니다.
      `PACKAGE_FEED_URIS` 및
      `패키지_피드_베이스_경로`
      변수.

      .. 메모::

         `PACKAGE_FEED_ARCHS`를 사용할 수 있습니다.
         특정 패키지 아키텍처를 허용하는 변수입니다. 만약 그렇다면
         특정 아키텍처를 허용할 필요가 없다는 점이 일반적입니다.
         이 경우에는 해당 변수를 생략할 수 있습니다. 변수를 생략하면 다음과 같은 결과가 나타납니다.
         현재 시스템에서 사용 가능한 모든 아키텍처가 포함됩니다.
         원격 패키지 피드로.

      다음 예시를 고려해 보세요. 여기서 `PACKAGE_FEED_URIS`는 다음과 같습니다.
      `PACKAGE_FEED_BASE_PATHS` 및 `PACKAGE_FEED_ARCHS` 변수는 다음과 같습니다.
      `local.conf` 파일에 정의되어 있습니다.

         PACKAGE_FEED_URIS = "https://example.com/packagerepos/release \
                              https://example.com/packagerepos/updates"
         PACKAGE_FEED_BASE_PATHS = "rpm rpm-dev"
         PACKAGE_FEED_ARCHS = "all core2-64"

      이러한 설정으로 인해 생성되는 패키지 피드는 다음과 같습니다.

      .. 코드 블록:: 없음

         https://example.com/packagerepos/release/rpm/all
         https://example.com/packagerepos/release/rpm/core2-64
         https://example.com/packagerepos/release/rpm-dev/all
         https://example.com/packagerepos/release/rpm-dev/core2-64
         https://example.com/packagerepos/updates/rpm/all
         https://example.com/packagerepos/updates/rpm/core2-64
         https://example.com/packagerepos/updates/rpm-dev/all
         https://example.com/packagerepos/updates/rpm-dev/core2-64

### `PACKAGE_FEED_BASE_PATHS`

      패키지 피드 URI를 구성할 때 사용되는 기본 경로를 지정합니다.
      `PACKAGE_FEED_BASE_PATHS` 변수는 중간 부분을 구성합니다.
      OpenEmbedded 빌드 시스템에서 사용하는 패키지 피드 URI입니다. 기본 경로
      `PACKAGE_FEED_URIS` 사이에 있습니다.
      및 `PACKAGE_FEED_ARCHS` 변수.

      다음 예시를 고려해 보세요. 여기서 `PACKAGE_FEED_URIS`는 다음과 같습니다.
      `PACKAGE_FEED_BASE_PATHS` 및 `PACKAGE_FEED_ARCHS` 변수는 다음과 같습니다.
      `local.conf` 파일에 정의되어 있습니다.

         PACKAGE_FEED_URIS = "https://example.com/packagerepos/release \
                              https://example.com/packagerepos/updates"
         PACKAGE_FEED_BASE_PATHS = "rpm rpm-dev"
         PACKAGE_FEED_ARCHS = "all core2-64"

      이러한 설정으로 인해 생성되는 패키지 피드는 다음과 같습니다.

      .. 코드 블록:: 없음

         https://example.com/packagerepos/release/rpm/all
         https://example.com/packagerepos/release/rpm/core2-64
         https://example.com/packagerepos/release/rpm-dev/all
         https://example.com/packagerepos/release/rpm-dev/core2-64
         https://example.com/packagerepos/updates/rpm/all
         https://example.com/packagerepos/updates/rpm/core2-64
         https://example.com/packagerepos/updates/rpm-dev/all
         https://example.com/packagerepos/updates/rpm-dev/core2-64

### `PACKAGE_FEED_URIS`

      패키지 피드 URI의 앞부분을 지정합니다.
      OpenEmbedded 빌드 시스템. 각 최종 패키지 피드 URI는 다음과 같이 구성됩니다.
      `PACKAGE_FEED_URIS`,
      `PACKAGE_FEED_BASE_PATHS` 및
      `PACKAGE_FEED_ARCHS` 변수.

      다음 예시를 고려해 보세요. 여기서 `PACKAGE_FEED_URIS`는 다음과 같습니다.
      `PACKAGE_FEED_BASE_PATHS` 및 `PACKAGE_FEED_ARCHS` 변수는 다음과 같습니다.
      `local.conf` 파일에 정의되어 있습니다.

         PACKAGE_FEED_URIS = "https://example.com/packagerepos/release \
                              https://example.com/packagerepos/updates"
         PACKAGE_FEED_BASE_PATHS = "rpm rpm-dev"
         PACKAGE_FEED_ARCHS = "all core2-64"

      이러한 설정으로 인해 생성되는 패키지 피드는 다음과 같습니다.

      .. 코드 블록:: 없음

         https://example.com/packagerepos/release/rpm/all
         https://example.com/packagerepos/release/rpm/core2-64
         https://example.com/packagerepos/release/rpm-dev/all
         https://example.com/packagerepos/release/rpm-dev/core2-64
         https://example.com/packagerepos/updates/rpm/all
         https://example.com/packagerepos/updates/rpm/core2-64
         https://example.com/packagerepos/updates/rpm-dev/all
         https://example.com/packagerepos/updates/rpm-dev/core2-64

### `PACKAGE_INSTALL`

      패키지 관리자에게 전달된 최종 패키지 목록은 다음과 같습니다.
      이미지에 설치합니다.

      패키지 관리자가 모든 패키지의 실제 설치를 제어하기 때문입니다.
      `PACKAGE_INSTALL`을 사용하여 전달되는 패키지 목록은 다음과 같습니다.
      실제로 설치된 패키지의 최종 목록이 아닙니다.
      해당 변수는 이미지 생성 코드 내부에 있습니다. 따라서,
      일반적으로는 다음을 사용해야 합니다.
      `IMAGE_INSTALL` 변수를 지정합니다.
      설치용 패키지. 단, 다음과 같은 경우에는 예외입니다.
      :ref:`core-image-minimal-initramfs <ref-manual/images:images>`
      이미지. 초기 RAM 파일 시스템(Initramfs) 이미지를 사용할 때,
      `PACKAGE_INSTALL` 변수를 사용하십시오. 생성 방법에 대한 자세한 내용은 다음을 참조하십시오.
      Initramfs에 대한 자세한 내용은 ":ref:dev-manual/building:building an initial ram filesystem (Initramfs) image" 섹션을 참조하십시오.
      Yocto 프로젝트 개발 작업 매뉴얼에 있습니다.

### `PACKAGE_INSTALL_ATTEMPTONLY`

      OpenEmbedded 빌드 시스템이 시도할 패키지 목록을 지정합니다.
      이미지 생성 시 설치해야 하는 패키지입니다. 나열된 패키지 중 하나라도 설치에 실패하면 문제가 발생할 수 있습니다.
      설치 과정에서 빌드 시스템은 오류를 발생시키지 않습니다. 이 변수는
      일반적으로 사용자가 정의하는 것이 아닙니다.

### `PACKAGE_PREPROCESS_FUNCS`

      사전 처리를 위해 실행되는 함수 목록을 지정합니다.
      파일을 분할하기 전의 `PKGD` 디렉토리
      개별 패키지로.

### `PACKAGE_WRITE_DEPS`

      설치 후 필요한 종속성 목록을 지정합니다.
      네이티브/크로스 툴에 대한 사전 설치 스크립트. 만약 당신의
      설치 후 또는 설치 전 스크립트는 루트 파일 시스템에서 실행될 수 있습니다.
      대상에 의존하는 것이 아니라 생성 시간에 의존하며, 네이티브 도구에 따라 달라집니다.
      실행하려면 도구 목록을 작성해야 합니다.
      `PACKAGE_WRITE_DEPS`.

      설치 후 스크립트 실행에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`dev-manual/new-recipe:post-installation scripts`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `PACKAGECONFIG`

      이 변수는 특정 기능을 활성화 또는 비활성화하는 수단을 제공합니다.
      레시피별로 설정 가능합니다. `PACKAGECONFIG` 블록은 다음과 같이 정의됩니다.
      레시피에서 기능을 지정한 다음 기능을 정의하는 인수를 지정하면 레시피가 생성됩니다.
      기능 동작. 다음은 기본 블록 구조입니다(분할됨).
      가독성을 위해 여러 줄로 표시했습니다.):

         PACKAGECONFIG ??= "f1 f2 f3 ..."
         PACKAGECONFIG[f1] = "\
             --with-f1, \
             --f1 제외, \
             f1용 빌드 종속성, \
             f1의 런타임 종속성, \
             f1에 대한 런타임 권장 사항, \
             packageconfig-conflicts-for-f1"
         PACKAGECONFIG[f2] = "\
              ...그리고 계속해서...

      `PACKAGECONFIG` 변수 자체는 공백으로 구분된 값을 지정합니다.
      활성화할 기능 목록입니다. 다음 기능을 사용하면 됩니다.
      최대 6개의 옵션을 제공하여 각 기능의 동작 방식을 결정합니다.
      순서에 따라 달라지는 인수는 쉼표로 구분됩니다.
      원하는 인수는 생략할 수 있지만 구분 쉼표는 반드시 유지해야 합니다.
      순서는 중요하며 다음 사항을 명시합니다.

      #. `PACKAGECONFIG_CONFARGS`에 추가해야 하는 추가 인수
         해당 기능이 활성화된 경우.

      #. `PACKAGECONFIG_CONFARGS`에 추가해야 하는 추가 인수
         해당 기능이 비활성화된 경우.

      #. 추가 빌드 종속성(DEPENDS)
         해당 기능이 활성화된 경우 추가되어야 합니다.

      #. 추가 런타임 종속성(RDEPENDS)
         해당 기능이 활성화된 경우 추가되어야 합니다.

      #. 추가 런타임 권장 사항
         (`RRECOMMENDS`)는 다음과 같은 경우에 추가되어야 합니다.
         해당 기능이 활성화되어 있습니다.

      #. 충돌하는 (즉, 상호 배타적인) `PACKAGECONFIG`
         이 기능에 대한 설정입니다.

      다음은 패키지 구성(PACKAGECONFIG) 블록의 일부입니다.
      `librsvg` 레시피입니다. 이 예에서 기능은 `gtk`이며, 이는 다음과 같습니다.
      기능의 동작을 결정하는 세 가지 인자:

         PACKAGECONFIG[gtk] = "--with-gtk3,--without-gtk3,gtk+3"

      그만큼
      `--with-gtk3` 및 `gtk+3` 인수는 해당 기능이 다음과 같은 경우에만 적용됩니다.
      활성화됩니다. 이 경우 구성에 `--with-gtk3`가 추가됩니다.
      스크립트 인자 목록과 `gtk+3`이 `DEPENDS`에 추가되었습니다.
      반면에, 예를 들어 ``.bbappend``를 통해 해당 기능이 비활성화된 경우
      다른 레이어에 있는 파일의 경우 두 번째 인수 `--without-gtk3`는 다음과 같습니다.
      대신 구성 스크립트에 추가되었습니다.

      이전에 설명한 기본 `PACKAGECONFIG` 구조는 여전히 유효합니다.
      블록을 생성하든 변경하든 상관없이.
      블록을 만들 때는 레시피 안에 있는 구조를 사용하세요.

      기존의 `PACKAGECONFIG` 블록을 변경하려면 다음과 같이 하면 됩니다.
      그러니까 두 가지 방법 중 하나입니다:

      - *추가 파일:* 라는 이름의 추가 파일을 생성합니다.
         레이어에 ``recipename.bbappend``를 추가하고 값을 재정의하세요.
         `PACKAGECONFIG`. 완전히 재정의하거나
         변하기 쉬운::

            패키지 구성 = "f4 f5"

         또는 변수를 바로 추가해도 됩니다.

            패키지 구성: 추가 = " f4"

      - *설정 파일:* 이 방법은 설정을 변경하는 것과 동일합니다.
         `local.conf` 파일을 수정하지 않는 한, 추가 파일을 통한 차단은 불가능합니다.
         또는 ``mydistro.conf`` 파일. 이전의 파일 추가 방식과 동일합니다.
         설명된 대로 변수를 완전히 재정의할 수 있습니다.

            패키지 구성: pn-recipename = "f4 f5"

         또는 변수를 직접 수정할 수도 있습니다.

            PACKAGECONFIG:append:pn-recipename = " f4"

      다음은 systemd 서비스를 사용하는 `ref-classes-cmake` 레시피의 예입니다.
      여기서 `PACKAGECONFIG`는 systemd 서비스를 변환하는 데 사용됩니다.
      `PACKAGECONFIG` 명령어를 통해 쉽게 활성화 또는 비활성화할 수 있는 기능으로 변경합니다.

         example.c
         예시.서비스
         CMakeLists.txt

      ``CMakeLists.txt`` 파일에는 다음 내용이 포함되어 있습니다::

         if(WITH_SYSTEMD)
            install(FILES ${PROJECT_SOURCE_DIR}/example.service DESTINATION /etc/systemd/systemd)
         endif(WITH_SYSTEMD)

      `example.service`를 설치하려면 다음이 필요합니다.
      `cmake` 명령에 `-DWITH_SYSTEMD=ON`이 전달되는지 확인하십시오.
      실행. ``CMakeLists.txt`` 파일이 있는 레시피는 일반적으로 다음 설정을 상속합니다.
      :ref:`ref-classes-cmake` 클래스는 ``cmake``를 실행합니다.
      `EXTRA_OECMAKE`는 `PACKAGECONFIG_CONFARGS`가 될 것입니다.
      추가됨. 이제 `PACKAGECONFIG_CONFARGS`가 무엇인지 알게 되었습니다.
      첫 번째 요소 또는 두 번째 요소로 자동으로 채워집니다.
      `PACKAGECONFIG` 플래그 값에 대한 레시피는 다음과 같습니다.

         상속 cmake
         PACKAGECONFIG = "systemd"
         PACKAGECONFIG[systemd] = "-DWITH_SYSTEMD=ON,-DWITH_SYSTEMD=OFF"

      이 레시피의 참고 사항은 실제로 `systemd`가 `INIT_MANAGER`로 사용되고 있는지 확인하는 것입니다.
      아니면 말고::

         PACKAGECONFIG = "${@'systemd' if d.getVar('INIT_MANAGER') == 'systemd' else ''}"

### `PACKAGECONFIG_CONFARGS`

      공백으로 구분된 구성 옵션 목록이 생성되었습니다.
      `PACKAGECONFIG` 설정.

      :ref:`ref-classes-autotools` 및 :ref:`ref-classes-cmake`와 같은 클래스
      `PACKAGECONFIG_CONFARGS`를 사용하여 `PACKAGECONFIG` 옵션을 전달하세요.
      `configure`와 `cmake`를 각각 사용하세요. 사용 중인 경우
      `PACKAGECONFIG`이지만, 이를 처리하는 클래스는 아닙니다.
      :ref:`ref-tasks-configure` 작업을 사용하려면 다음을 사용해야 합니다.
      `PACKAGECONFIG_CONFARGS`를 적절하게 사용하십시오.

### `PACKAGEGROUP_DISABLE_COMPLEMENTARY`

      `ref-classes-packagegroup` 클래스를 상속받는 레시피의 경우, 설정
      `PACKAGEGROUP_DISABLE_COMPLEMENTARY`를 "1"로 설정하면
      일반적인 보조 패키지(예: ``-dev``, ``-dbg`` 등)
      `packagegroup` 레시피에 의해 자동으로 생성되어서는 안 됩니다.
      이는 기본 동작입니다.

### `PACKAGES`

      레시피가 생성하는 패키지 목록입니다. 기본값은 다음과 같습니다.
      수행원::

         ${PN}-src ${PN}-dbg ${PN}-staticdev ${PN}-dev ${PN}-doc ${PN}-locale ${PACKAGE_BEFORE_PN} ${PN}

      패키징 중에 :ref:`ref-tasks-package` 작업이 실행됩니다.
      `PACKAGES`를 거쳐 `FILES`를 사용합니다.
      각 패키지에 해당하는 변수를 사용하여 파일을 할당합니다.
      패키지입니다. 파일이 두 개 이상에 대해 `FILES` 변수와 일치하는 경우
      패키지 목록(PACKAGES)에 있는 패키지는 가장 먼저 할당됩니다.
      (가장 왼쪽에 있는) 패키지입니다.

      변수 목록에 있는 패키지 중 비어 있는 패키지(즉, 아무것도 없는 패키지)
      ``FILES:``\ pkg의 패턴은 pkg에 의해 설치된 모든 파일과 일치합니다.
      :ref:`ref-tasks-install` 작업이 생성되지 않습니다.
      세대가 강제로 이루어지지 않는 한
      `ALLOW_EMPTY` 변수.

### `PACKAGES_DYNAMIC`

      레시피가 런타임 종속성을 충족한다는 약속
      다른 레시피에서 찾을 수 있는 선택적 모듈입니다.
      `PACKAGES_DYNAMIC`은 실제로 종속성을 충족시키지 않습니다.
      단지 만족해야 한다는 것만 명시합니다. 예를 들어, 어려운 상황이라면,
      다른 런타임 종속성(RDEPENDS)
      패키지는 빌드 시 `PACKAGES_DYNAMIC` 옵션을 통해 충족됩니다.
      변수이지만 모듈 이름이 있는 패키지는 실제로 존재하지 않습니다.
      만약 한 패키지가 생성되면 다른 패키지는 손상될 것입니다. 따라서, 만약 시도한다면
      해당 패키지를 이미지에 포함시키려면 종속성이 추가됩니다.
      포장 시스템 오류 발생
      :ref:`ref-tasks-rootfs` 작업.

      일반적으로, 그러한 상황이 발생할 가능성이 있다면
      생성되지 않은 패키지는 종속성 없이도 유효합니다.
      만족하셨다면 `RRECOMMENDS`를 사용하세요.
      `RDEPENDS` 대신 (소프트 런타임 종속성)을 사용합니다.

      `PACKAGES_DYNAMIC` 변수를 사용하는 방법의 예시는 다음과 같습니다.
      패키지를 분할하고 있습니다. 다음을 참조하세요.
      ":ref:`dev-manual/packages: 선택적 모듈 패키징 처리`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `PACKAGESPLITFUNCS`

      추가 분할을 수행하기 위해 실행되는 함수 목록을 지정합니다.
      파일을 개별 패키지로 나눕니다. 레시피는 이 앞에 추가하거나 추가할 수 있습니다.
      변수를 지정하거나 `populate_packages` 함수 앞에 추가하여
      추가 패키지 분할을 수행합니다. 어느 경우든 함수는
      `PACKAGES`를 설정해야 합니다.
      `FILES`, `RDEPENDS` 및
      다른 포장 변수들을 적절하게 조정하여 작업을 수행해야 합니다.
      원하는 분할.

### `PARALLEL_MAKE`

      빌드 도구 명령(``make``)에 전달되는 추가 옵션
      ``ninja`` 또는 Go 언어용 빌드 엔진과 같은 보다 구체적인 빌드 엔진)
      `ref-tasks-compile` 작업 중에 병렬 컴파일을 지정하려면
      로컬 빌드 호스트에서 사용됩니다. 이 변수는 일반적으로 "-j x" 형식입니다.
      여기서 x는 해당 엔진의 최대 병렬 스레드 수를 나타냅니다.
      실행 가능합니다.

      .. 메모::

         `make`로 컴파일된 소프트웨어의 경우, `PARALLEL_MAKE`를 사용하려면
         효과적으로 작동하려면 `make`는 다음과 같이 호출되어야 합니다.
         ``${``\ `EXTRA_OEMAKE`\ ``}``. 간단한
         이를 보장하는 방법은 ``oe_runmake`` 함수를 사용하는 것입니다.

      기본적으로 OpenEmbedded 빌드 시스템은 이 값을 자동으로 설정합니다.
      이 변수는 빌드 시스템에서 사용하는 코어 수와 같아야 합니다.

      .. 메모::

         소프트웨어 개발 중에 종속성 문제가 발생하면
         경쟁 조건을 유발하는 `:ref:ref-tasks-compile` 작업의 경우, 해당 문제를 해결할 수 있습니다.
         임시 해결책으로 레시피 내의 `PARALLEL_MAKE` 변수를 사용하세요.
         인종 차별 문제 해결에 대한 정보는 다음을 참조하십시오.
         ":ref:`dev-manual/debugging:debugging parallel make races`"
         Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

      단일 소켓 시스템(즉, CPU가 하나인 시스템)의 경우, 다음 작업은 필요하지 않습니다.
      빌드 시 최적의 병렬 처리를 얻으려면 이 변수를 재정의하십시오.
      하지만 여러 개의 물리적 장치를 사용하는 매우 큰 시스템을 운영하는 경우에는 상황이 달라질 수 있습니다.
      CPU를 사용하는 경우, `PARALLEL_MAKE` 변수가 올바른지 확인해야 합니다.
      "-j 20"보다 높게 설정하지 마십시오.

      빌드 속도 향상에 대한 자세한 내용은 다음을 참조하세요.
      ":ref:`dev-manual/speeding-up-build:빌드 속도 향상`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

      빌드 중에 사용되는 리소스를 제한하는 방법에 대한 자세한 내용은 다음을 참조하세요.
      Yocto 프로젝트의 :doc:`/dev-manual/limiting-resources` 섹션
      개발 작업 매뉴얼.

### `PARALLEL_MAKEINST`

      빌드 도구 설치 명령에 전달되는 추가 옵션
      (``make install``, ``ninja install`` 또는 더 구체적인 명령어)
      :ref:`ref-tasks-install` 작업 중에 지정하기 위해
      병렬 설치. 이 변수는 기본적으로 다음 값으로 설정됩니다.
      `PARALLEL_MAKE`.

      .. 메모::

         `make`로 컴파일된 소프트웨어의 경우, `PARALLEL_MAKEINST`를 실행하려면
         효과적으로 작동하려면 `make`는 다음과 같이 호출되어야 합니다.
         ``${``\ `EXTRA_OEMAKE`\ ``}``. 간단한
         이를 보장하는 방법은 ``oe_runmake`` 함수를 사용하는 것입니다.

         소프트웨어 개발 중에 종속성 문제가 발생하면
         경쟁 조건을 유발하는 `:ref:`ref-tasks-install` 작업의 경우,
         레시피 내의 ``PARALLEL_MAKEINST` 변수를 지우십시오.
         임시 해결책입니다. 경쟁 조건 해결에 대한 자세한 내용은 다음을 참조하세요.
         ":ref:`dev-manual/debugging:debugging parallel make races`"
         Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

### `PATCHRESOLVE`

      패치가 실패했을 때 수행할 작업을 결정합니다. 이 값을 설정할 수 있습니다.
      변수를 "noop" 또는 "user" 두 값 중 하나로 설정합니다.

      기본값인 "noop"은 빌드가 실패하도록 만듭니다.
      OpenEmbedded 빌드 시스템에서 패치를 성공적으로 적용할 수 없습니다. 설정
      "user"라는 값은 빌드 시스템이 셸을 실행하도록 합니다.
      올바른 위치로 안내하여 수동으로 문제를 해결할 수 있도록 도와줍니다.
      갈등.

      이 변수를 ``local.conf`` 파일에 설정하세요.

### `PATCHTOOL`

      레시피에 패치를 적용하는 데 사용되는 유틸리티를 지정합니다.
      :ref:`ref-tasks-patch` 작업입니다. 다음 중 하나를 지정할 수 있습니다.
      세 가지 유틸리티: "patch", "quilt", 또는 "git". 기본 유틸리티는 다음과 같습니다.
      퀼트 원조 레시피 자체를 제외하고는 "퀼트"입니다. 왜냐하면
      퀼트 도구는 퀼트 네이티브가 개발 중인 시점에는 사용할 수 없습니다.
      패치된 경우 "패치"를 사용합니다.

      다른 패치 도구를 사용하려면 변수를 설정하십시오.
      다음 중 하나를 사용하여 레시피를 작성하세요::

         PATCHTOOL = "패치"
         PATCHTOOL = "퀼트"
         PATCHTOOL = "git"

### `PE`

      레시피의 시점입니다. 기본적으로 이 변수는 설정되지 않았습니다.
      이 변수는 버전 관리 체계에서 업그레이드를 가능하게 하는 데 사용됩니다.
      일부 변경 사항이 이전 버전과 호환되지 않습니다.

      `PE`는 `PKGE` 변수의 기본값입니다.

### `PEP517_WHEEL_PATH`

      `ref-classes-python_pep517`을 상속하는 레시피에서 사용될 때
      클래스는 `dist/`(distribution의 줄임말)로 가는 경로를 나타냅니다.
      바이너리 아카이브 ``wheel``이 빌드되었습니다.

### `PERSISTENT_DIR`

      BitBake 설명서에서 `bitbake:PERSISTENT_DIR`을 참조하십시오.

### `PF`

      레시피 또는 패키지 이름을 지정하고 모든 버전을 포함합니다.
      개정 번호(예: ``glibc-2.13-r20+svnr15508/`` 및
      ``bash-4.2-r1/``). 이 변수는 다음으로 구성됩니다.
      ${`PN`}-${`EXTENDPE`}${`PV`}-${`PR`}

### `PIXBUF_PACKAGES`

      :ref:`ref-classes-pixbufcache`를 상속할 때
      클래스에서 이 변수는 픽스버퍼를 포함하는 패키지를 식별합니다.
      ``gdk-pixbuf``와 함께 사용되는 로더입니다. 기본적으로,
      :ref:`ref-classes-pixbufcache` 클래스는 다음을 가정합니다.
      로더는 레시피의 메인 패키지에 있습니다(예:
      ``${``\ `PN`\ ``}``). 이 변수를 사용하세요.
      필요한 로더는 메인 패키지가 아닌 다른 패키지에 있습니다.

### `PKG`

      OpenEmbedded 빌드 결과로 생성되는 패키지의 이름입니다.
      체계.

      .. 메모::

         ``PKG` 변수를 사용할 때는 패키지 이름을 재정의해야 합니다.

      예를 들어, :ref:`ref-classes-debian` 클래스가 출력 이름을 변경할 때
      패키지를 지정하려면 ``PKG:packagename``을 설정하면 됩니다.

### `PKG_CONFIG_PATH`

      현재 빌드 컨텍스트에 대한 ``pkg-config`` 파일의 경로입니다.
      ``pkg-config``는 환경 변수에서 이 변수를 읽어옵니다.

### `PKGD`

      패키징할 파일의 대상 디렉토리를 지정합니다.
      그것들은 개별 패키지로 분리되어 있습니다. 이 디렉터리는 기본적으로 다음과 같습니다.
      다음::

         ${WORKDIR}/패키지

      이 기본 설정을 변경하지 마십시오.

### `PKGDATA_DIR`

      생성된 데이터를 저장하는 공유된 전역 상태 디렉터리를 가리킵니다.
      포장 과정 중에. 포장 과정 중에,
      :ref:`ref-tasks-packagedata` 작업 패키지 데이터
      각 레시피마다 하나씩 설치하고 이 임시 공유 공간에 배치합니다.
      이 디렉터리는 기본적으로 다음과 같이 설정되어 있는데, 이렇게 설정하면 안 됩니다.
      변화::

         ${STAGING_DIR_HOST}/pkgdata

      이 데이터가 어떻게 사용되는지에 대한 예시는 다음을 참조하십시오.
      ":ref:`개요-매뉴얼/개념:자동으로 추가된 런타임 종속성`"
      Yocto 프로젝트 개요 및 개념 설명서의 해당 섹션과
      ":ref:`dev-manual/debugging:``oe-pkgdata-util```을 사용하여 패키지 정보 보기"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션을 참조하십시오. 자세한 내용은
      공유되는 전역 상태 디렉터리에 대한 정보는 다음을 참조하십시오.
      `스테이징_디렉터_호스트`.

### `PKGDEST`

      패키징될 파일들의 상위 디렉토리를 가리킵니다.
      개별 패키지로 분리되었습니다. 이 디렉터리는 기본적으로 다음과 같습니다.
      다음::

         ${WORKDIR}/packages-split

      이 디렉터리 아래에 빌드 시스템은 각 항목에 대한 디렉터리를 생성합니다.
      패키지는 `PACKAGES`에 지정되어 있습니다. 변경하지 마십시오.
      이것이 기본값입니다.

### `PKGDESTWORK`

      임시 작업 구역을 가리킵니다.
      :ref:`ref-tasks-package` 작업은 패키지 메타데이터를 저장합니다.
      `PKGDESTWORK` 위치는 기본적으로 다음과 같습니다.

         ${WORKDIR}/pkgdata

      이 기본 설정을 변경하지 마십시오.

      :ref:`ref-tasks-packagedata` 작업은 다음을 복사합니다.
      `PKGDESTWORK`의 패키지 메타데이터
      `PKGDATA_DIR`을 사용하여 전역적으로 사용할 수 있도록 합니다.

### `PKGE`

      레시피에 의해 빌드된 패키지의 에포크입니다. 기본값은 `PKGE`입니다.
      `PE`로 설정되어 있습니다.

### `PKGR`

      레시피에 의해 빌드된 패키지의 버전입니다. 기본적으로,
      `PKGR`이 `PR`로 설정되었습니다.

### `PKGV`

      레시피에 의해 빌드된 패키지 버전입니다. 기본값은 다음과 같습니다.
      `PKGV`가 `PV`로 설정되었습니다.

      `PV`에 `+` 기호가 포함되어 있으면 소스 제어 정보가 표시됩니다.
      패키징 단계 후반에 `PKGV`에 포함됩니다. 자세한 내용은 다음을 참조하세요.
      자세한 내용은 Yocto의 :doc:`/dev-manual/external-scm` 섹션을 참조하십시오.
      프로젝트 개발 작업 매뉴얼.

      .. 경고::

         소스 제어 정보는 후기 단계에 포함되기 때문에
         :ref:`ref-classes-package` 클래스는 BitBake에서 볼 수 없습니다.
         `bitbake -e` 또는 `bitbake-getvar` 명령어를 사용하여 환경을 설정하십시오. 대신, 다음에
         패키지 빌드가 완료되면 다음 명령어를 통해 버전 정보를 확인할 수 있습니다.
         ``oe-pkgdata-util package-info <패키지 이름>``을 참조하세요.
         :ref:`dev-manual/debugging:패키지 정보 보기
         Yocto 프로젝트 개발 작업의 ``oe-pkgdata-util``` 섹션
         ``oe-pkgdata-util``에 대한 자세한 내용은 설명서를 참조하십시오.


### `PN`

      이 변수는 상황에 따라 두 가지 별개의 기능을 가질 수 있습니다.
      맥락: 레시피 이름 또는 결과 패키지 이름.

      `PN`은 파일 컨텍스트에서 사용되는 레시피 이름을 나타냅니다.
      OpenEmbedded 빌드 시스템을 입력으로 사용하여 패키지를 생성합니다. 패키지 이름은 다음과 같습니다.
      일반적으로 레시피 파일 이름에서 추출됩니다. 예를 들어,
      레시피 이름이 ``expat_2.0.1.bb``인 경우 `PN`의 기본값은 다음과 같습니다.
      "해외 거주자"가 될 것입니다.

      해당 변수는 파일 컨텍스트에서 패키지 이름을 참조합니다.
      OpenEmbedded 빌드 시스템에 의해 생성되거나 생산되었습니다.

      해당되는 경우, `PN` 변수에는 특수 접미사도 포함됩니다.
      또는 접두사. 예를 들어, ``bash``를 사용하여 패키지를 빌드하는 경우
      네이티브 머신, `PN`은 ``bash-native``입니다. 빌드를 위해 ``bash``를 사용합니다.
      대상 및 Multilib용 패키지의 경우 `PN`은 ``bash``가 됩니다.
      그리고 각각 ``lib64-bash``입니다.

### `POPULATE_SDK_POST_HOST_COMMAND`

      OpenEmbedded 빌드가 완료되면 호출할 함수 목록을 지정합니다.
      시스템에서 SDK의 호스트 부분을 생성했습니다. 지정할 수 있습니다.
      함수들을 공백으로 구분하세요::

          POPULATE_SDK_POST_HOST_COMMAND += "함수"

      함수 내 명령에 SDK 경로를 전달해야 하는 경우,
      ``${SDK_DIR}``을 사용할 수 있으며, 이는 SDK에서 사용하는 상위 디렉터리를 가리킵니다.
      SDK 출력을 생성할 때 OpenEmbedded 빌드 시스템을 참조하십시오.
      자세한 내용은 `SDK_DIR` 변수를 참조하십시오.

### `POPULATE_SDK_POST_TARGET_COMMAND`

      OpenEmbedded 빌드가 완료되면 호출할 함수 목록을 지정합니다.
      시스템에서 SDK의 대상 부분을 생성했습니다. 지정할 수 있습니다.
      함수들을 공백으로 구분하세요::

         POPULATE_SDK_POST_TARGET_COMMAND += "함수"

      함수 내 명령에 SDK 경로를 전달해야 하는 경우,
      ``${SDK_DIR}``을 사용할 수 있으며, 이는 SDK에서 사용하는 상위 디렉터리를 가리킵니다.
      SDK 출력을 생성할 때 OpenEmbedded 빌드 시스템을 참조하십시오.
      자세한 내용은 `SDK_DIR` 변수를 참조하십시오.

### `PR`

      레시피 수정 사항입니다. 이 변수의 기본값은 다음과 같습니다.
      "r0". 이후 레시피 수정본에서는 일반적으로 다음과 같은 내용이 포함됩니다.
      "r1", "r2" 등의 값. `PV`가 증가하면,
      `PR`은 관례적으로 "r0"으로 재설정됩니다.

      .. 메모::

         OpenEmbedded 빌드 시스템은 `PR`의 도움을 필요로 하지 않습니다.
         레시피를 언제 다시 빌드해야 하는지 알기 위해 빌드 시스템은 해당 작업을 사용합니다.
         :ref:`체크섬 입력 <overview-manual/concepts:checksums (signatures)>`과 함께
         :ref:`스탬프 <structure-build-tmp-stamps>` 및
         :ref:`개요 매뉴얼/개념:공유 상태 캐시`
         메커니즘.

      `PR` 변수는 주로 패키지가 출시될 때 중요해집니다.
      관리자는 이미 빌드된 이미지에 패키지를 동적으로 설치합니다.
      이 경우 `PR`은 기본값입니다.
      `PKGR`은 패키지 관리자가 어떤 것을 구분하는 데 도움이 됩니다.
      여러 패키지가 있는 경우 해당 패키지는 가장 최근 패키지입니다.
      동일한 `PV`(즉, `PKGV`). 여러 패키지를 가진 구성 요소
      일반적으로 동일한 `PV`는 모든 패키지가 동일하게 설치됨을 의미합니다.
      업스트림 버전이지만, 이후 버전(PR) 패키지가 포함되어 있습니다.
      포장 관련 수정 사항.

      .. 메모::

         PR은 변경 사항이 없는 경우에는 늘릴 필요가 없습니다.
         패키지 내용 또는 메타데이터.

      PR을 수동으로 관리하는 것은 번거롭고 오류가 발생하기 쉽기 때문에,
      자동화된 솔루션이 있습니다. 다음을 참조하세요.
      ":ref:`dev-manual/packages:pr 서비스 사용`" 섹션
      자세한 내용은 Yocto 프로젝트 개발 작업 매뉴얼을 참조하십시오.

### `PREFERRED_PROVIDER`

      여러 레시피에서 동일한 재료를 사용하는 경우, 이 변수가 결정합니다.
      어떤 레시피가 선호되고, 따라서 해당 재료를 제공하는가 (즉,
      선호하는 공급자). 이 변수에는 항상 접미사를 붙여야 합니다.
      제공된 항목의 이름입니다. 그리고 변수를 다음과 같이 정의해야 합니다.
      선호하는 레시피 이름(`PN`). 일반적인 예는 다음과 같습니다.
      예::

         PREFERRED_PROVIDER_virtual/kernel ?= "linux-yocto"

      이전 예시에서는 여러 레시피가 "virtual/kernel"을 제공하고 있습니다.
      `PREFERRED_PROVIDER` 변수는 (`PN`)이라는 이름으로 설정됩니다.
      선호하는 레시피에 "virtual/kernel"을 입력하세요.

      다음은 더 많은 예시입니다.

         PREFERRED_PROVIDER_virtual/xserver = "xserver-xf86"
         PREFERRED_PROVIDER_virtual/libgl ?= "mesa"

      더 많은 정보를 원하시면
      자세한 내용은 ":ref:`dev-manual/new-recipe:using virtual providers`"를 참조하십시오.
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

      .. 메모::

         `PREFERRED_PROVIDER`와 함께 `virtual/\*` 항목을 사용하는 경우,
         해당 항목을 제공하지만 선택(정의)되지 않은 레시피
         `PREFERRED_PROVIDER`로 인해 빌드가 차단되는 경우가 있는데, 이는 일반적으로 발생합니다.
         이 메커니즘은 상호적으로 선택하도록 설계되었기 때문에 바람직합니다.
         독점 대체 공급업체.

### `PREFERRED_PROVIDERS`

      BitBake 설명서의 ``bitbake:PREFERRED_PROVIDERS`를 참조하십시오.

### `PREFERRED_RPROVIDER`

      `PREFERRED_RPROVIDER` 변수는 다음과 같이 작동합니다.
      `PREFERRED_PROVIDER` 변수이지만, 이는 특정 서비스를 제공하는 패키지를 나타냅니다.
      *런타임* 구성 요소. 런타임 공급자는 레시피에 선언되어 설정됩니다.
      특정 패키지에 대한 `RPROVIDES` 변수입니다.

      예를 들어::

         PREFERRED_RPROVIDER_virtual-x-terminal-emulator = "rxvt-unicode"

      이 명령문은 X 터미널 에뮬레이터의 런타임 공급자를 다음과 같이 설정합니다.
      ``rxvt-unicode``. ``rxvt-unicode`` 패키지는 런타임 제공자입니다.
      이 구성 요소는 ``rxvt-unicode`` 레시피가 다음을 설정했기 때문입니다.
      `RPROVIDES`는 ``rxvt-unicode`` (``${PN}``)에 대한 정의를 제공합니다.
      패키지::

         RPROVIDES:${PN} = "virtual-x-terminal-emulator"

      가상 제공자에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`dev-manual/new-recipe:using virtual providers`" 섹션의
      Yocto 프로젝트 개발 작업 매뉴얼.

### `PREFERRED_TOOLCHAIN`

      `PREFERRED_TOOLCHAIN` 변수는 사용할 툴체인을 선택합니다.
      레시피를 컴파일하는 중입니다. 이 변수는 전역적으로 재정의할 수 없습니다.
      대신, `PREFERRED_TOOLCHAIN_TARGET`의 값은 다음과 같습니다.
      `PREFERRED_TOOLCHAIN_NATIVE` 및 `PREFERRED_TOOLCHAIN_SDK`
      이 설정은 재정의되어야 합니다.

### `PREFERRED_TOOLCHAIN_NATIVE`

      이 변수는 컴파일에 사용되는 툴체인을 제어합니다.
      :ref:`ref-classes-native` 레시피.

      이 변수는 설정 파일에서 전역적으로 설정해야 합니다.

      자세한 내용은 `PREFERRED_TOOLCHAIN_TARGET`을 참조하십시오.
      이 변수에 대한 값입니다.

      지정된 툴체인을 지원하지 않는 레시피
      `PREFERRED_TOOLCHAIN_NATIVE`는 로컬에서 이를 재정의할 수 있습니다.
      `툴체인_네이티브`.

### `PREFERRED_TOOLCHAIN_SDK`

      이 변수는 컴파일에 사용되는 툴체인을 제어합니다.
      :ref:`ref-classes-nativesdk` 레시피.

      이 변수는 설정 파일에서 전역적으로 설정해야 합니다.

      자세한 내용은 `PREFERRED_TOOLCHAIN_TARGET`을 참조하십시오.
      이 변수에 대한 값입니다.

### `PREFERRED_TOOLCHAIN_TARGET`

      이 변수는 레시피 컴파일에 사용되는 툴체인을 제어합니다.
      대상 `MACHINE`의 아키텍처.

      현재 이 변수에 대해 가능한 값은 두 가지입니다.

      - :ref:`gcc <ref-classes-toolchain-gcc>` (기본값): GCC/Binutils 툴체인.
      - :ref:`clang <ref-classes-toolchain-clang>`: Clang/LLVM 툴체인.

      `PREFERRED_TOOLCHAIN_TARGET`를 사용하면 `ref-classes-base`가 생성됩니다.
      클래스는 정의된 툴체인 클래스 중 하나를 상속합니다.
      :oe_git:`meta/classes/toolchain
      </openembedded-core/tree/meta/classes/toolchain>`. 결과적으로 이것은
      해당 변수는 설정 파일에서 전역적으로 설정되어야 합니다.

      이 클래스들은 ``CC`와 같은 크로스 컴파일에 사용되는 명령어를 정의합니다.
      `CXX`, `LD` 등.

      지정된 툴체인을 지원하지 않는 레시피
      `PREFERRED_TOOLCHAIN_TARGET`는 로컬에서 이를 재정의할 수 있습니다.
      :용어:`툴체인`.

### `PREFERRED_VERSION`

      레시피에 여러 버전이 있는 경우 이 변수
      어떤 버전에 우선순위를 부여할지 결정합니다. 항상
      선택하려는 `PN` 접미사를 변수에 추가하세요(`python` 등).
      아래 첫 번째 예시와 같이, `PV`를 지정해야 합니다.
      따라서 (예시에서는 `3.4.0`).

      `PREFERRED_VERSION` 변수는 제한적인 와일드카드 사용을 지원합니다.
      "%" 문자를 통해 연결할 수 있습니다. 이 문자를 사용하여 모든 항목과 일치시킬 수 있습니다.
      문자 수는 버전을 지정할 때 유용할 수 있습니다.
      변경될 가능성이 있는 긴 개정 번호를 포함하고 있습니다. 다음은 그 예입니다.
      두 가지 예시:

         선호 버전_파이썬 = "3.4.0"
         선호 버전_linux-yocto = "5.0%"

      .. 메모::

         "%" 문자의 사용은 제한적이며, 오직 문단의 끝에만 사용할 수 있습니다.
         문자열입니다. 다른 문자열에서는 와일드카드 문자를 사용할 수 없습니다.
         문자열의 위치.

      지정된 버전은 `PV`와 일치하지만, 이는 그렇지 않습니다.
      레시피 파일 이름의 버전 부분과 반드시 ​​일치해야 하는 것은 아닙니다.

      `foo_git.bb`라는 이름의 레시피를 선택하고 싶은데, 그 레시피에 ``PV`가 포함되어 있다면...
      ```PREFERRED_VERSION_foo``를 설정하여 ``1.2.3+git``으로 설정할 수 있습니다.
      ``1.2.3%``로 변경합니다(즉, ``PREFERRED_VERSION_foo``를 ``git``로 설정하기만 하면 됩니다).
      레시피 이름이 아닌 다른 이름이 사용되므로 작동하지 않습니다.
      :용어:`PV` 정의).

      때때로 `PREFERRED_VERSION` 변수는 다음과 같이 설정될 수 있습니다.
      변경하기 어려운 방식으로 구성 파일을 관리할 수 있습니다.
      `OVERRIDES`를 사용하여 기기별 설정을 지정합니다.
      재정의합니다. 다음은 예시입니다.

         선호 버전_linux-yocto:qemux86 = "5.0%"

      권장하지는 않지만, 최악의 경우 다음과 같은 방법도 사용할 수 있습니다.
      "forcevariable" 오버라이드는 가능한 가장 강력한 오버라이드입니다.
      다음은 예시입니다.

         PREFERRED_VERSION_linux-yocto:forcevariable = "5.0%"

      .. 메모::

         ``:forcevariable`` 오버라이드는 특별히 처리되지 않습니다. 이 오버라이드는
         `OVERRIDES`의 기본값에 "forcevariable"이 포함되어 있기 때문에 작동하는 것입니다.

      지정된 버전의 레시피를 사용할 수 없는 경우 경고 메시지가 표시됩니다.
      메시지가 표시됩니다. 이 기능을 원하시면 `REQUIRED_VERSION`을 참조하세요.
      오류가 되는 것입니다.

### `PREMIRRORS`

      OpenEmbedded 빌드 시스템이 사용할 수 있는 추가 경로를 지정합니다.
      소스 코드를 가져옵니다. 빌드 시스템이 소스 코드를 검색할 때,
      먼저 로컬 다운로드 디렉토리를 시도합니다. 해당 위치에서 실패하면, 다음으로 넘어갑니다.
      빌드 시스템은 업스트림의 PREMIRRORS로 정의된 위치를 시도합니다.
      소스, 그리고 지정된 위치
      `MIRRORS` 순서대로.

      `PREMIRRORS`의 기본값은 다음과 같이 정의됩니다.
      코어 메타데이터 레이어의 ``meta/classes-global/mirrors.bbclass`` 파일입니다.

      일반적으로 빌드 시스템을 위한 특정 서버를 추가할 수 있습니다.
      다른 시도보다 먼저 다음과 같은 내용을 추가하여 시도해 보세요.
      ``local.conf`` 구성 파일은
      `디렉토리 빌드`::

         PREMIRRORS:prepend = "\
             git://.*/.* &YOCTO_DL_URL;/mirror/sources/ \
             ftp://.*/.* &YOCTO_DL_URL;/mirror/sources/ \
             http://.*/.* &YOCTO_DL_URL;/mirror/sources/ \
             https://.*/.* &YOCTO_DL_URL;/mirror/sources/"

      이러한 변화는 다음과 같은 결과를 초래합니다.
      Git, FTP, HTTP 및 HTTPS 요청을 가로채는 빌드 시스템 및
      ``http://`` 소스 미러로 연결하세요. 다음을 사용할 수 있습니다.
      로컬 디렉터리 또는 네트워크 공유를 가리키는 ``file://`` URL
      잘.

### `PRIORITY`

      패키지의 중요도를 나타냅니다.

      우선순위는 배포 정책의 일부로 간주됩니다.
      왜냐하면 특정 레시피의 중요성은 그 레시피를 사용하는 목적에 따라 달라지기 때문입니다.
      배포가 생성되는 방식입니다. 따라서 `PRIORITY`는 아닙니다.
      일반적으로 레시피 내에 설정되어 있습니다.

      ``PRIORITY`를 "필수", "표준", "추가" 등으로 설정할 수 있습니다.
      "선택 사항"이며, 이것이 기본값입니다.

### `PRIVATE_LIBS`

      레시피에 설치된 라이브러리 중 무시해야 할 라이브러리를 지정합니다.
      OpenEmbedded 빌드 시스템의 공유 라이브러리 리졸버에 의해.
      변수는 일반적으로 레시피로 빌드되는 소프트웨어에 사용됩니다.
      다른 곳에서 일반적으로 제공하는 라이브러리의 자체적인 개인 버전입니다.
      레시피. 이 경우, 패키지에 포함된 내용물은 원하지 않을 것입니다.
      다른 관련 없는 라이브러리에 대한 종속성으로 설정될 비공개 라이브러리
      대신 해당 패키지를 제공하는 패키지에 의존해야 하는 패키지
      라이브러리의 표준 버전입니다.

      이 변수에 지정된 라이브러리는 해당 라이브러리 이름으로 지정해야 합니다.
      파일 이름. 예를 들어, meta-browser의 Firefox 레시피에서::

         PRIVATE_LIBS = "libmozjs.so \
                         libxpcom.so \
                         libnspr4.so \
                         libxul.so \
                         libmozalloc.so \
                         libplc4.so \
                         libplds4.so"

      더 자세한 내용은 다음을 참조하십시오.
      ":ref:`개요-매뉴얼/개념:자동으로 추가된 런타임 종속성`"
      Yocto 프로젝트 개요 및 개념 설명서의 해당 섹션을 참조하십시오.

### `PROVIDES`

      특정 레시피를 알 수 있는 별칭 목록입니다.
      기본적으로 레시피 자체의 `PN`은 이미 암묵적으로 포함되어 있습니다.
      `PROVIDES` 목록을 제공하므로 언급할 필요가 없습니다.
      레시피에서 ``PROVIDES`를 사용하는 경우, 추가 정보는 자체적으로 제공됩니다.
      별칭은 레시피의 동의어이며, 만족스러운 결과를 얻는 데 유용할 수 있습니다.
      빌드 중 다른 레시피의 종속성은 지정된 대로 적용됩니다.
      `의존적입니다`.

      레시피의 `PROVIDES` 문 예시를 살펴보세요.
      파일 ``eudev_3.2.9.bb``::

         PROVIDES += "udev"

      `PROVIDES` 문
      결과적으로 "eudev" 레시피는 간단히 "udev"로도 사용할 수 있게 됩니다.

      .. 메모::

         레시피 자체의 레시피 이름(`PN`)은 항상 암묵적으로 앞에 추가됩니다.
         `PROVIDES`로 변환하는 것이므로 위 예시에서 "+="를 사용하는 것은 적절하지 않을 수 있습니다.
         혼동을 피하기 위해 반드시 필요한 조치이므로 권장합니다.

      다른 이름으로 레시피를 제공하는 것 외에도,
      `PROVIDES` 메커니즘은 가상 대상을 구현하는 데에도 사용됩니다.
      가상 대상은 특정 대상에 대응하는 이름입니다.
      기능(예: 리눅스 커널). 해당 기능을 제공하는 레시피
      해당 기능은 `PROVIDES`에 가상 대상을 나열합니다.
      해당 기능에 의존하는 레시피에는 다음이 포함될 수 있습니다.
      공급자 선택을 열어두기 위해 `DEPENDS`에 가상 대상을 지정합니다.

      일반적으로 가상 대상은 양식에 이름이 지정됩니다.
      "가상/함수"(예: "가상/커널"). 슬래시는 단순히 일부입니다.
      이름의 의미일 뿐이며 구문론적 의미는 없습니다.

      `PREFERRED_PROVIDER` 변수는 다음과 같습니다.
      가상 목표를 제공하는 특정 레시피를 선택하는 데 사용됩니다.

      .. 메모::

         가상 런타임 종속성(패키지)에 대한 상응하는 메커니즘
         존재합니다. 하지만 그 메커니즘은 어떤 특별한 것에 의존하지 않습니다.
         일반적인 변수 할당을 뛰어넘는 기능. 예를 들면,
         `VIRTUAL-RUNTIME_dev_manager <VIRTUAL-RUNTIME>`는 다음을 나타냅니다.
         `/dev` 디렉토리를 관리하는 구성 요소의 패키지입니다.

         런타임 종속성에 대한 "기본 제공자" 설정은 다음과 같습니다.
         설정 파일에 다음과 같은 할당을 사용하는 것만큼 간단합니다.

                 VIRTUAL-RUNTIME_dev_manager = "udev"


### `PRSERV_HOST`

      네트워크 기반 PR 서비스 호스트 및 포트입니다.

      `conf/templates/default/local.conf.sample.extended` 구성
      소스 디렉터리에 있는 파일은 PRSERV_HOST가 어떻게 작동하는지 보여줍니다.
      변수가 설정되었습니다::

         PRSERV_HOST = "localhost:0"

      당신은 반드시
      로컬 PR을 자동으로 시작하려면 변수를 설정하세요.
      `서비스 <dev-manual/packages:pr 서비스 작업>`을 사용할 수 있습니다.
      원격 PR 서비스를 사용하려면 `PRSERV_HOST`를 다른 값으로 설정하십시오.

### `PRSERV_UPSTREAM`

      이 변수는 로컬에 대한 업스트림 PR 서버를 지정하는 데 사용할 수 있습니다.
      연결할 PR 서버는 ``호스트:포트`` 형식입니다.

      이를 통해 상위 패키지에 로컬 수정 사항을 적용할 수 있습니다.

### `PSEUDO_IGNORE_PATHS`

      무시해야 할 경로 접두사를 쉼표로 구분하여 (공백 없이) 나열하십시오.
      파일 작업 모니터링 및 기록 시 가상으로 처리하여, 이를 방지하기 위해
      가상 컨텍스트 외부에 파일이 기록되는 문제 및
      의사 변수의 오버헤드를 줄입니다. 경로가 목록에 있는 접두사와 일치하는 경우 해당 경로는 무시됩니다.
      부분적인 디렉터리(또는 파일) 이름을 포함할 수 있습니다. 경로 접두사가 있는 경우
      `PSEUDO_IGNORE_PATHS`와 `PSEUDO_INCLUDE_PATHS` 모두에 존재합니다.
      `PSEUDO_INCLUDE_PATHS`가 우선합니다.

### `PSEUDO_INCLUDE_PATHS`

      포함해야 할 경로 접두사 목록을 쉼표로 구분하여 (공백 없이) 입력하십시오.
      파일 작업 모니터링 및 기록 시 가상으로 처리하여, 이를 방지하기 위해
      가상 컨텍스트 외부에 파일이 기록되는 문제 및
      :ref:`pseudo <overview-manual/concepts:Fakeroot 및 Pseudo>`의 오버헤드를 줄입니다.
      경로가 목록에 있는 접두사와 일치하는 경우 해당 경로가 포함되며, 다음을 포함할 수 있습니다.
      부분적인 디렉터리(또는 파일) 이름. 경로 접두사가 양쪽에 모두 있는 경우
      `PSEUDO_IGNORE_PATHS` 및 `PSEUDO_INCLUDE_PATHS`에서,
      `PSEUDO_INCLUDE_PATHS`가 우선합니다.


### `PTEST_ENABLED`

      :ref:`패키지 여부를 지정합니다.
      ptest를 사용하여 <test-manual/ptest:testing packages with ptest>`를 테스트합니다.
      레시피를 만들 때 해당 기능이 활성화됩니다. 설정하지 마십시오.
      이 변수를 직접 설정합니다. 패키지 테스트 빌드 활성화 및 비활성화
      빌드 시점에 "ptest"를 추가하거나 제거함으로써 이를 수행해야 합니다.
      출처) `배포 기능`.

### `PTEST_PYTEST_DIR`

      :ref:`ref-classes-ptest-python-pytest` 클래스 내에서,
      `PTEST_PYTEST_DIR` 변수는 소스 내의 경로를 나타냅니다.
      실행할 단위 테스트를 담고 있는 파이썬 패키지의 트리 구조
      `pytest <https://docs.pytest.org>`__ 프레임워크입니다. 이 값의 기본값은 다음과 같습니다.
      변수는 ``tests``입니다.

      더 자세한 내용은 다음을 참조하세요.
      :ref:`ref-classes-ptest-python-pytest` 클래스 문서입니다.

### `PV`

      레시피 버전. 버전은 일반적으로 다음에서 추출됩니다.
      레시피 파일 이름입니다. 예를 들어, 레시피 이름이 다음과 같을 경우
      ``expat_2.0.1.bb``인 경우 `PV`의 기본값은 "2.0.1"이 됩니다.
      일반적으로 레시피 내에서 PV(Private Value)는 재정의되지 않습니다. 단, 예외적인 경우는 제외합니다.
      소스 코드로부터 불안정한 (즉, 개발용) 버전을 빌드하는 것
      저장소(예: Git 또는 Subversion).

      `PV`는 `PKGV` 변수의 기본값입니다.

### `PYPI_PACKAGE`

      `ref-classes-pypi` 클래스를 상속할 때, 다음을 지정합니다.
      빌드할 `PyPI <https://pypi.org/>`__ 패키지 이름입니다. 기본값은 다음과 같습니다.
      `BPN`을 기준으로 설정됩니다("python-" 또는 "python3-"을 제거함).
      접두사가 있는 경우 이를 비활성화합니다. 단, 일부 패키지의 경우 설정해야 할 수 있습니다.
      패키지 이름과 일치하지 않을 경우 명시적으로 표시하십시오(예: 해당 위치에서)
      패키지 이름에 접두사, 밑줄, 대문자 등이 포함될 수 있습니다.

### `PYPI_PACKAGE_EXT`

      `ref-classes-pypi` 클래스를 상속할 때, 다음을 지정합니다.
      `PyPI`에서 패키지를 가져올 때 사용할 파일 확장자입니다.
      <https://pypi.org/>`__. 기본값은 ``tar.gz``입니다.

### `PYPI_SRC_URI`

      `ref-classes-pypi` 클래스를 상속할 때, 다음을 지정합니다.
      `pythonhosted <https://files.pythonhosted.org/>`__ URI의 전체 내용
      빌드할 패키지를 가져오는 중입니다. 기본값은 생성됨입니다.
      `PYPI_PACKAGE`, `PYPI_PACKAGE_EXT`를 기반으로 합니다.
      대부분의 레시피에서는 이 변수를 설정할 필요가 없습니다. 단, 특별한 경우가 있는 레시피에서는 예외적으로 설정할 수 있습니다.
      그들은 불안정한 (즉, 개발용) 버전을 만들고 있습니다.

### `PYTHON_ABI`

      `ref-classes-setuptools3`를 상속하는 레시피에서 사용될 때
      클래스는 현재 사용 중인 애플리케이션 바이너리 인터페이스(ABI)를 나타냅니다.
      파이썬의 경우 기본 ABI는 "m"입니다. 이 값을 설정할 필요는 없습니다.
      이 변수는 OpenEmbedded 빌드 시스템에서 설정해 주는 대로 사용됩니다.

      OpenEmbedded 빌드 시스템은 ABI를 사용하여 디렉터리를 구성합니다.
      파이썬 헤더 및 라이브러리를 설치할 때 사용되는 이름
      sysroot(예: ``.../python3.3m/...``).

### `QA_EMPTY_DIRS`

      비어 있어야 하는 디렉터리 목록을 지정합니다.
      패키징; 만약 `empty-dirs`가 `ERROR_QA`에 나타나거나
      `WARN_QA` 이러한 항목들을 검사하여 오류 또는 경고를 표시합니다.
      (각각) 생산될 것입니다.

      기본값 `QA_EMPTY_DIRS`는 다음과 같이 설정됩니다.
      :ref:`insane.bbclass <ref-classes-insane>`.

### `QA_EMPTY_DIRS_RECOMMENDATION`

      디렉터리를 비워야 하는 이유에 대한 권장 사항을 명시합니다.
      특정 디렉터리인 경우 오류 메시지에 포함될 내용입니다.
      해당 디렉터리에 파일이 포함되어 있는 것으로 확인되었습니다. 디렉터리 이름으로 덮어써야 합니다.
      일치하는 경로입니다.

      디렉터리에 대한 권장 사항이 지정되지 않은 경우 기본값이 사용됩니다.
      "하지만 비어있을 것으로 예상됩니다"라는 문구가 사용될 것입니다.

      예시 메시지는 '/dev'에 파일이 있는지 여부를 보여줍니다.

         QA_EMPTY_DIRS_RECOMMENDATION:/dev = "하지만 모든 장치는 런타임에 생성되어야 합니다."

### `RANLIB`

      :manpage:`ranlib <ranlib(1)>`을 실행하기 위한 최소 명령 및 인수입니다.

### `RCONFLICTS`

      패키지와 충돌하는 패키지 목록입니다. 패키지는 다음과 같습니다.
      충돌하는 패키지를 먼저 제거하지 않으면 설치되지 않습니다.

      다른 모든 패키지 제어 변수와 마찬가지로, 이러한 변수들은 항상 다음과 같이 사용해야 합니다.
      패키지 이름 재정의와 함께 사용됩니다. 다음은 예시입니다.

         RCONFLICTS:${PN} = "다른 충돌하는 패키지 이름"

      OpenEmbedded 빌드 시스템에서 사용하는 BitBake는 다음을 지원합니다.
      버전별 종속성을 지정합니다. 구문은 다양하지만
      BitBake는 패키징 형식에 따라 이러한 차이점을 숨깁니다.
      귀하로부터. 다음은 버전을 지정하는 일반적인 구문입니다.
      `RCONFLICTS` 변수::

         RCONFLICTS:${PN} = "패키지(운영자 버전)"

      `operator`의 경우 다음과 같이 지정할 수 있습니다.

      - =
      - <
      ->
      - <=
      - >=

      예를 들어, 다음은 버전 1.2에 대한 종속성을 설정합니다.
      패키지 `foo`의 더 큰 부분::

         RCONFLICTS:${PN} = "foo (>= 1.2)"

### `RDEPENDS`

      패키지의 런타임 종속성을 나열합니다. 이러한 종속성은 다른 패키지들입니다.
      해당 패키지가 제대로 작동하려면 반드시 설치해야 하는 패키지들입니다.
      정확하게. 예를 들어, 다음 할당은 다음을 선언합니다.
      `foo` 패키지를 사용하려면 `bar` 및 `baz` 패키지가 필요합니다.
      설치됨::

         RDEPENDS:foo = "bar baz"

      가장 일반적인 포장 유형
      런타임 종속성은 자동으로 감지되어 추가됩니다. 따라서
      대부분의 레시피는 `RDEPENDS`를 설정할 필요가 없습니다. 자세한 내용은 다음을 참조하세요.
      보다
      ":ref:`개요-매뉴얼/개념:자동으로 추가된 런타임 종속성`"
      Yocto 프로젝트 개요 및 개념 설명서의 해당 섹션을 참조하십시오.

      위의 `RDEPENDS` 할당의 실제적인 효과는 다음과 같습니다.
      ``bar``와 ``baz``는 내부에 종속성으로 선언될 것입니다.
      `foo` 패키지는 다음 중 하나에 의해 작성될 때
      :ref:`do_package_write_* <ref-tasks-package_write_deb>` 작업.
      이 과정이 정확히 어떻게 진행되는지는 사용되는 패키지 형식에 따라 다릅니다.
      이는 다음으로 결정됩니다
      `패키지 클래스`.
      해당 패키지 관리자가 패키지를 설치하면, 패키지 관리자는 이를 알게 될 것입니다.
      또한 해당 프로그램이 의존하는 패키지도 설치하십시오.

      `bar`와 `baz` 패키지가 빌드되도록 하려면,
      이전 `RDEPENDS` 할당 또한 작업 종속성을 발생시킵니다.
      추가되었습니다. 이 종속성은 레시피에서 비롯됩니다.
      :ref:`ref-tasks-build` (다음과 혼동하지 마십시오)
      :ref:`ref-tasks-compile`) 작업을
      `bar`를 빌드하는 레시피의 `do_package_write_* <ref-tasks-package_write_deb>` 작업
      ``바즈``.

      ``RDEPENDS`에 나열하는 패키지 이름은 다음과 같아야 합니다.
      다른 패키지의 이름은 레시피 이름이 될 수 없습니다.
      패키지 이름과 레시피 이름이 일치하는 경우가 많다는 점이 중요합니다.
      여기서 문제는 `RDEPENDS` 내에 패키지 이름을 제공하고 있다는 것입니다.
      변수. 예를 들어, 기본적으로 생성되는 패키지 목록은 다음과 같습니다.
      레시피를 보려면 `PACKAGES` 변수를 참조하세요.

      `RDEPENDS` 변수는 빌드 중인 패키지에 적용되기 때문에,
      변수를 사용할 때는 항상 패키지가 첨부된 형태로 사용해야 합니다.
      이름 (하나의 레시피로 여러 패키지를 빌드할 수 있다는 점을 기억하세요).
      예를 들어, 특정 서비스에 의존하는 개발 패키지를 빌드한다고 가정해 보겠습니다.
      `perl` 패키지에 대한 내용입니다. 이 경우 다음과 같이 사용합니다.
      `RDEPENDS` 문::

         RDEPENDS:${PN}-dev += "perl"

      예시에서,
      개발 패키지는 ``perl`` 패키지에 의존합니다. 따라서,
      `RDEPENDS` 변수에는 ``${PN}-dev`` 패키지 이름이 일부 포함되어 있습니다.
      변수.

      .. 메모::

         ``RDEPENDS:${PN}-dev``에는 ``${``\ `PN`\ ``}``이 포함됩니다.
         기본적으로 그렇습니다. 이 기본값은 BitBake 설정 파일에 설정되어 있습니다.
         (``meta/conf/bitbake.conf``) 파일을 실수로 삭제하지 않도록 주의하세요.
         `RDEPENDS:${PN}-dev`를 수정할 때는 `${PN}`에 "+=" 연산자를 사용하십시오.
         연산자 "=" 대신에.

      `RDEPENDS` 명령어와 함께 사용하는 패키지 이름은 다음과 같이 표시되어야 합니다.
      `PACKAGES` 변수에 있습니다. `PKG` 변수는 다음과 같습니다.
      최종 패키지에 다른 이름을 사용할 수 있습니다(예:
      :ref:`ref-classes-debian` 클래스는 이를 사용하여 이름을 변경합니다.
      패키지)이지만, 이 최종 패키지 이름은 다음과 함께 사용할 수 없습니다.
      `RDEPENDS`는 `RDEPENDS`의 의미대로 해석하면 타당합니다.
      사용된 패키지 형식과 무관합니다.

      OpenEmbedded 빌드 시스템에서 사용하는 BitBake는 다음을 지원합니다.
      버전별 종속성을 지정합니다. 구문은 다양하지만
      BitBake는 패키징 형식에 따라 이러한 차이점을 숨깁니다.
      귀하로부터. 다음은 버전을 지정하는 일반적인 구문입니다.
      `RDEPENDS` 변수::

         RDEPENDS:${PN} = "패키지(운영자 버전)"

      `operator`의 경우 다음과 같이 지정할 수 있습니다.

      - =
      - <
      ->
      - <=
      - >=

      버전의 경우 버전 번호를 입력해 주세요.

      .. 메모::

         `EXTENDPKGV` 명령어를 사용하면 전체 패키지 버전을 제공할 수 있습니다.
         사양.

      예를 들어, 다음은 버전 1.2에 대한 종속성을 설정합니다.
      패키지 `foo`의 더 큰 부분::

         RDEPENDS:${PN} = "foo (>= 1.2)"

      빌드 시 종속성에 대한 자세한 내용은 `DEPENDS`를 참조하십시오.
      변수입니다. 또한 다음을 확인할 수 있습니다.
      ":ref:`bitbake-user-manual/bitbake-user-manual-metadata:tasks`" 및
      ":ref:`bitbake-user-manual/bitbake-user-manual-execution:dependencies`" 섹션의
      작업 및 종속성에 대한 자세한 내용은 BitBake 사용자 설명서를 참조하십시오.

### `READELF`

      :manpage:`readelf <readelf(1)>`을 실행하기 위한 최소 명령 및 인수입니다.

### `RECIPE_MAINTAINER`

      이 변수는 관리자의 이름과 이메일 주소를 정의합니다.
      레시피. 이러한 정보는 사용자가 변경 사항을 제출할 때 사용할 수 있습니다.
      예를 들어 다음과 같은 알림을 보내기 위해 자동화된 도구를 사용할 수 있습니다.
      취약점 또는 소스 업데이트.

      해당 변수는 전역 배포 파일인 `maintainers.inc`에서 정의할 수 있습니다.
      </openembedded-core/tree/meta/conf/distro/include/maintainers.inc>` 파일::

          meta/conf/distro/include/maintainers.inc:RECIPE_MAINTAINER:pn-sysvinit = "Ross Burton <ross.burton@arm.com>"

      레시피에 직접 명시할 수도 있습니다.
      예를 들어 ``libgpiod``의 경우::

          RECIPE_MAINTAINER = "바르토스 골라스제프스키 <brgl@bgdev.pl>"

### `RECIPE_NO_UPDATE_REASON`

      레시피를 더 최신 버전의 상위 버전으로 교체해서는 안 되는 경우,
      레시피에서 이 변수에 이유를 넣으면 다음과 같은 이점이 있습니다.
      앞서 설명한 대로 `devtool check-upgrade-status` 명령어를 사용하여 표시할 수 있습니다.
      ":ref:`ref-manual/devtool-reference:레시피 업그레이드 상태 확인`"에서
      부분.

### `RECIPE_SYSROOT`

      이 변수는 모든 파일이 저장된 디렉토리를 가리킵니다.
      `DEPENDS`에 지정된 레시피. 이름에서 알 수 있듯이,
      이 변수를 레시피의 사용자 지정 루트(``/``)라고 생각하십시오.
      컴파일러가 컴파일을 완료하는 데 필요한 헤더 및 기타 파일을 찾기 위해 사용됩니다.
      그것의 역할.

      이 변수는 `STAGING_DIR_HOST` 또는 `STAGING_DIR_TARGET`와 관련이 있습니다.
      레시피 유형과 빌드 대상에 따라 다릅니다.

      이 변수를 더 잘 이해하기 위해 다음 예시들을 살펴보세요.

      - `#include <header.h>`를 사용하려면 `header.h` 파일은 `${RECIPE_SYSROOT}/usr/include` 경로에 있어야 합니다.

      - `-lexample`의 경우, `libexample.so` 파일은 `${RECIPE_SYSROOT}/lib`에 있어야 합니다.
         또는 다른 라이브러리 sysroot 디렉터리.

      기본값은 ``"${WORKDIR}/recipe-sysroot"``입니다.
      수정하지 마십시오.

### `RECIPE_SYSROOT_NATIVE`

      이는 `RECIPE_SYSROOT`와 유사하지만, 표시되는 파일은 다음에서 가져온 것입니다.
      `-native` 레시피를 사용하면 대상 머신용으로 빌드된 레시피를 만들 수 있습니다.
      ``네이티브`` 도구를 사용하세요.

      이 변수는 `STAGING_DIR_NATIVE`와 관련이 있습니다.

      기본값은 ``"${WORKDIR}/recipe-sysroot-native"``입니다.
      수정하지 마십시오.

### `RECIPE_UPGRADE_EXTRA_TASKS`

      `devtool upgrade` 명령어를 사용하여 레시피를 업그레이드할 때 변수
      `RECIPE_UPGRADE_EXTRA_TASKS`는 공백으로 구분된 목록을 지정합니다.
      새 소스 파일의 압축 해제 후 실행할 작업입니다.

      일부 레시피의 경우, 새 소스 압축을 푼 후 추가 작업이 필요합니다.
      업그레이드 중에 실행해야 할 수도 있습니다. 좋은 예로 레시피가 있습니다.
      :ref:`ref-classes-cargo-update-recipe-crates`를 상속하는 경우,
      `do_update_crates` 작업은 Cargo.toml/Cargo.lock 파일이 변경될 때마다 실행되어야 합니다.
      소스 코드가 변경되었습니다.

### `REPODIR`

      BitBake 설명서에서 ``bitbake:REPODIR`을 참조하십시오.

### `REQUIRED_COMBINED_FEATURES`

      `:ref:`ref-classes-features_check` 클래스를 상속받을 때, 이 변수는
      결합된 특징(기계 특징의 교집합)을 식별합니다.
      그리고 `DISTRO_FEATURES`)는 현재 구성에 반드시 존재해야 합니다.
      OpenEmbedded Build System이 레시피를 빌드하려면 다음이 필요합니다.
      즉, `REQUIRED_COMBINED_FEATURES` 변수에 나열된 내용이
      `COMBINED_FEATURES`에 나타나지 않는 기능
      현재 구성이면 레시피는 건너뛰어지고, 빌드가 완료되면 레시피는 건너뛰어집니다.
      시스템이 레시피를 빌드하려고 시도하면 오류가 발생합니다.

### `REQUIRED_DISTRO_FEATURES`

      :ref:`ref-classes-features_check`를 상속받을 때
      클래스에서 이 변수는 반드시 존재해야 하는 배포 기능을 식별합니다.
      현재 구성에서 OpenEmbedded 빌드를 위해서는
      레시피를 만드는 시스템입니다. 다시 말해, 만약
      `REQUIRED_DISTRO_FEATURES` 변수는 필수적이지 않은 기능을 나열합니다.
      현재 구성 내의 `DISTRO_FEATURES`에 나타납니다.
      해당 레시피는 건너뛰어지며, 빌드 시스템이 빌드를 시도하는 경우
      그러면 레시피에 오류가 발생합니다.

### `REQUIRED_IMAGE_FEATURES`

      `:ref:`ref-classes-features_check` 클래스를 상속받을 때, 이 변수는
      현재 이미지에 반드시 존재해야 하는 이미지 특징을 식별합니다.
      OpenEmbedded Build System이 빌드를 수행하려면 다음과 같이 구성해야 합니다.
      레시피. 다시 말해, `REQUIRED_IMAGE_FEATURES` 변수가
      `IMAGE_FEATURES`에 나타나지 않는 기능을 나열합니다.
      현재 구성이면 레시피는 건너뛰어지고, 빌드가 완료되면 레시피는 건너뛰어집니다.
      시스템이 레시피를 빌드하려고 시도하면 오류가 발생합니다.

      다른 ``REQUIRED_*_FEATURES`` 변수와 비교했을 때,
      `REQUIRED_IMAGE_FEATURES` 변수는 이미지 레시피만 대상으로 합니다.
      `IMAGE_FEATURES` 변수는 `ref-classes-core-image`에서 처리됩니다.
      클래스). 하지만 `REQUIRED_IMAGE_FEATURES` 변수는 또한 다음과 같을 수 있습니다.
      배포판과 같은 구성 파일에서 설정됩니다.
      구성 파일에서, 필수 이미지 기능 목록이 적용되어야 하는 경우
      이 `DISTRO`를 사용하는 모든 이미지.

### `REQUIRED_MACHINE_FEATURES`

      `:ref:`ref-classes-features_check` 클래스를 상속받을 때, 이 변수는
      현재 시스템에 반드시 존재해야 하는 `MACHINE_FEATURES`를 식별합니다.
      OpenEmbedded Build System이 빌드를 수행하려면 다음과 같이 구성해야 합니다.
      레시피. 다시 말해, `REQUIRED_MACHINE_FEATURES` 변수가
      `MACHINE_FEATURES`에 나타나지 않는 기능을 나열합니다.
      현재 구성이면 레시피는 건너뛰어지고, 빌드가 완료되면 레시피는 건너뛰어집니다.
      시스템이 레시피를 빌드하려고 시도하면 오류가 발생합니다.

### `REQUIRED_TUNE_FEATURES`

      `:ref:`ref-classes-features_check` 클래스를 상속받을 때, 이 변수는
      현재 구성에 반드시 존재해야 하는 튜닝 기능을 식별합니다.
      레시피를 빌드하기 위해 `OpenEmbedded Build System`에 대한 주문입니다.
      즉, `REQUIRED_TUNE_FEATURES` 변수에 나열된 내용이
      현재 `TUNE_FEATURES`에 나타나지 않는 기능
      구성이 잘못되면 레시피는 건너뛰어지고, 빌드 시스템이
      레시피를 빌드하려고 시도하면 오류가 발생합니다.

### `REQUIRED_VERSION`

      레시피에 여러 버전이 있는 경우 이 변수
      어떤 버전에 우선순위를 부여해야 하는지 결정합니다.
      `REQUIRED_VERSION`은 다음과 정확히 동일한 방식으로 작동합니다.
      지정된 버전이 아닌 경우를 제외하고 `선호하는 버전`
      사용 가능한 경우 오류 메시지가 표시되고 빌드가 실패합니다.
      즉시.

      `REQUIRED_VERSION`과 `PREFERRED_VERSION`이 모두 설정된 경우
      동일한 레시피의 경우, `REQUIRED_VERSION` 값이 적용됩니다.

### `RETAIN_DIRS_ALWAYS`

      `:ref:`ref-classes-retain` 클래스를 상속할 때, 이 변수는 다음 값을 가집니다.
      레시피별로 구분된 디렉토리를 공백으로 구분하여 항상 tarball에 저장합니다.
      레시피 빌드가 실패했는지 여부와 관계없이.

### `RETAIN_DIRS_FAILURE`

      `:ref:`ref-classes-retain` 클래스를 상속할 때, 이 변수는 다음 값을 가집니다.
      레시피별로 구분된 디렉토리를 tarball에 저장합니다.
      레시피 빌드 실패.

### `RETAIN_DIRS_GLOBAL_ALWAYS`

      `:ref:`ref-classes-retain` 클래스를 상속할 때, 이 변수는 다음 값을 가집니다.
      레시피와 관련 없는 공백으로 구분된 디렉터리를 저장합니다.
      빌드가 실패했는지 여부와 관계없이 tarball을 생성합니다.

### `RETAIN_DIRS_GLOBAL_FAILURE`

      `:ref:`ref-classes-retain` 클래스를 상속할 때, 이 변수는 다음 값을 가집니다.
      레시피와 관련 없는 공백으로 구분된 디렉터리를 저장합니다.
      빌드 실패 시 tarball 생성.

### `RETAIN_ENABLED`

      작업 디렉터리의 tarball 생성을 비활성화합니다.
      :ref:`ref-classes-retain` 클래스입니다. 특정 레시피에 설정하여 비활성화할 수 있습니다.
      클래스가 `INHERIT`를 사용하여 전역적으로 상속될 때의 클래스입니다.

### `RETAIN_OUTDIR`

      `ref-classes-retain` 클래스를 상속할 때, 이 변수는
      작업 디렉터리의 tarball을 저장할 디렉터리를 지정합니다.
      기본 디렉터리는 ``${TMPDIR}/retain``입니다.

### `RETAIN_TARBALL_SUFFIX`

      `ref-classes-retain` 클래스를 상속할 때, 이 변수는
      작업 디렉터리의 tarball 접미사를 지정합니다. 기본값은 다음과 같습니다.
      접미사는 ``${DATETIME}.tar.gz``입니다.

### `RM_WORK_EXCLUDE`

      `ref-classes-rm-work`가 활성화된 경우 이 변수는
      작업 디렉터리를 삭제하지 않아야 하는 레시피 목록을 지정합니다.
      자세한 내용은 ":ref:`ref-classes-rm-work`" 섹션을 참조하십시오.

### ` ROOT_HOME`

      루트 홈 디렉터리를 정의합니다. 기본적으로 이 디렉터리는 다음과 같이 설정됩니다.
      BitBake 설정 파일에는 다음과 같은 내용이 있습니다.

         ROOT_HOME ??= "/home/root"

      .. 메모::

         이 기본값은 일부 임베디드 솔루션에서 사용되는 이유일 가능성이 높습니다.
         읽기 전용 루트 파일 시스템을 선호하며, 유지하는 것을 선호합니다.
         쓰기 가능한 데이터가 한 곳에 있습니다.

      ``INIT_MANAGER = systemd``로 설정하면 기본값은 다음과 같이 설정됩니다.

         ROOT_HOME ?= "/root"

      배포판에서 변수를 설정하여 기본 설정을 재정의할 수도 있습니다.
      설정 파일이나 ``local.conf`` 파일에서 확인할 수 있습니다.

### `ROOTFS`

      루트 파일 시스템으로 포함할 파일 시스템 이미지를 지정합니다.

      `ROOTFS` 변수는 선택적으로 사용되는 변수입니다.
      :ref:`ref-classes-image-live` 클래스.

### `ROOTFS_POSTINSTALL_COMMAND`

      OpenEmbedded 빌드 후에 호출할 함수 목록을 지정합니다.
      시스템에 패키지가 설치되어 있습니다. 함수는 따옴표로 구분하여 지정할 수 있습니다.
      공간::

         ROOTFS_POSTINSTALL_COMMAND += "함수"

      만약 명령줄 내부에 있는 루트 파일 시스템 경로를 전달해야 한다면
      이 함수에서는 `${IMAGE_ROOTFS}`를 사용할 수 있으며, 이는 해당 경로를 가리킵니다.
      루트 파일 시스템 이미지가 되는 디렉터리입니다. 자세한 내용은 다음을 참조하십시오.
      `IMAGE_ROOTFS` 변수에 대한 자세한 내용은 다음을 참조하십시오.
      정보.

### `ROOTFS_POSTPROCESS_COMMAND`

      OpenEmbedded 빌드가 완료되면 호출할 함수 목록을 지정합니다.
      시스템에서 루트 파일 시스템을 생성했습니다. 기능을 지정할 수 있습니다.
      공백으로 구분됨::

         ROOTFS_POSTPROCESS_COMMAND += "함수"

      만약 명령줄 내부에 있는 루트 파일 시스템 경로를 전달해야 한다면
      이 함수에서는 `${IMAGE_ROOTFS}`를 사용할 수 있으며, 이는 해당 경로를 가리킵니다.
      루트 파일 시스템 이미지가 되는 디렉터리입니다. 자세한 내용은 다음을 참조하십시오.
      `IMAGE_ROOTFS` 변수에 대한 자세한 내용은 다음을 참조하십시오.
      정보.

### `ROOTFS_POSTUNINSTALL_COMMAND`

      OpenEmbedded 빌드 후에 호출할 함수 목록을 지정합니다.
      시스템에서 불필요한 패키지를 제거했습니다. 런타임 패키지
      이미지에서 관리 기능이 비활성화되어 있으며, 여러 패키지가 제거되었습니다.
      `base-passwd`, `shadow`, `update-alternatives` 등이 포함됩니다.
      함수는 공백으로 구분하여 지정할 수 있습니다.

         ROOTFS_POSTUNINSTALL_COMMAND += "함수"

      만약 명령줄 내부에 있는 루트 파일 시스템 경로를 전달해야 한다면
      이 함수에서는 `${IMAGE_ROOTFS}`를 사용할 수 있으며, 이는 해당 경로를 가리킵니다.
      루트 파일 시스템 이미지가 되는 디렉터리입니다. 자세한 내용은 다음을 참조하십시오.
      `IMAGE_ROOTFS` 변수에 대한 자세한 내용은 다음을 참조하십시오.
      정보.

### `ROOTFS_PREPROCESS_COMMAND`

      OpenEmbedded 빌드 전에 호출할 함수 목록을 지정합니다.
      시스템에서 루트 파일 시스템을 생성했습니다. 기능을 지정할 수 있습니다.
      공백으로 구분됨::

         ROOTFS_PREPROCESS_COMMAND += "함수"

      만약 명령줄 내부에 있는 루트 파일 시스템 경로를 전달해야 한다면
      이 함수에서는 `${IMAGE_ROOTFS}`를 사용할 수 있으며, 이는 해당 경로를 가리킵니다.
      루트 파일 시스템 이미지가 되는 디렉터리입니다. 자세한 내용은 다음을 참조하십시오.
      `IMAGE_ROOTFS` 변수에 대한 자세한 내용은 다음을 참조하십시오.
      정보.

### `RPMBUILD_EXTRA_PARAMS`

      `rpmbuild` 명령에 대한 추가 사용자 정의 매개변수를 지정합니다.

### `RPROVIDES`

      패키지가 제공하는 패키지 이름 별칭 목록입니다.
      별칭은 다른 항목의 런타임 종속성을 충족하는 데 유용합니다.
      빌드 과정과 대상 시스템 모두에서 패키지를 사용합니다(지정된 대로).
      `RDEPENDS`).

      .. 메모::

         패키지 자체의 이름은 `RPROVIDES` 목록에 암묵적으로 이미 포함되어 있습니다.

      다른 모든 패키지 제어 변수와 마찬가지로 항상 다음을 사용해야 합니다.
      패키지 이름 재정의와 함께 변수를 사용합니다. 다음은 그 예입니다.
      예::

         RPROVIDES:${PN} = "widget-abi-2"

### `RRECOMMENDS`

      패키지의 활용도를 확장하는 패키지 목록
      빌드가 완료되었습니다. 빌드 중인 패키지는 이 목록에 있는 항목에 의존하지 않습니다.
      성공적인 빌드를 위해 패키지를 사용하는 것이 아니라, 오히려 패키지를 다음과 같은 용도로 사용합니다.
      확장된 사용성. 패키지의 런타임 종속성을 지정하려면 다음을 참조하세요.
      `RDEPENDS` 변수.

      패키지 관리자가 자동으로 `RRECOMMENDS`를 설치합니다.
      빌드된 패키지를 설치할 때 표시되는 패키지 목록입니다. 하지만 다음과 같은 방법도 있습니다.
      나열된 패키지가 설치되지 않도록 하려면 다음을 사용하십시오.
      `나쁜_추천`,
      `권장사항 없음`, 그리고
      `PACKAGE_EXCLUDE` 변수.

      `RRECOMMENDS`에 지정된 패키지는 실제로 생성할 필요가 없습니다.
      하지만 각 패키지에는 반드시 레시피가 포함되어 있어야 합니다.
      `PACKAGES`를 통해 또는
      `PACKAGES_DYNAMIC` 변수 또는
      `RPROVIDES` 변수를 제공하지 않으면 오류가 발생합니다.
      빌드 중에. 만약 그러한 레시피가 존재하고 패키지가 그렇지 않다면.
      생성된 후에는 오류 없이 빌드가 계속됩니다.

      `RRECOMMENDS` 변수는 빌드 중인 패키지에 적용되기 때문에,
      변수에 오버라이드를 연결하여 지정하는 것이 항상 좋습니다.
      사용성이 확장되고 있는 특정 패키지입니다. 예를 들어,
      확장 기능을 갖춘 개발 패키지를 구축한다고 가정해 보겠습니다.
      무선 기능을 지원합니다. 이 경우 다음을 사용합니다.
      수행원::

         권장 사항:${PN}-dev += "무선 패키지 이름"

      그 안에서
      예를 들어 패키지 이름(``${PN}-dev``)은 다음과 같이 표시되어야 합니다.
      출력 패키지의 이름을 변경하기 전에 `PACKAGES` 네임스페이스를 사용하십시오.
      :ref:`ref-classes-debian`과 같은 클래스에 의해.

      OpenEmbedded 빌드 시스템에서 사용하는 BitBake는 다음을 지원합니다.
      버전별 권장 사항을 지정합니다. 구문은 상황에 따라 다를 수 있습니다.
      BitBake는 포장 형식에서 이러한 차이점을 사용자에게 숨깁니다.
      다음은 버전을 지정하는 일반적인 구문입니다.
      `RRECOMMENDS` 변수::

         권장 사항:${PN} = "패키지(운영자 버전)"

      `operator`의 경우 다음과 같이 지정할 수 있습니다.

      - =
      - <
      ->
      - <=
      - >=

      예를 들어, 다음은 버전 1.2에 대한 권장 사항을 설정합니다.
      패키지 `foo`의 더 큰 부분::

         권장 사항:${PN} = "foo (>= 1.2)"

### `RREPLACES`

      패키지로 교체된 패키지 목록입니다. 패키지 관리자는 다음을 사용합니다.
      이 변수는 어떤 패키지를 설치해야 하는지 결정하는 데 사용됩니다.
      업그레이드 중에 다른 패키지를 교체합니다. 또한 다음을 수행하려면
      다른 패키지가 동시에 제거된 경우, 해당 패키지의 이름을 추가해야 합니다.
      다른 패키지를 `RCONFLICTS` 변수에 추가합니다.

      다른 모든 패키지 제어 변수와 마찬가지로 이 변수도 반드시 사용해야 합니다.
      패키지 이름 재정의와 함께 사용됩니다. 다음은 예시입니다.

         RREPLACES:${PN} = "교체될 다른 패키지"

      OpenEmbedded 빌드 시스템에서 사용하는 BitBake는 다음을 지원합니다.
      버전이 지정된 대체 항목을 지정합니다. 구문은 다양하지만
      BitBake는 패키징 형식에 따라 이러한 차이점을 숨깁니다.
      귀하로부터. 다음은 버전을 지정하는 일반적인 구문입니다.
      `RREPLACES` 변수를::

         RREPLACES:${PN} = "패키지(운영자 버전)"

      `operator`의 경우 다음과 같이 지정할 수 있습니다.

      - =
      - <
      ->
      - <=
      - >=

      예를 들어, 다음은 버전 1.2를 사용하여 교체를 설정하는 예입니다.
      패키지 `foo`의 그 이상::

          RREPLACES:${PN} = "foo (>= 1.2)"

### `RSUGGESTS`

      설치를 제안할 수 있는 추가 패키지 목록입니다.
      패키지 관리자가 패키지를 설치할 때 생성합니다. 모든 패키지가 그런 것은 아닙니다.
      패키지 관리자는 이 기능을 지원합니다.

      다른 모든 패키지 제어 변수와 마찬가지로, 항상 이 변수를 사용해야 합니다.
      패키지 이름 재정의와 함께 변수를 사용합니다. 다음은 그 예입니다.
      예::

         제안:${PN} = "유용한 패키지 다른 패키지"

### `RUST_CHANNEL`

      빌드할 Rust 버전을 지정합니다. "안정 버전", "베타 버전" 또는 "나이틀리 버전" ​​중에서 선택할 수 있습니다.
      기본값은 "안정적"입니다. 이 값을 설정할 때는 주의가 필요하며, 다른 값으로 설정할 경우 발생할 수 있는 위험에 대한 책임은 사용자에게 있습니다.
      "안정적"이라는 표시보다 더 많은 기능을 제공한다고 해서 특정 시점에 작동이 보장되는 것은 아닙니다.

### `S`

      빌드 디렉터리 내의 위치
      압축 해제된 레시피 소스 코드가 있는 디렉토리입니다. 기본적으로 이 디렉토리는 다음과 같습니다.
      ``${``\ `UNPACKDIR`\ ``}/${``\ `BPN`\ ``}-${``\ `PV`\ ``}``,
      여기서 `${BPN}``은 기본 레시피 이름이고 `${PV}``은 레시피입니다.
      버전. 소스 tarball이 코드를 라는 이름의 디렉터리에 압축 해제하는 경우
      ``${BPN}-${PV}`` 이외의 모든 것, 또는 소스 코드가 다음과 같은 경우
      Git이나 Subversion과 같은 SCM에서 가져온 경우, 설정을 해야 합니다.
      OpenEmbedded 빌드 시스템이 레시피의 `S` 위치를 알 수 있도록 레시피에 `S`를 추가합니다.
      압축 해제된 소스 코드를 찾으려면.

      예를 들어, 소스 디렉터리를 가정해 보겠습니다.
      최상위 폴더 이름은 `poky`이고 기본 `빌드 디렉토리`는 다음과 같습니다.
      ``poky/build``. 이 경우 빌드 시스템의 작업 디렉토리입니다.
      `db`에 대한 압축 해제된 레시피를 유지하는 데 사용되는 방법은 다음과 같습니다.

         poky/build/tmp/work/qemux86-poky-linux/db/5.1.19-r3/sources/db-5.1.19

      압축 해제된 소스 코드는 ``db-5.1.19`` 폴더에 있습니다.

### `SANITY_REQUIRED_UTILITIES`

      확인해야 할 명령줄 유틸리티 목록을 지정합니다.
      BitBake를 실행할 때 초기 정상 작동 확인 과정 중에 발생합니다. 만약
      빌드 호스트에 유틸리티 중 하나라도 설치되어 있지 않으면,
      BitBake가 즉시 오류와 함께 종료됩니다.

### `SANITY_TESTED_DISTROS`

      빌드 시스템이 보유한 호스트 배포 식별자 목록
      테스트를 거쳤습니다. 식별자는 호스트 배포자 ID로 구성됩니다.
      이어서 `lsb_release` 도구에서 보고한 대로 릴리스가 진행됩니다.
      `/etc/lsb-release`에서 읽은 내용입니다. 목록 항목은 다음으로 구분합니다.
      명시적인 줄 바꿈 문자(``\n``). `SANITY_TESTED_DISTROS`가 다음과 같으면
      비어있지 않고 현재 값
      `NATIVELSBSTRING`은 나타나지 않습니다.
      목록을 나열한 다음 빌드 시스템에서 경고를 표시합니다.
      현재 호스트 배포판은 빌드 호스트로 테스트되지 않았습니다.

### `SDK_ARCH`

      SDK의 대상 아키텍처입니다. 일반적으로 직접 지정하지는 않습니다.
      이 변수를 설정하세요. 대신 `SDKMACHINE`을 사용하세요.

### `SDK_ARCHIVE_TYPE`

      SDK용으로 생성할 아카이브 유형을 지정합니다. 유효한 값:

      - ``tar.xz`` (기본값)
      - ``tar.zst``
      - ``7zip``
      - ``zip``

      한 번에 하나의 아카이브 유형만 지정할 수 있습니다.

### `SDK_AS_ARCH`

      빌드 시 아키텍처별 어셈블러 플래그를 지정합니다.
      :ref:`ref-classes-nativesdk` 레시피. 기본적으로 값은
      `SDK_AS_ARCH`는 `BUILD_AS_ARCH`와 동일합니다.

### `SDK_BUILDINFO_FILE`

      :ref:`ref-classes-image-buildinfo` 클래스를 사용할 때,
      SDK에서 빌드 정보를 기록할 파일을 지정합니다.
      기본값은 "``/buildinfo``"입니다.

### `SDK_CC_ARCH`

      빌드 시 아키텍처별 C 컴파일러 플래그를 지정합니다.
      :ref:`ref-classes-nativesdk` 레시피. 기본적으로 값은
      `SDK_CC_ARCH`는 `BUILD_CC_ARCH`와 같습니다.

### `SDK_CUSTOM_TEMPLATECONF`

      확장 가능한 SDK를 빌드할 때, `SDK_CUSTOM_TEMPLATECONF`가 설정되어 있으면
      "1"이고 빌드 디렉터리에 `conf/templateconf.cfg` 파일이 있습니다.
      (`TOPDIR`)을 입력하면 이 내용이 SDK로 복사됩니다.

### `SDK_DEPLOY`

      디렉토리는 설정되어 있으며 사용됩니다.
      :ref:`populate_sdk_base <ref-classes-populate-sdk>` 클래스는
      SDK가 배포되었습니다. :ref:`populate_sdk_base <ref-classes-populate-sdk>`
      클래스는 `SDK_DEPLOY`를 다음과 같이 정의합니다.

         SDK_DEPLOY = "${TMPDIR}/deploy/sdk"

### `SDK_DIR`

      OpenEmbedded 빌드 시스템에서 사용하는 상위 디렉터리
      SDK 출력물을 생성하는 중입니다.
      :ref:`populate_sdk_base <ref-classes-populate-sdk-*>` 클래스 정의
      변수는 다음과 같습니다.

         SDK_DIR = "${WORKDIR}/sdk"

      .. 메모::

         `SDK_DIR` 디렉터리는 SDK의 일부이므로 임시 디렉터리입니다.
         `WORKDIR`입니다. 최종 출력 디렉터리는 `SDK_DEPLOY`입니다.

### `SDK_EXT_TYPE`

      공유 상태 아티팩트가 복사될지 여부를 제어합니다.
      확장 가능한 SDK입니다. 기본값인 "full"은 모든 내용을 복사합니다.
      확장 가능한 SDK에 필요한 공유 상태 아티팩트를 포함시켰습니다. 값
      "minimal" 버전은 SDK에서 이러한 구성 요소를 제외합니다.

      .. 메모::

         변수를 "최소"로 설정하는 경우 다음 사항을 확인해야 합니다.
         SDK 구성에서 `SSTATE_MIRRORS`를 설정하면 다음을 활성화할 수 있습니다.
         필요에 따라 아티팩트를 가져옵니다.

### `SDK_HOST_MANIFEST`

      SDK 호스트 부분의 매니페스트 파일입니다. 이 파일에는 모든 항목이 나열됩니다.
      SDK의 호스트 부분을 구성하는 설치된 패키지들입니다.
      해당 파일에는 패키지별 정보가 한 줄씩 포함되어 있습니다.
      다음이 따릅니다::

         패키지 이름 패키지 아키텍처 버전

      :ref:`populate_sdk_base <ref-classes-populate-sdk-*>` 클래스
      매니페스트 파일을 다음과 같이 정의합니다.

         SDK_HOST_MANIFEST = "${SDK_DEPLOY}/${TOOLCHAIN_OUTPUTNAME}.host.manifest"

      해당 위치는 `SDK_DEPLOY`를 사용하여 얻어집니다.
      `TOOLCHAIN_OUTPUTNAME` 변수.

### `SDK_INCLUDE_PKGDATA`

      "1"로 설정하면 모든 레시피의 패키지 데이터를 포함하도록 지정합니다.
      확장 가능한 SDK의 "world" 타겟에 이 데이터를 포함합니다.
      `devtool search` 명령을 사용하여 검색에서 이러한 레시피를 찾을 수 있습니다.
      결과를 제공할 뿐만 아니라 `devtool add` 명령을 사용하여 매핑할 수도 있습니다.
      의존성을 보다 효과적으로 관리합니다.

      .. 메모::

         `SDK_INCLUDE_PKGDATA` 활성화
         변수 때문에 빌드 시간이 상당히 증가합니다. 왜냐하면 전 세계가 모두 같은 이유로 빌드 시간이 늘어나기 때문입니다.
         구축해야 합니다. 변수를 활성화하면 약간 증가합니다.
         확장 가능한 SDK의 크기.

### `SDK_INCLUDE_TOOLCHAIN`

      "1"로 설정하면 확장 가능한 라이브러리에 툴체인을 포함하도록 지정합니다.
      SDK. 툴체인을 포함하는 것은 특히 다음과 같은 경우에 유용합니다.
      `SDK_EXT_TYPE`이 "minimal"로 설정되어 유지됩니다.
      SDK 크기는 비교적 작지만, 그래도 사용 가능한 기능을 제공하고 싶을 것입니다.
      툴체인. 예를 들어, 특정 툴체인을 사용하고 싶다고 가정해 보겠습니다.
      IDE 또는 다른 도구를 사용하는데 추가적인 작업을 수행하고 싶지 않다면
      툴체인 설치 단계.

      `SDK_INCLUDE_TOOLCHAIN` 변수는 다음과 같은 경우 기본값이 "0"입니다.
      `SDK_EXT_TYPE`이 "minimal"로 설정되어 있고 기본값은 "1"인 경우입니다.
      `SDK_EXT_TYPE`이 "full"로 설정되었습니다.

### `SDK_LD_ARCH`

      빌드 시 아키텍처별 링커 플래그를 지정합니다.
      :ref:`ref-classes-nativesdk` 레시피. 기본적으로 값은
      `SDK_LD_ARCH`는 `BUILD_LD_ARCH`와 같습니다.

### `SDK_NAME`

      SDK 출력 파일의 기본 이름입니다. 기본값(설정된 대로)
      ``meta-poky/conf/distro/poky.conf``)는 다음에서 파생됩니다.
      `배포`,
      `TCLIBC`,
      `SDKMACHINE`,
      `이미지_베이스이름`,
      `TUNE_PKGARCH`, 그리고
      `MACHINE` 변수::

         SDK_NAME = "${DISTRO}-${TCLIBC}-${SDKMACHINE}-${IMAGE_BASENAME}-${TUNE_PKGARCH}-${MACHINE}"

### `SDK_OS`

      SDK를 빌드할 운영 체제를 지정합니다.
      기본값은 `BUILD_OS`의 값입니다.

### `SDK_OUTPUT`

      OpenEmbedded 빌드 시스템에서 SDK를 생성할 때 사용하는 위치입니다.
      출력. :ref:`populate_sdk_base <ref-classes-populate-sdk-*>`
      클래스는 변수를 다음과 같이 정의합니다.

         SDK_DIR = "${WORKDIR}/sdk"
         SDK_OUTPUT = "${SDK_DIR}/image"
         SDK_DEPLOY = "${DEPLOY_DIR}/sdk"

      .. 메모::

         `SDK_OUTPUT` 디렉터리는 임시 디렉터리이며, 이는 SDK_OUTPUT 디렉터리의 일부입니다.
         `SDK_DIR`을 통해 `WORKDIR`을 지정합니다. 최종 출력 디렉토리는 다음과 같습니다.
         `SDK_DEPLOY`.

### `SDK_PACKAGE_ARCHS`

      SDK 머신과 호환되는 아키텍처 목록을 지정합니다.
      이 변수는 자동으로 설정되므로 일반적으로는 변경해서는 안 됩니다.
      수작업으로 편집되었습니다. 항목들은 공백으로 구분되어 있으며 순서대로 나열되어 있습니다.
      우선순위. `SDK_PACKAGE_ARCHS`의 기본값은 "모든 것"입니다.
      노아치 ${SDK_ARCH}-${SDKPKGSUFFIX}".

### `SDK_POSTPROCESS_COMMAND`

      OpenEmbedded 빌드가 완료되면 호출할 함수 목록을 지정합니다.
      시스템이 SDK를 생성합니다. 함수는 따옴표로 구분하여 지정할 수 있습니다.
      공간:

         SDK_POSTPROCESS_COMMAND += "함수"

      함수 내 명령에 SDK 경로를 전달해야 하는 경우,
      ``${SDK_DIR}``을 사용할 수 있으며, 이는 SDK에서 사용하는 상위 디렉터리를 가리킵니다.
      SDK 출력을 생성할 때 OpenEmbedded 빌드 시스템을 참조하십시오.
      자세한 내용은 `SDK_DIR` 변수를 참조하십시오.

### `SDK_PREFIX`

      툴체인 바이너리 접두사는 다음과 같이 사용됩니다.
      :ref:`ref-classes-nativesdk` 레시피.
      OpenEmbedded 빌드 시스템은 `SDK_PREFIX` 값을 사용하여 설정합니다.
      빌드 시 `TARGET_PREFIX`
      ``nativesdk`` 레시피. 기본값은 "${SDK_SYS}-"입니다.

### `SDK_RECRDEP_TASKS`

      확장 가능한 SDK에 추가된 공유 상태 작업 목록입니다. 기본적으로,
      다음과 같은 작업이 추가되었습니다.

      - :ref:`ref-tasks-populate_lic`
      - :ref:`ref-tasks-package_qa`
      - :ref:`ref-tasks-populate_sysroot`
      - :ref:`ref-tasks-deploy`

      기본값이 ""임에도 불구하고
      `SDK_RECRDEP_TASKS` 변수에 따라 위의 네 가지 작업이 항상 추가됩니다.
      SDK에 대한 내용입니다. 이 네 가지 이상의 작업을 지정하려면 다음을 사용해야 합니다.
      `SDK_RECRDEP_TASKS` 변수(예: 추가 변수를 정의하는 경우)
      건설에 필요한 작업
      `SDK_TARGETS`).

### `SDK_SYS`

      시스템 아키텍처 및 운영 체제를 포함한 시스템 사양을 명시합니다.
      SDK가 빌드될 시스템입니다.

      OpenEmbedded 빌드 시스템은 이 변수를 자동으로 설정합니다.
      `SDK_ARCH`에서,
      `SDK_VENDOR`, 그리고
      `SDK_OS`를 설정해야 합니다. `SDK_SYS`는 설정할 필요가 없습니다.
      스스로 변수를 조절하세요.

### `SDK_TARGET_MANIFEST`

      SDK의 대상 부분에 대한 매니페스트 파일입니다. 이 파일에는 모든 항목이 나열됩니다.
      SDK의 대상 부분을 구성하는 설치된 패키지들입니다.
      해당 파일에는 패키지별 정보가 한 줄씩 포함되어 있습니다.
      다음이 따릅니다::

         패키지 이름 패키지 아키텍처 버전

      :ref:`populate_sdk_base <ref-classes-populate-sdk-*>` 클래스
      매니페스트 파일을 다음과 같이 정의합니다.

         SDK_TARGET_MANIFEST = "${SDK_DEPLOY}/${TOOLCHAIN_OUTPUTNAME}.target.manifest"

      해당 위치는 `SDK_DEPLOY`를 사용하여 얻어집니다.
      `TOOLCHAIN_OUTPUTNAME` 변수.

### `SDK_TARGETS`

      공유 상태에서 설치할 대상 목록은 다음과 같습니다.
      표준 또는 확장 가능한 SDK 설치. 기본값은 "${PN}"입니다.
      (즉, SDK를 빌드하는 데 사용된 이미지).

      `SDK_TARGETS` 변수는 내부 변수이며 일반적으로
      변경되지 않을 것입니다.

### `SDK_TITLE`

      SDK 설치 프로그램을 실행할 때 출력될 제목입니다. 기본값은 다음과 같습니다.
      이 제목은 `배전소_이름`을 기반으로 합니다.
      `DISTRO` 변수는 설정됩니다.
      :ref:`populate_sdk_base <ref-classes-populate-sdk-*>` 클래스를
      다음이 따릅니다::

         SDK_TITLE ??= "${@d.getVar('DISTRO_NAME') 또는 d.getVar('DISTRO')} SDK"

      기본 배포판 "poky"의 경우,
      `SDK_TITLE`이 "Poky(Yocto Project 참조 배포판)"으로 설정되었습니다.

      이 기본 제목을 변경하는 방법에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`sdk-manual/appendix-customizing:확장 가능한 SDK 설치 프로그램 제목 변경`"
      Yocto 프로젝트 애플리케이션 개발 섹션 및
      확장형 소프트웨어 개발 키트(eSDK) 설명서.

### `SDK_TOOLCHAIN_LANGS`

      SDK에서 지원할 프로그래밍 언어를 지정합니다.
      공백으로 구분된 목록입니다. 현재 지원되는 항목은 `rust`와 `go`입니다.

### `SDK_UPDATE_URL`

      확장 가능한 SDK용 업데이트 서버의 선택적 URL입니다. 설정된 경우,
      해당 값은 실행 시 기본 업데이트 서버로 사용됩니다.
      확장 가능한 SDK 내의 ``devtool sdk-update``입니다.

### `SDK_VENDOR`

      SDK 공급업체의 이름을 지정합니다.

### `SDK_VERSION`

      SDK 버전을 지정합니다. Poky 배포 구성 파일
      (``/meta-poky/conf/distro/poky.conf``)는 기본값을 설정합니다.
      `SDK_VERSION`은 다음과 같습니다::

         SDK_VERSION = "${@d.getVar('DISTRO_VERSION').replace('snapshot-${METADATA_REVISION}', 'snapshot')}"

      자세한 내용은 다음을 참조하십시오.
      `배포판` 및
      `METADATA_REVISION` 변수.

### `SDK_ZIP_OPTIONS`

      SDK를 압축할 때 `zip` 명령에 전달할 추가 옵션을 지정합니다.
      (예: `SDK_ARCHIVE_TYPE`이 "zip"으로 설정된 경우). 기본값은 다음과 같습니다.
      "-와이".

### `SDKEXTPATH`

      확장 가능 SDK의 기본 설치 디렉터리입니다. 작성자:
      기본적으로 이 디렉터리는 `DISTRO`를 기반으로 합니다.
      변수이며 설정됩니다.
      :ref:`populate_sdk_base <ref-classes-populate-sdk-*>` 클래스를
      다음이 따릅니다::

         SDKEXTPATH ​​??= "~/${@d.getVar('DISTRO')}_sdk"

      ~을 위해
      기본 배포판이 "poky"인 경우, `SDKEXTPATH`는 "poky_sdk"로 설정됩니다.

      기본 디렉터리를 변경하는 방법에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`sdk-manual/appendix-customizing:기본 SDK 설치 디렉터리 변경`"
      Yocto 프로젝트 애플리케이션 개발 섹션 및
      확장형 소프트웨어 개발 키트(eSDK) 설명서.

### `SDKIMAGE_FEATURES`

      `IMAGE_FEATURES`와 동일합니다. 하지만 이 변수는 다음에 적용됩니다.
      SDK는 다음 명령어를 사용하여 이미지로부터 생성되었습니다.

         $ bitbake -c populate_sdk imagename

### `SDKMACHINE`

      SDK가 빌드된 대상 기기입니다. 다시 말해, SDK 자체가 빌드된 기기입니다.
      `SDKMACHINE` 명령어로 지정한 대상 시스템에서 실행되도록 합니다.
      값. 이 값은 해당 ``.conf`` 파일을 가리킵니다.
      활성화된 레이어의 `conf/machine-sdk/` (예: `aarch64`)
      ``i586``, ``i686``, ``ppc64``, ``ppc64le`` 및 ``x86_64``는
      :oe_git:`OpenEmbedded-Core </openembedded-core/tree/meta/conf/machine-sdk>에서 사용 가능합니다.

      해당 변수의 기본값은 `BUILD_ARCH`이므로 SDK는 해당 용도로 빌드됩니다.
      빌드 머신의 아키텍처.

      .. 메모::

         `SDKMACHINE`을 설정할 수 없습니다.
         배포 구성 파일에 변수가 있습니다. 만약 그렇다면,
         설정이 적용되지 않습니다.

### `SDKPATH`

      SDK 구성 요소를 수집하고 빌드하는 데 사용되는 경로를 정의합니다.
      설치 프로그램.

### `SDKPATHINSTALL`

      SDK 설치를 위해 사용자에게 제공되는 경로를 정의합니다.
      이 파일은 OpenEmbedded 빌드 시스템에 의해 생성됩니다. 경로는 다음과 같습니다.
      SDK를 실행할 때 SDK가 설치되는 기본 위치입니다.
      설치 스크립트입니다. 실행 시 제공되는 경로를 변경할 수 있습니다.
      대본.

### `SDKTARGETSYSROOT`

      SDK 내에서 크로스 컴파일에 사용되는 sysroot의 전체 경로입니다.
      기본 설치 시와 동일한 상태가 됩니다.
      `SDKPATHINSTALL`.

### `SECTION`

      패키지를 분류해야 하는 섹션입니다. 패키지
      관리 유틸리티는 이 변수를 활용할 수 있습니다.

### `SELECTED_OPTIMIZATION`

      C 컴파일러에 전달되는 최적화 플래그를 지정합니다.
      대상에 맞게 빌드합니다. 플래그는 기본값을 통해 전달됩니다.
      `TARGET_CFLAGS` 변수의 값입니다.

      `SELECTED_OPTIMIZATION` 변수는 다음 값을 갖습니다.
      `DEBUG_BUILD` = "1"이 아닌 경우, 이 경우에는 `FULL_OPTIMIZATION`이 적용됩니다.
      이 경우 `DEBUG_OPTIMIZATION` 값이 사용됩니다.

### `SERIAL_CONSOLES`

      직렬 콘솔(TTY)을 정의하여 사용을 활성화합니다.
      :wikipedia:`getty <Getty_(Unix)>`. 값을 지정하여 제공하십시오.
      전송 속도와 TTY 장치 이름을 세미콜론으로 구분하여 입력합니다.
      여러 장치를 구분하려면 공백을 사용하세요.

         SERIAL_CONSOLES = "115200;ttyS0 115200;ttyS1"

### `SETUPTOOLS_BUILD_ARGS`

      `ref-classes-setuptools3`를 상속하는 레시피에서 사용될 때
      클래스에서 이 변수는 추가 인수를 지정하는 데 사용할 수 있습니다.
      `setuptools3_do_compile()` 작업에서 `setup.py build`에 전달되었습니다.

### `SETUPTOOLS_SETUP_PATH`

      `ref-classes-setuptools3`를 상속하는 레시피에서 사용될 때
      클래스에서 이 변수는 디렉토리를 지정하는 데 사용해야 합니다.
      `setup.py` 파일이 소스 코드의 루트에 있지 않은 경우 해당 파일의 위치를 ​​확인할 수 있습니다.
      ( `S`로 지정된) 트리. 예를 들어, 레시피에서
      소스 코드는 Git 저장소에서 가져오며 `setup.py`는 다음 위치에 있습니다.
      ``python/pythonmodule`` 하위 디렉터리에는 다음과 같은 내용이 있을 것입니다.

         SETUPTOOLS_SETUP_PATH = "${S}/python/pythonmodule"

### `SIGGEN_EXCLUDE_SAFE_RECIPE_DEPS`

      레시피 종속성 목록 (이 목록은 레시피를 결정하는 데 사용해서는 안 됩니다.)
      한 레시피의 작업들이 다른 레시피의 작업에 의존할 때, 그 작업들의 서명
      또 다른 레시피. 예를 들면:

         SIGGEN_EXCLUDE_SAFE_RECIPE_DEPS += "intone->mplayer2"

      이전 예시에서 ``intone``은 ``mplayer2``에 의존합니다.

      왼쪽에 특수 기호 ``"*"``를 사용할 수 있습니다.
      오른쪽 레시피를 제외한 모든 레시피와 일치하도록 종속성을 설정합니다.
      측면입니다. 예를 들면 다음과 같습니다.

         SIGGEN_EXCLUDE_SAFE_RECIPE_DEPS += "*->quilt-native"

      이전 예시에서 `quilt-native`를 제외한 모든 레시피는 무시됩니다.
      `quilt-native` 레시피의 작업 서명을 결정할 때
      그들의 업무 서명.

      이 변수를 사용하는 것은 종속성을 제거하는 한 가지 방법입니다.
      작업 서명에 영향을 미치므로 레시피가 변경될 때 재빌드가 강제됩니다.

      .. 메모::

         레시피 관계에 부적절한 종속성을 추가하면,
         소프트웨어 인터페이스에 문제가 있는 경우 런타임 중에 소프트웨어가 오류를 일으킬 수 있습니다.
         첫 번째 레시피가 만들어진 후 두 번째 레시피가 변경되었습니다.

   :용어:`SIGGEN_EXCLUDERECIPES_ABISAFE`
      완전히 안정적이며 절대 변하지 않는 레시피 목록입니다.
      목록에 있는 레시피의 ABI는 다음 출력에서 ​​확인할 수 있습니다.
      레시피를 빌드하기 위해 실행되는 작업입니다. 이 변수를 사용하는 것이 한 가지 방법입니다.
      작업에 영향을 미치는 레시피 간의 종속성을 제거합니다.
      서명을 사용하므로 레시피가 변경될 때 재구축이 강제됩니다.

      .. 메모::

         이 목록에 부적절한 변수를 추가하면 소프트웨어가 오류를 발생시킵니다.
         레시피 인터페이스가 변경되면 런타임 오류가 발생할 수 있습니다.
         다른 하나가 지어진 후에.

### `SIGGEN_LOCKEDSIGS`

     잠긴 작업 목록은 다음과 같은 형식입니다.

       SIGGEN_LOCKEDSIGS += "<패키지>:<작업>:<서명>"

     지정된 `<작업>`` 및 `<패키지>``에 대해 `<서명>``이 존재하는 경우
     sstate 캐시에서 BitBake는 캐시된 출력을 사용합니다.
     ``<task>``를 다시 빌드합니다. 존재하지 않으면 BitBake가 빌드합니다.
     ``<task>`` 그러면 다음번에 sstate 캐시가 사용됩니다.

     예::

       SIGGEN_LOCKEDSIGS += "bc:do_compile:09772aa4532512baf96d433484f27234d4b7c11dd9cda0d6f56fa1b7ce6f25f0"

     레시피 ``bc``에 대한 모든 작업의 ​​서명은 다음을 사용하여 얻을 수 있습니다.

       bitbake -S 없음 bc

     그런 다음 ``build/tmp/stamps/<arch>/bc``에 있는 파일을 살펴보고 찾을 수 있습니다.
     다음과 같은 파일: ``<PV>.do_compile.sigdata.09772aa4532512baf96d433484f27234d4b7c11dd9cda0d6f56fa1b7ce6f25f0``.

     또는 :doc:`bblock </dev-manual/bblock>`을 사용할 수도 있습니다.
     이 줄을 생성해 드리겠습니다.

   :용어:`SIGGEN_LOCKEDSIGS_TASKSIG_CHECK`
     작업 서명 검사의 디버그 수준을 지정합니다. 3가지 수준이 지원됩니다.

     * ``정보``: 작업이 잠겨 있음을 사용자에게 알리는 "참고" 메시지를 표시합니다.
       현재 서명이 잠긴 서명과 일치합니다.
     * ``warn``: 작업이 잠겨 있고 현재 작업이 잠겨 있는 경우 "경고" 메시지를 표시합니다.
       서명이 잠긴 서명과 일치하지 않습니다.
     * ``error``: 경고와 동일하지만 "오류" 메시지를 표시하고 종료합니다.

   :용어:`SIGGEN_LOCKEDSIGS_TYPES`
     `SIGGEN_LOCKEDSIGS`에 대한 허용된 재정의입니다. 이는 주로 사용됩니다.
     아키텍처별 잠금에 사용됩니다. 일반적인 값은 다음과 같습니다.
     `SIGGEN_LOCKEDSIGS_TYPES`는 ``${PACKAGE_ARCHS}``입니다::

       SIGGEN_LOCKEDSIGS_TYPES += "${PACKAGE_ARCHS}"

       SIGGEN_LOCKEDSIGS_core2-64 += "bc:do_compile:09772aa4532512baf96d433484f27234d4b7c11dd9cda0d6f56fa1b7ce6f25f0"
       SIGGEN_LOCKEDSIGS_cortexa57 += "bc:do_compile:12178eb6d55ef602a8fe638e49862fd247e07b228f0f08967697b655bfe4bb61"

     여기서 `bc`의 `do_compile` 작업은 특정 시점에만 잠금 처리됩니다.
     ``core2-64`` 및 ``cortexa57``에는 적용되지만 다른 아키텍처에는 적용되지 않습니다.
     ``mips32r2``.

### `SITEINFO_BITS`

      대상 시스템 CPU의 비트 수를 지정합니다. 값
      "32" 또는 "64"여야 합니다.

### `SITEINFO_ENDIANNESS`

      대상 시스템의 엔디안 바이트 순서를 지정합니다. 값
      리틀 엔디안의 경우 "le", 빅 엔디안의 경우 "be"여야 합니다.

### `SKIP_FILEDEPS`

      RPM 패키지의 "Provides" 섹션에서 모든 파일을 제거할 수 있도록 합니다.
      패키지에 포함된 파일들을 삭제하려면 해당 파일들을 제거해야 합니다.
      `libstdc++` 및 `glibc`와 같은 미리 빌드된 바이너리 및 라이브러리.

      파일 삭제를 활성화하려면 변수를 "1"로 설정하십시오.
      `conf/local.conf` 설정 파일은 다음 위치에 있습니다.
      `디렉토리 빌드`::

         SKIP_FILEDEPS = "1"

### `SKIP_RECIPE`

      OpenEmbedded 빌드 시스템이 특정 버전을 빌드하지 못하도록 방지하는 데 사용됩니다.
      레시피. `PN` 값을 변수 플래그(``varflag``)로 지정합니다.
      그리고 사유를 제공해 주십시오. 해당 사유는 시도 시 보고될 것입니다.
      레시피를 만들어 보세요.

      레시피 생성을 방지하려면 `SKIP_RECIPE` 명령어를 사용하세요.
      `local.conf` 파일 또는 배포판 구성에 있는 변수입니다.
      다음은 `myrecipe`가 빌드되지 않도록 하는 예시입니다.

         SKIP_RECIPE[myrecipe] = "저희 기관에서 지원하지 않는 레시피입니다."

### `SOC_FAMILY`

      동일한 기능을 가진 기계들을 콜론으로 구분하여 그룹화한 목록입니다.
      SoC(시스템 온 칩) 제품군입니다. 일반적으로 이 변수는 다음과 같이 설정합니다.
      모든 구성 파일에 포함하는 공통 ``.inc`` 파일
      기계들.

      .. 메모::

         이를 위해서는 `conf/machine/include/soc-family.inc` 파일을 포함해야 합니다.
         `MACHINEOVERRIDES`에 나타날 변수입니다.

### `SOLIBS`

      대상 플랫폼에서 사용되는 공유 라이브러리의 접미사를 정의합니다.
      기본적으로 모든 Linux 기반 시스템에서 이 접미사는 ".so.*"입니다.
      ``meta/conf/bitbake.conf`` 설정 파일에 정의되어 있습니다.

      기본값에서 이 변수가 참조되는 것을 볼 수 있습니다.
      ``파일:${PN}``.

### `SOLIBSDEV`

      개발 심볼릭 링크(symlink)에 사용할 접미사를 정의합니다.
      대상 플랫폼의 공유 라이브러리입니다. 기본적으로 이 접미사는 다음과 같습니다.
      리눅스 기반 시스템의 경우 ".so" 파일이며 다음과 같이 정의됩니다.
      ``meta/conf/bitbake.conf`` 설정 파일입니다.

      기본값에서 이 변수가 참조되는 것을 볼 수 있습니다.
      ``파일:${PN}-dev``.

### `SOURCE_DATE_EPOCH`

      이는 특정 시점 이후 경과된 시간을 초 단위로 나타낸 것입니다.
      UNIX EPOCH(1970년 1월 1일 00:00:00 UTC)는 다음과 같은 데서 사용됩니다.
      여러 빌드 시스템에서 빌드된 바이너리에 타임스탬프를 강제로 포함시키는 기능.
      이미 많은 상위 프로젝트에서 이 변수를 지원하고 있습니다.

      자세한 내용은 공식 사양서를 참조하십시오.
      <https://reproducible-builds.org/specs/source-date-epoch/>`__.

      각 레시피에 대한 값은 소스를 기반으로 계산됩니다.
      :oe_git:`meta/lib/oe/reproducible.py </openembedded-core/tree/meta/lib/oe/reproducible.py>`.

      레시피에서 기본 동작을 재정의하려면 해당 설정을 지정해야 합니다.
      자체 `SOURCE_DATE_EPOCH` 값::

          SOURCE_DATE_EPOCH = "1613559011"

### `SOURCE_MIRROR_FETCH`

      소스의 미러를 생성하기 위해 파일을 가져올 때 (예:
      소스 미러를 생성하는 경우, `SOURCE_MIRROR_FETCH`를 "1"로 설정합니다.
      `local.conf` 설정 파일은 모든 소스에 대한 설정을 보장합니다.
      레시피가 있는지 여부와 관계없이 레시피가 가져와집니다.
      구성과 호환됩니다. 레시피는 다음과 같이 간주됩니다.
      현재 구성된 시스템과 호환되지 않습니다.
      `COMPATIBLE_MACHINE` 둘 다
      변수 및 `COMPATIBLE_HOST` 변수
      현재 기기 이외의 기기와의 호환성을 지정합니다.
      머신 또는 호스트.

      .. 메모::

         `SOURCE_MIRROR_FETCH`를 설정하지 마십시오.
         소스 미러를 생성하는 경우가 아니라면 변수를 사용하지 않습니다. 다시 말해,
         일반 빌드 과정에서는 해당 변수를 설정하지 마십시오.

### `SOURCE_MIRROR_URL`

      `PREMIRRORS`를 정의하여 그 기준점으로 사용합니다.
      업스트림에서 가져오기를 시도하기 전에 먼저 소스 코드를 가져옵니다.
      `SRC_URI`에 지정되어 있습니다.

      이 변수를 사용하려면 전역적으로 상속해야 합니다.
      :ref:`ref-classes-own-mirrors` 클래스를 제공한 다음 제공합니다.
      미러 서버의 URL입니다. 일반적인 구문은 다음과 같습니다.

         INHERIT += "자체 미러"
         SOURCE_MIRROR_URL = "http://example.com/my_source_mirror"

      .. 메모::

         `SOURCE_MIRROR_URL`에는 하나의 URL만 지정할 수 있습니다.

      .. 메모::

         미러 서버가 사용자 이름과 비밀번호로 보호되어 있는 경우,
         빌드 호스트를 구성해야 빌드 시스템이 작동합니다.
         `<OpenEmbedded Build System>`은 미러에서 가져올 수 있습니다.

         권장되는 방법은 다음과 같은 매개변수를 설정하는 것입니다.
         `$HOME/.netrc` 파일에서 (`$HOME`은 빌드 호스트의 홈 디렉토리입니다)
         예배 규칙서)::

            머신 예제.com
            로그인 <사용자>
            비밀번호 <비밀번호>

         이 파일은 접근을 차단하기 위해 권한을 ``400`` 또는 ``600``으로 설정해야 합니다.
         다른 사용자가 파일을 읽는 것을 막습니다.

            chmod 600 "$HOME/.netrc"

         사용자 이름과 비밀번호를 설정하는 또 다른 방법은 URL을 이용하는 것입니다.
         `user`와 `pswd`를 사용하여 `SOURCE_MIRROR_URL`에 직접 입력합니다.
         매개변수::

            SOURCE_MIRROR_URL = "http://example.com/my_source_mirror;user=<user>;pswd=<password>"

### `SPDX_ARCHIVE_PACKAGED`

      이 옵션을 사용하면 `SPDX` 출력에 압축 아카이브를 추가할 수 있습니다.
      생성된 대상 패키지에 포함된 파일들 중 일부입니다.

      그러한 자료는 다음에서 이용 가능합니다.
      ``tmp/deploy/spdx/MACHINE/packages/packagename.tar.zst``
      빌드 디렉터리 아래에 있습니다.

      다음과 같이 이 옵션을 활성화하세요::

         SPDX_ARCHIVE_PACKAGED = "1"

      릴리스 4.1 "langdale"에 대한 테스트 결과에 따르면, 빌드는 다음과 같습니다.
      ``qemux86-64`` 머신용 ``core-image-minimal``을 활성화하면 다음과 같은 기능이 활성화됩니다.
      이 옵션은 ``tmp/deploy/spdx`` 디렉터리의 크기를 곱합니다.
      단순히 사용하는 것과 비교했을 때 13배(이 이미지의 경우 +1.6GiB) 더 큽니다.
      :ref:`ref-classes-create-spdx` 클래스에 옵션이 없습니다.

      참고로 이 옵션은 `SPDX`의 크기를 늘리지 않습니다.
      ``tmp/deploy/images/MACHINE``에 있는 파일입니다.

### `SPDX_ARCHIVE_SOURCES`

      이 옵션을 사용하면 `SPDX` 출력에 압축 아카이브를 추가할 수 있습니다.
      대상 시스템에 설치된 패키지의 소스 중 하나입니다. 현재는
      `SPDX_INCLUDE_SOURCES`가 설정된 경우에만 작동합니다.

      이는 "소스 코드 접근" 라이선스를 충족하는 한 가지 방법입니다.
      요구 사항.

      이러한 소스 아카이브는 다음에서 이용 가능합니다.
      ``tmp/deploy/spdx/MACHINE/recipes/recipe-packagename.tar.zst``
      빌드 디렉터리 아래에 있습니다.

      다음과 같이 이 옵션을 활성화하세요::

         SPDX_INCLUDE_SOURCES = "1"
         SPDX_ARCHIVE_SOURCES = "1"

      릴리스 4.1 "langdale"에 대한 테스트 결과에 따르면, 빌드는 다음과 같습니다.
      ``qemux86-64`` 머신용 ``core-image-minimal``을 활성화합니다.
      이러한 옵션들은 ``tmp/deploy/spdx``의 크기를 크게 늘렸습니다.
      디렉토리 크기가 11배 증가합니다(+이 이미지의 경우 1.4GiB 증가).
      단순히 `ref-classes-create-spdx`를 사용하는 것과 비교했을 때
      선택 사항이 없는 수업.

      참고로 이 옵션을 사용해도 크기가 아주 약간만 증가합니다.
      `tmp/deploy/images/MACHINE/`에 있는 `SPDX` 출력의 일부
      (+ 테스트 이미지에서 0.07% 증가), 단순히 활성화만 한 경우와 비교
      `SPDX_INCLUDE_SOURCES`.

### `SPDX_CUSTOM_ANNOTATION_VARS`

      이 옵션을 사용하면 `SPDX 주석`을 연결할 수 있습니다.
      <https://spdx.github.io/spdx-spec/v2.3/annotations/>`__를 레시피에 추가합니다.
      레시피에 있는 변수 값을 사용하여::

         ANNOTATION1 = "레시피에 대한 첫 번째 주석"
         ANNOTATION2 = "레시피에 대한 두 번째 주석"
         SPDX_CUSTOM_ANNOTATION_VARS = "ANNOTATION1 ANNOTATION2"

      이렇게 하면 레시피 ``.sdpx.json`` 출력에 새 블록이 추가됩니다.

         "주석": [
           {
             "annotationDate": "2023-04-18T08:32:12Z",
             "annotationType": "기타",
             "주석 작성자": "도구: oe-spdx-creator - 1.0",
             "댓글": "ANNOTATION1=레시피에 대한 첫 번째 주석"
           },
           {
             "annotationDate": "2023-04-18T08:32:12Z",
             "annotationType": "기타",
             "주석 작성자": "도구: oe-spdx-creator - 1.0",
             "댓글": "ANNOTATION2=레시피에 대한 두 번째 주석"
           }
         ],

### `SPDX_INCLUDE_COMPILED_SOURCES`

      이 옵션은 `SPDX_INCLUDE_SOURCES`와 동일한 기능을 제공하지만, 소스를 포함합니다.
      호스트 도구와 대상 패키지를 컴파일하는 데 사용된 소스 코드만 포함됩니다.
      `SPDX_INCLUDE_SOURCES`는 소스의 모든 파일을 포함합니다.
      디렉토리를 소스 파일 설명으로 사용, `SPDX_INCLUDE_COMPILED_SOURCES`
      제공되는 바이너리를 생성하는 데 사용된 소스만 포함합니다.
      패키지 형태로 제공됩니다. 컴파일 과정에서 사용되지 않는 소스 파일은 포함되지 않습니다.
      SBOM에 포함되어 있습니다. 디버그 소스 정보가 생성되는 동안 해당 정보를 사용합니다.
      `do_package`를 사용하여 소스 파일을 필터링합니다.

      이를 통해 외부 도구는 SPDX 정보를 사용하여 무시할 수 있습니다.
      패키지에 컴파일되지 않은 취약점.

      다음과 같이 이 옵션을 활성화하세요::

         SPDX_INCLUDE_COMPILED_SOURCES = "1"

      SPDX 2.2 형식(릴리스 4.1 "langdale")의 경우, 빌드
      ``qemux86-64`` 머신의 경우 ``core-image-minimal`` 옵션은 다음과 같습니다.
      ``tmp/deploy/spdx`` 디렉터리의 크기를 2GB에서 줄였습니다.
      1.6GB는 `SPDX_INCLUDE_SOURCES`와 비교했을 때, 다음 항목만 포함하기 때문입니다.
      원본 소스 파일 없이 컴파일된 객체입니다.

      SPDX 3.0.1 JSON 형식에서 이 옵션을 활성화하면 두 가지 모두 포함됩니다.
      컴파일된 소스 및 원본 소스 파일(동일함)
      ``SPDX_INCLUDE_SOURCES = "1"``)로 인해 크게 증가합니다.
      SBOM 크기. 예를 들어, `core-image-minimal` 옵션을 켜면
      ``qemux86-64``에서 압축되지 않은 SBOM 파일은 수백 개에 달할 수 있습니다.
      메가바이트에서 수 기가바이트에 이릅니다.

### `SPDX_INCLUDE_SOURCES`

      이 옵션을 사용하면 빌드에 사용된 소스 파일에 대한 설명을 추가할 수 있습니다.
      호스트 도구와 대상 패키지를 ``spdx.json`` 파일에 추가합니다.
      빌드 디렉터리 아래의 ``tmp/deploy/spdx/MACHINE/recipes/`` 경로입니다.
      결과적으로 `by-namespace` 아래의 `spdx.json` 파일과
      `tmp/deploy/spdx/MACHINE` 내의 `packages` 하위 디렉터리도 마찬가지입니다.
      해당 소스 파일 설명에 대한 참조를 포함하도록 수정되었습니다.

      다음과 같이 이 옵션을 활성화하세요::

         SPDX_INCLUDE_SOURCES = "1"

      SPDX 2.2 형식(릴리스 4.1 "langdale")의 경우, 빌드
      ``qemux86-64`` 머신용 ``core-image-minimal``을 활성화합니다.
      이 옵션은 ``tmp/deploy/spdx``의 전체 크기를 증가시킵니다.
      디렉토리 크기가 3배 증가합니다(+291MiB, 이 이미지 용량 증가).
      그리고 ``IMAGE-MACHINE.spdx.tar.zst``의 크기는 다음과 같습니다.
      `tmp/deploy/images/MACHINE` 파일 크기가 130배 증가합니다(+15MiB 추가).
      이미지)를 사용하는 것과 비교했을 때, 단순히 :ref:`ref-classes-create-spdx` 클래스를 사용하는 것과 비교됩니다.
      선택의 여지가 없습니다.

      SPDX 3.0.1 JSON 형식에서는 소스 파일을 포함하여 상당한 개선이 이루어졌습니다.
      SBOM 크기가 증가합니다(일반적인 경우 수 기가바이트까지 증가할 수 있음).
      이미지).

### `SPDX_LICENSES`

      SPDX 라이선스 식별자 매핑이 포함된 JSON 파일의 경로입니다.
      이 파일은 일반적인 라이선스 이름을 공식 SPDX 라이선스에 매핑합니다.
      SBOM 생성 중에 사용되는 식별자입니다.

      기본값은 정의된 라이선스 매핑의 복사본을 가리킵니다.
      SPDX(https://github.com/spdx/license-list-data)에서 저장됨
      `OpenEmbedded-Core(OE-Core)`.

      이 변수를 재정의하여 사용자 지정 라이선스 매핑 파일을 사용할 수 있습니다.
      조직에서 서로 다른 라이선스 명명 규칙을 사용하는 경우.

### `SPDX_MULTILIB_SSTATE_ARCHS`

      SPDX를 수집할 때 고려해야 할 sstate 아키텍처 목록
      종속성. 여기에는 multilib가 사용될 때 multilib 아키텍처가 포함됩니다.
      활성화됨.

      기본값은 ``SSTATE_ARCHS`` 값으로 설정됩니다.

      이 변수는 SPDX 생성 클래스에서 내부적으로 사용됩니다.
      SBOM에 모든 관련 종속성이 포함되어 있는지 확인하십시오.
      multilib이 활성화되어 있는지 여부와 관계없이.

### `SPDX_NAMESPACE_PREFIX`

      이 옵션은 `spdxDocument`의 접두사를 변경하는 데 사용할 수 있습니다.
      그리고 `documentNamespace`의 접두사입니다. 기본값은 다음과 같습니다.
      ``http://spdx.org/spdxdoc``.

### `SPDX_PACKAGE_URL`

      SPDX 데이터 생성자가 패키지 URL을 기록할 수 있는 공간을 제공합니다.
      문자열(``software_packageUrl``, 패키지 URL에 따라)
      소프트웨어 패키지에 대한 사양입니다. 이 변수의 기본값은 다음과 같습니다.
      빈 문자열입니다.

### `SPDX_PACKAGE_VERSION`

      이 변수는 SPDX 3.0 JSON에 표시되는 패키지 버전을 제어합니다.
      출력(``software_packageVersion``). 이 변수의 기본값
      `PV`입니다.

### `SPDX_PRETTY`

      이 옵션은 SPDX 출력을 보다 사람이 읽기 쉽게 만들어 줍니다.
      기본 출력 대신 들여쓰기와 줄 바꿈이 포함됩니다.
      한 줄::

         SPDX_PRETTY = "1"

      생성된 SPDX 파일의 크기는 약 20% 정도 더 커집니다.
      SPDX를 검사하려면 이 옵션을 사용하는 것이 좋습니다.
      텍스트 편집기를 사용하여 출력 파일을 엽니다.

### `SPDX_UUID_NAMESPACE`

      SPDX 문서에서 UUID를 생성하는 데 사용되는 네임스페이스입니다.
      도메인 이름 또는 조직의 고유 식별자여야 합니다.
      서로 다른 빌드에서 전 세계적으로 고유한 SPDX ID를 보장하기 위해
      조직들.

      기본값은 OpenEmbedded에서 관리하는 도메인으로 설정되어 있습니다.
      프로젝트입니다. 조직의 도메인을 사용하도록 이 설정을 재정의할 수 있습니다.

### `SPDXLICENSEMAP`

      일반적으로 사용되는 맵의 라이선스 이름은 SPDX에서 찾을 수 있는 해당 라이선스 이름과 동일합니다.
      ``meta/files/common-licenses/``. 기본값 `SPDXLICENSEMAP`의 경우
      매핑에 대한 자세한 내용은 ``meta/conf/licenses.conf`` 파일을 참조하십시오.

      자세한 내용은 라이선스 문서를 참조하십시오.
      변하기 쉬운.

### `SPECIAL_PKGSUFFIX`

      OpenEmbedded에서 사용하는 `PN` 접두사 목록
      레시피 또는 패키지의 변형을 생성하는 빌드 시스템. 목록
      특정 상황에서 제거할 접두사를 지정합니다.
      `BPN` 변수의 생성과 같습니다.

### `SPL_BINARY`

      보조 프로그램 로더(SPL)의 파일 형식입니다. 일부 장치에서는
      부팅할 SPL을 사용합니다(예: BeagleBone 개발).
      보드). 이러한 경우 SPL의 파일 형식을 선언할 수 있습니다.
      `u-boot.inc` 헤더 파일에 있는 바이너리 파일은 다음에서 사용됩니다.
      U-Boot 레시피.

      `u-boot.inc` 파일에서 SPL 파일 형식은 기본적으로 "null"로 설정되어 있습니다.
      다음과 같이 파일을 작성하십시오::

         # 일부 u-boot 버전에서는 SPL(Second Program Loader) 이미지를 빌드합니다.
         # u-boot 바이너리와 함께 패키징되어야 하며, 해당 위치에 배치되어야 합니다.
         # 배포 디렉터리. 해당 버전에서는 다음 변수를 설정할 수 있습니다.
         # SPL 패키징을 허용합니다.
         SPL_BINARY ?= ""
         SPL_BINARYNAME ?= "${@os.path.basename(d.getVar("SPL_BINARY"))}"
         SPL_IMAGE ?= "${SPL_BINARYNAME}-${MACHINE}-${PV}-${PR}"
         SPL_SYMLINK ?= "${SPL_BINARYNAME}-${MACHINE}"

      `SPL_BINARY` 변수는 형식을 지정하는 데 도움이 됩니다.
      OpenEmbedded 빌드 시스템에서 사용되는 다양한 ``SPL_*`` 변수.

      BeagleBone 머신 구성 예시는 다음을 참조하세요.
      ":ref:`dev-manual/layers:\`\`bitbake-layers\`\` 스크립트를 사용하여 레이어 추가`"
      Yocto 프로젝트 보드 지원 패키지 개발자 가이드의 해당 섹션
      추가 정보는 다음을 참조하십시오.

### `SPL_DTB_BINARY`

      :ref:`ref-classes-uboot-sign` 클래스를 상속받을 때,
      `SPL_DTB_BINARY` 변수에는 실행할 SPL 바이너리의 이름이 포함됩니다.
      컴파일됨.

### `SPL_MKIMAGE_DTCOPTS`

      ``mkimage -D`` 기능에 전달되는 장치 트리 컴파일러 옵션
      :ref:`ref-classes-uboot-sign`을 사용하여 FIT 이미지를 생성하는 동안
      클래스입니다. `SPL_MKIMAGE_DTCOPTS`가 설정되지 않은 경우
      :ref:`ref-classes-uboot-sign` 클래스는 ``-D`` 옵션을 통과하지 못합니다.
      ``mkimage``로 이동합니다.

      :ref:`ref-classes-uboot-config`에 의해 기본값은 ""로 설정됩니다.
      수업.

### `SPL_SIGN_ENABLE`

      U-Boot FIT 이미지 서명을 활성화합니다. 기본값은 "0"입니다.
      이 변수는 :ref:`ref-classes-uboot-sign` 클래스에서 사용됩니다.

### `SPL_SIGN_KEYDIR`

      RSA 키와 인증서가 포함된 디렉터리의 위치
      :ref:`ref-classes-uboot-sign`에서 사용되는 U-Boot FIT 이미지에 서명합니다.
      수업.

### `SPL_SIGN_KEYNAME`

      :ref:`ref-classes-uboot-sign` 클래스에서 사용되는 키의 이름
      `SPL_SIGN_KEYDIR`에 저장된 U-Boot FIT 이미지에 서명하기 위한 것입니다.
      디렉토리입니다. 예를 들어 `dev.key`라는 키와 `dev.crt`라는 파일이 있다고 가정해 보겠습니다.
      인증서는 `SPL_SIGN_KEYDIR` 디렉터리에 저장됩니다.
      `SPL_SIGN_KEYNAME`을 ``dev``로 설정해야 합니다.

### `SPLASH`

      :ref:`ref-classes-image` 클래스에서 사용되는 이 변수는 다음을 허용합니다.
      스플래시 화면 애플리케이션을 선택하려면 패키지 이름으로 설정하세요.
      이러한 애플리케이션에서 사용하기 위한 것입니다. 이 변수는 기본적으로 다음과 같이 설정됩니다.
      ``psplash``.

### `SPLASH_IMAGES`

      `psplash` 레시피에서 사용되는 이 변수를 통해 사용자 정의가 가능합니다.
      기본 시작 화면 이미지입니다.

      지정된 PNG 형식 이미지는 해당 레시피에 의해 ``.h`` 파일로 변환됩니다.
      그리고 이 파일들은 ``psplash`` 바이너리에 포함되어 있으므로, 해당 파일들은 별도의 디렉토리에서 찾을 수 없습니다.
      루트 파일 시스템.

      이러한 변경을 하려면 사용자 정의하는 것이 좋습니다.
      사용자 정의 레이어의 ``psplash`` 레시피입니다. 다음은 예시 구조입니다.
      ACME 이사회::

          메타-아크미/레시피 코어/psplash
          â”œâ”€â”€ 파일
          â”‚Â Â â””â”€â”€ logo-acme.png
          â””â”€â”€ psplash_%.bbappend

      다음은 ``psplash_%.bbappend`` 파일의 내용입니다.
      이 예시::

          SPLASH_IMAGES = "file://logo-acme.png;outsuffix=default"
          FILESEXTRAPATHS:prepend := "${THISDIR}/files:"

      `psplash`에 대한 특정 구성 옵션을 추가할 수도 있습니다.
      예를 들어::

          EXTRA_OECONF += "--disable-startup-msg --enable-img-fullscreen"

      파일 추가에 대한 자세한 내용은 다음을 참조하세요.
      ":ref:`개발자 설명서/레이어:다른 레이어의 메타데이터를 내 레이어에 추가하기`"
      부분.

### `SRC_URI`

      이 변수에 대한 초기 설명은 BitBake 설명서를 참조하십시오.
      `bitbake:SRC_URI`.

      OpenEmbedded와 Yocto Project에서 다음과 같은 기능을 추가했습니다.

      기본 옵션과 레시피별 옵션이 있습니다. 기본 옵션은 다음과 같습니다.

      - ``apply`` --- 패치를 적용할지 여부. 기본값은 입니다.
         조치는 패치를 적용하는 것입니다.

      - ``striplevel`` --- 적용 시 사용할 striplevel을 지정합니다.
         패치. 기본 레벨은 1입니다.

      - ``patchdir`` --- 패치가 저장될 디렉토리를 지정합니다.
         적용됩니다. 기본값은 ``${``\ `S`\ ``}``입니다.

      다음은 수정된 버전에서 레시피를 빌드하는 코드에 특화된 옵션입니다.
      제어 시스템:

      - ``mindate`` --- 다음 조건에 해당하는 경우에만 패치를 적용합니다.
         `SRCDATE`는 다음과 같거나 큽니다.
         ``mindate``.

      - `maxdate` --- `SRCDATE`가 그 이후가 아닌 경우에만 패치를 적용합니다.
         `maxdate`보다.

      - ``minrev`` --- `SRCREV`가 또는 와 같을 경우에만 패치를 적용합니다.
         ``minrev``보다 큽니다.

      - ``maxrev`` --- `SRCREV`가 나중이 아닌 경우에만 패치를 적용합니다.
         `maxrev`보다.

      - ``rev`` --- `SRCREV`가 같은 경우에만 패치를 적용합니다.
         ``rev``.

      - ``notrev`` --- `SRCREV`가 같지 않은 경우에만 패치를 적용합니다.
         ``rev``.

      .. 메모::

         빌드 시스템이 지정된 파일을 사용하도록 하려면
         추가 파일에서 `SRC_URI` 문을 사용하려면 다음이 필요합니다.
         `FILESPATH` 변수를 확장하려면 다음을 함께 사용해야 합니다.
         추가 파일 내의 `FILESEXTRAPATHS` 변수를 사용하십시오.

### `SRC_URI_OVERRIDES_PACKAGE_ARCH`

      기본적으로 OpenEmbedded 빌드 시스템은 자동으로 감지합니다.
      `SRC_URI`에 기기별 파일이 포함되어 있는지 여부를 확인합니다. 만약 그렇다면,
      빌드 시스템은 자동으로 `PACKAGE_ARCH`를 변경합니다. 이 값을 설정하려면 다음을 수행하십시오.
      변수를 "0"으로 설정하면 이 동작이 비활성화됩니다.

### `SRCDATE`

      패키지를 빌드하는 데 사용된 소스 코드의 날짜입니다. 이 변수는
      소스 코드가 소스 코드 관리자를 통해 가져온 경우에만 적용됩니다.
      (SCM).

### `SRCPV`

      변수 `SRCPV`는 더 이상 사용되지 않습니다. 이전에는 다음과 같은 용도로 사용되었습니다.
      Bitbake의 경우 PV에 소스 제어 정보를 포함시키려면
      정상적으로 작동하지만 더 이상 필수 사항은 아닙니다. 소스 제어
      정보는 `bitbake`에 의해 자동으로 포함됩니다.
      패키징 중에 변수 `PKGV`가 ``+`` 기호가 있는 경우
      `PV`.

      .. 메모::

         `SRCPV` 변수는 이전에 다음과 같이 정의되었습니다.
         ``meta/conf/bitbake.conf`` 구성 파일(`소스`)
         디렉토리는 다음과 같습니다.

            SRCPV = "${@bb.fetch2.get_srcrev(d)}"

         ``get_srcrev`` 함수는 소스 제어를 포함하는 데 여전히 사용할 수 있습니다.
         변수에 정보를 수동으로 입력합니다.

### `SRCREV`

      패키지 빌드에 사용된 소스 코드의 수정 버전입니다.
      이 변수는 Subversion, Git, Mercurial 및 Bazaar에만 적용됩니다. 참고
      고정된 버전을 만들고 싶고 피하고 싶다면
      BitBake가 파싱할 때마다 원격 저장소에 대한 쿼리를 수행합니다.
      레시피를 작성할 때는 전체 수정 버전을 나타내는 `SRCREV`라는 용어를 지정해야 합니다.
      식별자(예: Git의 전체 SHA 해시)이며 단순히 태그가 아닙니다.

      .. 메모::

         최신 버전을 상속할 때의 제한 사항에 대한 정보는 다음을 참조하십시오.
         `SRCREV`를 사용하는 소프트웨어에 대해서는 `AUTOREV` 변수를 참조하십시오.
         설명과
         ":ref:`dev-manual/packages:패키지 버전 번호를 자동으로 증가시키는 방법`"
         Yocto 프로젝트 개발 작업 매뉴얼에 있는 섹션입니다.

### `SRCREV_FORMAT`

      BitBake 설명서에서 `bitbake:SRCREV_FORMAT`을 참조하십시오.

### `SRCTREECOVEREDTASKS`

      일반적으로 관련성이 없어 생략되는 작업 목록
      `ref-classes-externalsrc`를 사용하여 빌드할 때
      클래스입니다. 해당 클래스 파일에 설정된 기본값은 작업 집합입니다.
      외부 소스를 사용할 때 거의 필요하지 않은 사항입니다.

         SRCTREECOVEREDTASKS ?= "do_patch do_unpack do_fetch"

      주목할 만한 예외는 외부 커널 소스를 처리할 때입니다.
      :ref:`ref-classes-kernel-yocto` 클래스 파일에 정의됨(형식은 다음과 같음)
      미학)::

         SRCTREECOVEREDTASKS += "\
           do_validate_branches \
           do_kernel_configcheck \
           do_kernel_checkout \
           do_fetch \
           do_unpack \
           do_patch \
         "

      관련 항목인 `EXTERNALSRC` 및 `EXTERNALSRC_BUILD`를 참조하십시오.
      자세한 내용은 변수를 참조하세요.

### `SSTATE_DIR`

      공유 상태 캐시의 디렉터리입니다.

### `SSTATE_EXCLUDEDEPS_SYSROOT`

      이 변수를 사용하면 제외할 간접 종속성을 지정할 수 있습니다.
      예를 들어 sysroots에서 종속성으로 인해 발생하는 상황을 방지하기 위해
      `-native`가 포함된 레시피는 해당 레시피의 모든 종속성을 가져옵니다.
      레시피의 sysroot에서 이러한 동작이 나타납니다. 하지만 이러한 동작이 항상 바람직한 것은 아닐 수도 있습니다.
      예를 들어 `-native` 레시피가 빌드 도구에 의존하는 경우
      현재 레시피와 관련이 없는 것들입니다.

      이렇게 하면 불필요한 종속성이 무시되므로 문제가 발생하지 않습니다.
      공유 폴더에 저장된 사전 구축된 아티팩트의 재사용을 방지했습니다.
      상태 캐시.

      `SSTATE_EXCLUDEDEPS_SYSROOT`는 두 개의 일반 항목으로 평가됩니다.
      무시할 레시피 및 종속성 표현. 예시
      :oe_git:`meta/conf/layer.conf </openembedded-core/tree/meta/conf/layer.conf>`에 있는 규칙은 무엇입니까?

         # libc-initial에 의존할 필요가 전혀 없습니다.
         # base-passwd/shadow-sysroot는 종속성이 필요하지 않습니다.
         SSTATE_EXCLUDEDEPS_SYSROOT += "\
             .*->.*-초기.* \
             .*(base-passwd|shadow-sysroot)->.* \
         "

      ``->`` 부분 문자열은 두 요소 간의 의존성을 나타냅니다.
      두 개의 정규 표현식.

### `SSTATE_MIRROR_ALLOW_NETWORK`

      "1"로 설정하면 지정된 미러에서 가져오기를 허용합니다.
      `SSTATE_MIRRORS`가 다음과 같은 경우에도 작동하도록
      `BB_NO_NETWORK`를 설정하면 네트워크에서 데이터를 가져오는 기능이 비활성화됩니다.
      "1". `SSTATE_MIRROR_ALLOW_NETWORK` 변수를 사용하는 것은 다음과 같은 경우에 유용합니다.
      `SSTATE_MIRRORS`를 내부 서버를 가리키도록 설정했습니다.
      공유 상태 캐시를 사용하지만 다른 모든 가져오기 작업은 비활성화하고 싶습니다.
      네트워크에서 가져온 것입니다.

### `SSTATE_MIRRORS`

      OpenEmbedded 빌드 시스템이 다른 미러를 검색하도록 구성합니다.
      미리 구축된 캐시 데이터 객체의 위치를 ​​빌드하기 전에
      데이터. 이 변수는 fetcher `MIRRORS`처럼 작동합니다.
      그리고 `PREMIRRORS`는 캐시를 가리킵니다.
      공유 상태(sstate) 객체를 확인할 위치입니다.

      파일 시스템 디렉터리 또는 HTTP와 같은 원격 URL을 지정할 수 있습니다.
      또는 FTP를 사용하세요. 지정하는 위치에는 공유 상태가 포함되어 있어야 합니다.
      캐시(sstate-cache)에는 이전 빌드 결과가 저장됩니다.
      당신이 지적한 내용은 다른 컴퓨터에서 빌드된 것일 수도 있습니다.

      다른 머신에서 sstate 빌드 아티팩트를 가리킬 때
      네이티브 빌드에 다른 GCC 버전을 사용하려면 구성해야 합니다.
      로컬 검색을 매핑하는 정규 표현식을 사용하는 `SSTATE_MIRRORS`
      서버 경로에 대한 경로입니다. 경로에는 다음 사항을 고려해야 합니다.
      `NATIVELSBSTRING`은 :ref:`ref-classes-uninative` 클래스에 의해 설정됩니다.
      예를 들어, 다음은 로컬 검색 경로 ``universal-4.9``를 매핑합니다.
      서버에서 제공하는 경로 server_url_sstate_path::로

         SSTATE_MIRRORS ?= "file://universal-4.9/(.*) https://server_url_sstate_path/universal-4.8/\1"

      거울이 다음과 같은 구조를 사용한다면
      `SSTATE_DIR`의 경우 "PATH"를 추가해야 합니다.
      아래 예시와 같이 끝납니다. 빌드 시스템은 이를 대체합니다.
      디렉토리 구조 내의 올바른 경로::

         SSTATE_MIRRORS ?= "\
             file://.* https://someserver.tld/share/sstate/PATH;downloadfilename=PATH \
             file://.* file:///some-local-dir/sstate/PATH"

      .. 메모::

         미러 서버가 사용자 이름과 비밀번호로 보호되어 있는 경우,
         빌드 호스트를 구성해야 빌드 시스템이 작동합니다.
         `<OpenEmbedded Build System>`은 sstate 캐시를 다운로드할 수 있습니다.
         입증.

         권장되는 방법은 다음과 같은 매개변수를 설정하는 것입니다.
         `$HOME/.netrc` 파일에서 (`$HOME`은 빌드 호스트의 홈 디렉토리입니다)
         예배 규칙서)::

            머신 someserver.tld
            로그인 <사용자>
            비밀번호 <비밀번호>

         이 파일은 접근을 차단하기 위해 권한을 ``400`` 또는 ``600``으로 설정해야 합니다.
         다른 사용자가 파일을 읽는 것을 막습니다.

            chmod 600 "$HOME/.netrc"

         사용자 이름과 비밀번호를 설정하는 또 다른 방법은 다음과 같습니다.
         ``SSTATE_MIRRORS`에 URL을 직접 입력하고 사용자 이름과 비밀번호를 지정합니다.
         매개변수::

            SSTATE_MIRRORS ?= "\
                file://.* https://someserver.tld/share/sstate/PATH;user=<user>;pswd=<password>;downloadfilename=PATH \
            "

      Yocto 프로젝트는 실제로 자체적으로 구축한 캐시 데이터 객체를 공유합니다.
      자동 빌더::

         SSTATE_MIRRORS ?= "file://.* http://sstate.yoctoproject.org/all/PATH;downloadfilename=PATH"

      따라서 바이너리 아티팩트는 범용 QEMU 시스템용으로 빌드됩니다.
      다양한 포키 릴리스의 지원을 받기 때문에 그럴 가능성이 더 낮습니다.
      실제 프로젝트에서 재사용 가능하며 특정 용도에 최적화된 바이너리를 생성합니다.
      CPU 제품군.

### `SSTATE_SCAN_FILES`

      OpenEmbedded 빌드 시스템이 검색하는 파일 목록을 제어합니다.
      하드코딩된 설치 경로. 해당 변수는 공백으로 구분된 경로를 사용합니다.
      표준 와일드카드 문자를 포함하는 파일 이름 목록(경로가 아님)
      허용된.

      빌드 과정에서 OpenEmbedded 빌드 시스템은 공유 상태를 생성합니다.
      (sstate) 객체는 sysroots를 준비하는 첫 번째 단계 동안 존재합니다.
      해당 객체는 최초 설치 시 하드코딩된 경로를 찾기 위해 스캔됩니다.
      위치. 경로를 검색하는 파일 목록은 제어됩니다.
      `SSTATE_SCAN_FILES` 변수를 통해. 일반적으로 레시피는 파일을 추가합니다.
      그들은 `SSTATE_SCAN_FILES` 값으로 스캔되기를 원합니다.
      변수가 포괄적으로 설정되는 것보다.
      :ref:`ref-classes-sstate` 클래스는 기본 파일 목록을 지정합니다.

      이 프로세스에 대한 자세한 내용은 :ref:`ref-classes-staging` 클래스를 참조하십시오.

### `SSTATE_SKIP_CREATION`

      ``SSTATE_SKIP_CREATION` 변수를 사용하면 생성 과정을 건너뛸 수 있습니다.
      :ref:`공유 상태 <overview-manual/concepts:공유 상태 캐시>` 생성
      tarball 파일. 예를 들어 이미지를 tar로 묶는 이미지 생성 작업에 적합합니다.
      그리고 그것들을 sstate 상태로 유지하면 디스크 공간을 많이 차지하게 됩니다.

      일반적으로 이 변수를 결측값으로 사용하는 것은 권장되지 않습니다.
      아티팩트는 빌드에 부정적인 영향을 미치며, 특히 다음 항목에 해당합니다.
      의존성 사슬의 중간 부분. 이것이 의미가 있는 경우는 다음과 같습니다.
      해당 아티팩트의 크기와 시간 비용은 단순히 실행하는 것과 유사합니다.
      작업. 이는 일반적으로 이미지와 같은 최종 결과물에만 적용됩니다.

      특정 작업에 대해 해당 기능을 비활성화하는 구문은 다음과 같습니다.

         SSTATE_SKIP_CREATION:task-image-complete = "1"

      레시피 전체에 대해 해당 기능을 비활성화하는 구문은 다음과 같습니다.

         SSTATE_SKIP_CREATION = "1"

### `STAGING_BASE_LIBDIR_NATIVE`

      sysroot의 ``/lib`` 하위 디렉터리에 대한 경로를 지정합니다.
      빌드 호스트의 디렉터리입니다.

### `STAGING_BASELIBDIR`

      sysroot의 ``/lib`` 하위 디렉터리에 대한 경로를 지정합니다.
      현재 레시피가 빌드되고 있는 대상에 대한 디렉터리입니다.
      (`스테이징_디렉터_호스트`).

### `STAGING_BINDIR`

      sysroot의 ``/usr/bin`` 하위 디렉터리의 경로를 지정합니다.
      현재 레시피가 빌드되고 있는 대상에 대한 디렉터리입니다.
      (`스테이징_디렉터_호스트`).

### `STAGING_BINDIR_CROSS`

      바이너리 구성 파일이 포함된 디렉터리의 경로를 지정합니다.
      스크립트. 이러한 스크립트는 다른 스크립트에 대한 구성 정보를 제공합니다.
      라이브러리를 사용하거나 파일을 포함하려는 소프트웨어
      스크립트와 연동된 소프트웨어에서 제공합니다.

      .. 메모::

         이러한 빌드 구성 방식은 대부분 다음으로 대체되었습니다.
         ``pkg-config``. 따라서 ``pkg-config``가 지원되는 경우
         링크하려는 라이브러리의 경우, 다음 라이브러리를 사용하는 것이 좋습니다.
         제공된 구성 스크립트 대신 ``pkg-config``를 사용합니다.

### `STAGING_BINDIR_NATIVE`

      sysroot의 ``/usr/bin`` 하위 디렉터리의 경로를 지정합니다.
      빌드 호스트의 디렉터리입니다.

### `STAGING_DATADIR`

      sysroot의 ``/usr/share`` 하위 디렉터리에 대한 경로를 지정합니다.
      현재 레시피가 빌드되고 있는 대상에 대한 디렉터리입니다.
      (`스테이징_디렉터_호스트`).

### `STAGING_DATADIR_NATIVE`

      sysroot의 ``/usr/share`` 하위 디렉터리에 대한 경로를 지정합니다.
      빌드 호스트의 디렉터리입니다.

### `STAGING_DIR`

      ``recipe-sysroot*`` 디렉터리를 구성하는 데 도움이 됩니다. 이 디렉터리는 다음과 같이 사용됩니다.
      포장 과정 중에.

      레시피별 시스템 루트 스테이징이 어떻게 진행되는지에 대한 정보는 다음을 참조하세요.
      :ref:`ref-tasks-populate_sysroot`를 참조하세요.
      작업, ":ref:`dev-manual/devtool:레시피 간 파일 공유`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션에서,
      ":ref:`개요 매뉴얼/개념:구성, 컴파일 및 스테이징`"
      Yocto 프로젝트 개요 및 개념 설명서의 해당 섹션과
      `SYSROOT_DIRS` 변수.

      .. 메모::

         레시피는 `STAGING_DIR` 디렉터리 바로 아래에 파일을 직접 작성해서는 안 됩니다.
         OpenEmbedded 빌드 시스템이 디렉토리를 관리하기 때문입니다.
         디렉토리가 자동으로 생성됩니다. 대신 파일은 다음 위치에 설치되어야 합니다.
         레시피의 :ref:`ref-tasks-install` 안에 ``${``\ `D`\ ``}``를 넣으세요.
         작업을 수행한 다음 OpenEmbedded 빌드 시스템은 일부 작업을 준비합니다.
         해당 파일들을 sysroot에 넣으세요.

### `STAGING_DIR_HOST`

      해당 시스템의 sysroot 디렉터리 경로를 지정합니다.
      해당 구성 요소는 (구성 요소를 호스팅하는 시스템에서) 실행되도록 설계되었습니다.
      대부분의 레시피에서 이 sysroot는 해당 레시피의 sysroot입니다.
      :ref:`ref-tasks-populate_sysroot` 작업 복사
      파일. 예외로는 ``-native`` 레시피가 있습니다.
      :ref:`ref-tasks-populate_sysroot` 작업은 대신 다음을 사용합니다.
      `STAGING_DIR_NATIVE`. 에 따라 다릅니다.
      레시피 유형과 빌드 대상인 `STAGING_DIR_HOST`는 다음과 같습니다.
      다음과 같은 값을 가집니다:

      - 대상 기기용으로 레시피를 만들 때 값은 다음과 같습니다.
         "${`스테이징_디렉터`}/${`머신`}".

      - 빌드 호스트용으로 빌드되는 네이티브 레시피의 경우 해당 값은 비어 있습니다.
         빌드 호스트용으로 빌드할 때 다음과 같은 가정을 전제로 합니다.
         빌드 호스트 자체의 디렉터리를 사용해야 합니다.

         .. 메모::

            ``-native`` 레시피는 다음과 같은 호스트 경로에 설치되지 않습니다.
            ``/usr``과 같이 설치되는 것이 아니라, 이러한 레시피는 다음 위치에 설치됩니다.
            `STAGING_DIR_NATIVE`. ``-native`` 레시피를 컴파일할 때,
            표준 빌드 환경 변수(예: ...)
            `CPPFLAGS` 및
            `CFLAGS`는 호스트 경로 두 개 모두에 대해 설정됩니다.
            그리고 `STAGING_DIR_NATIVE`는 라이브러리를 검색하는 데 사용됩니다.
            예를 들어 GCC의 ``-isystem`` 옵션을 사용하여 헤더를 추가합니다.

            따라서 핵심은 ``STAGING_DIR*`` 변수에 있습니다.
            다음과 같은 작업에서 입력 변수로 간주되어야 합니다.
            :ref:`ref-tasks-configure`,
            :ref:`ref-tasks-compile` 및
            :ref:`ref-tasks-install`. 실제 시스템을 갖추고 있습니다.
            루트는 `STAGING_DIR_HOST`에 대응하며 개념적으로 타당합니다.
            `-native` 레시피의 경우 호스트 헤더를 사용하기 때문에
            도서관.

      `RECIPE_SYSROOT` 및 `RECIPE_SYSROOT_NATIVE`를 확인하십시오.

### `STAGING_DIR_NATIVE`

      빌드 시 사용되는 sysroot 디렉터리의 경로를 지정합니다.
      빌드 호스트 자체에서 실행되는 구성 요소입니다.

      기본값은 ``"${RECIPE_SYSROOT_NATIVE}"``입니다.
      `RECIPE_SYSROOT_NATIVE`를 확인하세요.

### `STAGING_DIR_TARGET`

      해당 시스템에 사용되는 sysroot의 경로를 지정합니다.
      컴포넌트가 코드를 생성합니다. 코드를 생성하지 않는 컴포넌트의 경우,
      대다수인 경우, `STAGING_DIR_TARGET`이 일치하도록 설정됩니다.
      `스테이징_디렉터_호스트`.

      일부 레시피는 대상 시스템에서 실행될 수 있는 바이너리를 생성하지만,
      바이너리 파일은 차례로 다른 시스템용 코드를 생성합니다(예:
      :ref:`ref-classes-cross-canadian` 레시피). GNU 용어를 사용하면,
      기본 시스템은 "호스트"라고 하며, 보조 시스템 또는
      서로 다른 경우, 시스템을 "대상"이라고 합니다. 따라서 바이너리는
      "HOST" 시스템에서 실행하고 "TARGET"용 바이너리를 생성합니다.
      시스템. `STAGING_DIR_HOST` 변수는 사용되는 시스템 루트를 가리킵니다.
      "HOST" 시스템의 경우, `STAGING_DIR_TARGET`는 다음을 가리킵니다.
      "대상" 시스템에 사용되는 sysroot입니다.

### `STAGING_ETCDIR_NATIVE`

      sysroot의 ``/etc`` 하위 디렉터리에 대한 경로를 지정합니다.
      빌드 호스트의 디렉터리입니다.

### `STAGING_EXECPREFIXDIR`

      sysroot의 ``/usr`` 하위 디렉터리에 대한 경로를 지정합니다.
      현재 레시피가 빌드되고 있는 대상에 대한 디렉터리입니다.
      (`스테이징_디렉터_호스트`).

### `STAGING_INCDIR`

      ``/usr/include`` 하위 디렉터리의 경로를 지정합니다.
      현재 레시피가 적용되는 대상의 sysroot 디렉터리
      빌드됨(`STAGING_DIR_HOST`).

### `STAGING_INCDIR_NATIVE`

      ``/usr/include`` 하위 디렉터리의 경로를 지정합니다.
      빌드 호스트의 sysroot 디렉터리입니다.

### `STAGING_KERNEL_BUILDDIR`

      커널 빌드 아티팩트가 포함된 디렉토리를 가리킵니다.
      커널 빌드 아티팩트에 접근해야 하는 소프트웨어를 빌드하는 레시피
      (예: ``systemtap-uprobes``)는 지정된 디렉터리를 검색할 수 있습니다.
      이러한 아티팩트를 찾으려면 `STAGING_KERNEL_BUILDDIR` 변수를 사용하십시오.
      커널 빌드가 완료된 후.

### `STAGING_KERNEL_DIR`

      빌드에 필요한 커널 헤더가 있는 디렉터리
      트리 외부 모듈.

### `STAGING_LIBDIR`

      sysroot의 ``/usr/lib`` 하위 디렉터리의 경로를 지정합니다.
      현재 레시피가 빌드되고 있는 대상에 대한 디렉터리입니다.
      (`스테이징_디렉터_호스트`).

### `STAGING_LIBDIR_NATIVE`

      sysroot의 ``/usr/lib`` 하위 디렉터리의 경로를 지정합니다.
      빌드 호스트의 디렉터리입니다.

   :용어:`스탬프`
      레시피 스탬프 파일을 생성하는 데 사용되는 기본 경로를 지정합니다. 경로
      실제 우표 파일로 변환하는 과정은 이 문자열을 평가하여 수행됩니다.
      그 다음 추가 정보를 덧붙입니다. 현재 기본값은 다음과 같습니다.
      `meta/conf/bitbake.conf`에 설정된 대로 `STAMP`에 대한 할당이 이루어집니다.
      파일 내용은 다음과 같습니다::

         STAMP = "${STAMPS_DIR}/${MULTIMACH_TARGET_SYS}/${PN}/${EXTENDPE}${PV}-${PR}"

      BitBake가 스탬프 파일을 사용하여 특정 조건을 충족하는지 여부를 판단하는 방법에 대한 자세한 내용은 다음을 참조하십시오.
      작업을 다시 실행해야 합니다. 자세한 내용은 다음을 참조하십시오.
      ":ref:`개요 매뉴얼/개념: 스탬프 파일 및 작업 재실행`"
      Yocto 프로젝트 개요 및 개념 설명서의 해당 섹션을 참조하십시오.

      `STAMPS_DIR`을 참조하십시오.
      `MULTIMACH_TARGET_SYS`,
      `PN`, `EXTENDPE`,
      관련 변수에 대해서는 `PV` 및 `PR`을 사용합니다.
      정보.

### `STAMPCLEAN`

      BitBake 설명서에서 ``bitbake:STAMPCLEAN`을 참조하십시오.

### `STAMPS_DIR`

      OpenEmbedded 빌드 시스템이 실행되는 기본 디렉터리를 지정합니다.
      우표를 저장하는 곳입니다. 기본 디렉터리는 ``${TMPDIR}/stamps``입니다.

### `STRIP`

      :manpage:`strip <strip(1)>`을 실행하기 위한 최소 명령 및 인수,
      이는 기호를 제거하는 데 사용됩니다.

### `SUMMARY`

      바이너리 패키지에 대한 간략한 요약(72자 이하)입니다.
      `opkg`, `rpm`, 또는 `dpkg`와 같은 패키징 시스템. 기본적으로,
      `SUMMARY`는 다음을 정의하는 데 사용됩니다.
      `DESCRIPTION` 변수는 `DESCRIPTION`이 다음과 같을 때 사용됩니다.
      레시피에 명시되어 있지 않습니다.

### `SVNDIR`

      서브버전 시스템에서 체크아웃한 파일이 저장되는 디렉터리는 다음과 같습니다.
      저장됨.

### `SYSLINUX_DEFAULT_CONSOLE`

      커널 부팅 시 기본 콘솔을 지정합니다. 만약 특정 콘솔을 사용하고 싶다면,
      기본 콘솔 이외의 콘솔을 사용하려면 레시피에서 이 변수를 다음과 같이 설정하세요.
      다음은 사용하려는 콘솔 번호 "X"를 입력하는 부분입니다.

         SYSLINUX_DEFAULT_CONSOLE = "console=ttyX"

      :ref:`ref-classes-syslinux` 클래스는 처음에 다음과 같이 설정합니다.
      이 변수를 null로 초기화한 다음 나중에 값을 확인합니다.

### `SYSLINUX_OPTS`

      syslinux 파일에 추가할 옵션 목록을 보여줍니다. 설정해야 합니다.
      레시피에 이 변수를 넣으세요. 여러 옵션을 나열하려면,
      옵션들을 세미콜론(``;``)으로 구분하세요.

      :ref:`ref-classes-syslinux` 클래스는 이 변수를 사용합니다.
      옵션 세트를 만들기 위해.

### `SYSLINUX_SERIAL`

      대체 직렬 포트를 지정하거나 비활성화합니다. 비활성화하려면 다음 단계를 따르세요.
      serial 변수의 값을 레시피에서 빈 문자열로 설정하세요.
      변수의 기본값은 다음과 같이 설정됩니다.
      :ref:`ref-classes-syslinux` 클래스는 다음과 같습니다.:

         SYSLINUX_SERIAL ?= "0 115200"

      해당 클래스는 필요에 따라 변수를 확인하고 사용합니다.

### `SYSLINUX_SERIAL_TTY`

      대체 콘솔=tty... 커널 부팅 인수를 지정합니다.
      해당 변수의 기본값은 :ref:`ref-classes-syslinux`에 설정되어 있습니다.
      다음과 같이 분류됩니다::

         SYSLINUX_SERIAL_TTY ?= "console=ttyS0,115200"

      해당 클래스는 필요에 따라 변수를 확인하고 사용합니다.

### `SYSLINUX_SPLASH`

      VGA 부팅 메뉴의 배경으로 사용되는 ``.LSS`` 파일
      부팅 메뉴를 사용합니다. 레시피에서 이 변수를 설정해야 합니다.

      :ref:`ref-classes-syslinux` 클래스는 이를 확인합니다.
      해당 변수를 찾으면 OpenEmbedded 빌드 시스템이 설치합니다.
      시작 화면.

### `SYSROOT_DESTDIR`

      작업 디렉터리 아래의 임시 디렉터리를 가리킵니다(기본값).
      "``${``\ `WORKDIR`\ ``}/sysroot-destdir``")
      sysroot에 채워지는 파일들은 다음과 같은 과정에서 조립됩니다.
      :ref:`ref-tasks-populate_sysroot` 작업.

### `SYSROOT_DIRS`

      sysroot에 스테이징되는 디렉터리는 다음과 같습니다.
      :ref:`ref-tasks-populate_sysroot` 작업. 작성자:
      기본적으로 다음 디렉터리가 준비됩니다.

         SYSROOT_DIRS = " \
             ${includedir} \
             ${libdir} \
             ${base_libdir} \
             ${nonarch_base_libdir} \
             ${datadir} \
             /sysroot 전용 \
             "

      이 변수를 조작해야 하는 다음 예시를 생각해 보세요.
      공유 라이브러리 ``.so.*``를 제공하는 레시피 ``A``가 있다고 가정해 보겠습니다.
      "``${libdir}``" 이외의 사용자 지정 폴더에 설치됨
      또는 "``${base_libdir}``", 예를 들어 "``/opt/lib``"라고 하겠습니다.

      .. 메모::

         이는 공유 라이브러리를 다루는 데 권장되는 방법은 아니지만,
         이는 단지 `SYSROOT_DIRS` 설정을 사용하는 것이 유용함을 보여주기 위한 것입니다.

      레시피 ``B``가 ``A``에 의존한다는 것은, 레시피에 있는 것이 ``A``에 의존한다는 것을 의미합니다.
      `SYSROOT_DIRS`는 레시피 ``A``의 `D`에서 복사됩니다.
      ``B``의 `SYSROOT_DESTDIR`은 "``${WORKDIR}/sysroot-destdir``입니다.

      현재 `/opt/lib`는 `SYSROOT_DIRS`에 포함되어 있지 않으므로, 해당 디렉토리는 절대 복사되지 않습니다.
      ``A``의 `RECIPE_SYSROOT`는 "``${WORKDIR}/recipe-sysroot``"입니다. 따라서,
      연결 과정이 실패할 것입니다.

      이 문제를 해결하려면 `/opt/lib`를 ``SYSROOT_DIRS`::에 추가해야 합니다.

         SYSROOT_DIRS:append = " /opt/lib"

      .. 메모::
         `/opt/lib`를 `SYSROOT_DIRS`로 설정하더라도 링크 프로세스가 여전히 실패합니다.
         링커가 해당 위치를 알지 못하기 때문입니다. `TARGET_LDFLAGS`
         (레시피가 대상을 위한 것이라면) 해당 재료가 포함되어 있지 않습니다. 따라서 다음을 추가해야 합니다.

            TARGET_LDFLAGS:append = " -L${RECIPE_SYSROOT}/opt/lib"

### `SYSROOT_DIRS_IGNORE`

      sysroot에 스테이징되지 않는 디렉터리
      :ref:`ref-tasks-populate_sysroot` 작업입니다.
      이 변수를 사용하여 특정 하위 디렉토리를 제외할 수 있습니다.
      `SYSROOT_DIRS`에 나열된 디렉터리
      스테이징. 기본적으로 다음 디렉터리는 스테이징되지 않습니다.

         SYSROOT_DIRS_IGNORE = " \
             ${mandir} \
             ${docdir} \
             ${infodir} \
             ${datadir}/X11/locale \
             ${datadir}/applications \
             ${datadir}/bash-completion \
             ${datadir}/fonts \
             ${datadir}/gtk-doc/html \
             ${datadir}/installed-tests \
             ${datadir}/locale \
             ${datadir}/픽스맵
             ${datadir}/terminfo \
             ${libdir}/${BPN}/ptest \
             "

### `SYSROOT_DIRS_NATIVE`

      추가 디렉터리가 sysroot에 배치됩니다.
      :ref:`ref-tasks-populate_sysroot` 작업에 대한
      ``-native`` 레시피는 에 명시된 레시피 외에도 추가됩니다.
      `SYSROOT_DIRS`. 기본적으로 다음이 사용됩니다.
      추가 디렉터리가 준비되었습니다::

         SYSROOT_DIRS_NATIVE = " \
             ${bindir} \
             ${sbindir} \
             ${base_bindir} \
             ${base_sbindir} \
             ${libexecdir} \
             ${sysconfdir} \
             ${localstatedir} \
             "

      .. 메모::

         `-native` 레시피로 빌드된 프로그램은 시스템 루트에서 직접 실행됩니다.
         (`STAGING_DIR_NATIVE`) 이것이 추가 디렉터리가 필요한 이유입니다.
         프로그램 실행 파일과 지원 파일이 포함된 파일을 스테이징해야 합니다.

### `SYSROOT_PREPROCESS_FUNCS`

      파일이 스테이징된 후 실행할 함수 목록
      sysroot. 이러한 기능은 일반적으로 추가 기능을 적용하는 데 사용됩니다.
      준비된 파일을 처리하거나 추가 파일을 준비합니다.

### `SYSTEMD_AUTO_ENABLE`

      `ref-classes-systemd` 클래스를 상속할 때,
      이 변수는 지정된 서비스가 있는지 여부를 지정합니다.
      `SYSTEMD_SERVICE`가 시작되어야 합니다
      자동으로 활성화될 수도 있고 그렇지 않을 수도 있습니다. 기본적으로 서비스는 활성화되어 있습니다.
      부팅 시 자동으로 시작됩니다. 기본 설정은 다음과 같습니다.
      :ref:`ref-classes-systemd` 클래스는 다음과 같습니다::

         SYSTEMD_AUTO_ENABLE ??= "활성화"

      변수를 "disable"로 설정하면 서비스를 비활성화할 수 있습니다.

### `SYSTEMD_BOOT_CFG`

      `EFI_PROVIDER`가 설정되면
      "systemd-boot"에서 `SYSTEMD_BOOT_CFG` 변수는 다음을 지정합니다.
      사용할 설정 파일입니다. 기본적으로
      :ref:`ref-classes-systemd-boot` 클래스는 다음을 설정합니다.
      `SYSTEMD_BOOT_CFG`는 다음과 같습니다::

         SYSTEMD_BOOT_CFG ?= "${S}/loader.conf"

      Systemd-boot에 대한 자세한 내용은 `Systemd-boot`를 참조하십시오.
      문서 <https://www.freedesktop.org/wiki/Software/systemd/systemd-boot/>`__.

### `SYSTEMD_BOOT_ENTRIES`

      `EFI_PROVIDER`가 설정되면
      "systemd-boot"에서 `SYSTEMD_BOOT_ENTRIES` 변수는 다음을 지정합니다.
      부팅 파일을 하나 포함하는 설치 항목 파일(``*.conf``) 목록
      파일당 항목 수입니다. 기본적으로 :ref:`ref-classes-systemd-boot` 클래스가 사용됩니다.
      `SYSTEMD_BOOT_ENTRIES`를 다음과 같이 설정합니다.

          SYSTEMD_BOOT_ENTRIES ?= ""

      Systemd-boot에 대한 자세한 내용은 `Systemd-boot`를 참조하십시오.
      문서 <https://www.freedesktop.org/wiki/Software/systemd/systemd-boot/>`__.

### `SYSTEMD_BOOT_TIMEOUT`

      `EFI_PROVIDER`가 설정되면
      "systemd-boot"에서 `SYSTEMD_BOOT_TIMEOUT` 변수는 다음을 지정합니다.
      부팅 메뉴 시간 초과(초). 기본값은 다음과 같습니다.
      :ref:`ref-classes-systemd-boot` 클래스는 다음을 설정합니다.
      `SYSTEMD_BOOT_TIMEOUT`은 다음과 같습니다.:

         SYSTEMD_BOOT_TIMEOUT ?= "10"

      Systemd-boot에 대한 자세한 내용은 `Systemd-boot`를 참조하십시오.
      문서 <https://www.freedesktop.org/wiki/Software/systemd/systemd-boot/>`__.

### `SYSTEMD_DEFAULT_TARGET`

      이 변수를 사용하면 systemd가 부팅 시 시작하는 기본 장치를 설정할 수 있습니다.
      일반적으로 이는 `multi-user.target` 또는 `graphical.target` 중 하나입니다.
      이 기능은 선택한 systemd에 대한 `default.target` 심볼릭 링크를 생성함으로써 작동합니다.
      대상 파일.

      `systemd` 문서를 참조하세요.
      <https://www.freedesktop.org/software/systemd/man/systemd.special.html>`__
      자세한 내용은 다음을 참조하세요.

      예를 들어, 이 변수는 :oe_git:`core-image-minimal-xfce.bb`에서 사용됩니다.
      </meta-openembedded/tree/meta-xfce/recipes-core/images/core-image-minimal-xfce.bb>`
      레시피::

          SYSTEMD_DEFAULT_TARGET = "graphical.target"

### `SYSTEMD_PACKAGES`

      `ref-classes-systemd` 클래스를 상속할 때,
      이 변수는 systemd 유닛 파일을 찾을 수 없을 때 해당 파일의 위치를 ​​지정합니다.
      메인 레시피 패키지에 있습니다. 기본적으로 `SYSTEMD_PACKAGES`
      이 변수는 systemd 유닛 파일이 다음과 같이 가정되도록 설정됩니다.
      레시피 메인 패키지에 있습니다.

         SYSTEMD_PACKAGES ?= "${PN}"

      이 유닛 파일들이 이 레시피의 메인 패키지에 없다면, 다음 파일들을 추가해야 합니다.
      `SYSTEMD_PACKAGES`를 사용하여 패키지 또는 패키지 목록을 보려면 다음을 사용하십시오.
      빌드 시스템은 systemd 유닛 파일을 찾을 수 있습니다.

### `SYSTEMD_SERVICE`

      `ref-classes-systemd` 클래스를 상속할 때,
      이 변수는 패키지에 대한 systemd 서비스 이름을 지정합니다.

      여러 서비스를 지정할 수 있으며, 각 서비스는 공백으로 구분해야 합니다.

      레시피에서 이 파일을 지정할 때는 패키지 이름을 사용하세요.
      값이 적용될 패키지를 나타내기 위해 재정의합니다. 다음은 그 예입니다.
      콘맨 레시피의 예시::

         SYSTEMD_SERVICE:${PN} = "connman.service"

      지정할 수 있는 패키지 재정의는 값과 직접적인 관련이 있습니다.
      `SYSTEMD_PACKAGES`에 포함되지 않은 재정의입니다.
      조용히 무시될 것입니다.

### `SYSVINIT_ENABLED_GETTYS`

      :ref:`SysVinit <dev-manual/new-recipe:시스템 서비스 활성화>`를 사용할 때,
      공백으로 구분된 가상 터미널 목록을 지정합니다.
      로그인을 허용하는 :wikipedia:`getty <Getty_(Unix)>`를 ​​실행합니다.
      `USE_VT`가 "0"으로 설정되어 있지 않습니다.

      `SYSVINIT_ENABLED_GETTYS`의 기본값은 "1"입니다(즉, 1만 해당).
      첫 번째 가상 터미널에서 getty를 실행합니다.

### `T`

      이 변수는 BitBake가 임시 파일을 저장하는 디렉토리를 가리킵니다.
      빌드할 때 주로 작업 로그와 스크립트로 구성된 파일들이 생성됩니다.
      특정 레시피. 변수는 일반적으로 다음과 같이 설정됩니다.

         T = "${WORKDIR}/temp"

      `WORKDIR`은 작업이 수행될 디렉토리입니다.
      BitBake는 레시피를 압축 해제하고 빌드합니다. 기본 ``bitbake.conf``
      파일이 이 변수를 설정합니다.

      `T` 변수는 다음 변수와 혼동해서는 안 됩니다.
      `TMPDIR` 변수는 루트를 가리킵니다.
      BitBake가 전체 작업의 출력을 저장하는 디렉토리 트리
      짓다.

### `TARGET_ARCH`

      대상 시스템의 아키텍처. OpenEmbedded 빌드 시스템
      다양한 아키텍처를 지원합니다. 다음은 지원되는 아키텍처의 예시 목록입니다.
      지원되는 기능입니다. 이 목록은 아키텍처가 다양하기 때문에 결코 완전한 목록이 아닙니다.
      구성 가능:

      - 팔
      - i586
      - x86_64
      - 파워PC
      - 파워PC64
      - 밉스
      - 밉셀

      머신 아키텍처에 대한 자세한 내용은 다음을 참조하십시오.
      `TUNE_ARCH` 변수.

### `TARGET_AS_ARCH`

      대상에 대한 아키텍처별 어셈블러 플래그를 지정합니다.
      시스템. `TARGET_AS_ARCH`는 다음에서 초기화됩니다.
      BitBake에서 기본적으로 `TUNE_ASARGS`
      설정 파일(``meta/conf/bitbake.conf``)::

         TARGET_AS_ARCH = "${TUNE_ASARGS}"

### `TARGET_CC_ARCH`

      대상 아키텍처에 따른 C 컴파일러 플래그를 지정합니다.
      시스템. `TARGET_CC_ARCH`는 다음에서 초기화됩니다.
      `TUNE_CCARGS`가 기본값입니다.

      .. 메모::

         흔히 사용되는 해결 방법은 `LDFLAGS`를 추가하는 것입니다.
         타겟용 소프트웨어를 빌드하는 레시피에서 `TARGET_CC_ARCH`를 사용합니다.
         그렇지 않으면 내보낸 `LDFLAGS` 변수를 존중하지 않습니다.

### `TARGET_CC_KERNEL_ARCH`

      이는 특정 CPU 또는 애플리케이션에 대한 커널 컴파일러 플래그입니다.
      바이너리 인터페이스(ABI) 튜닝. 이 플래그는 드물게 사용되며 특정 경우에만 사용됩니다.
      사용자 공간 `TUNE_CCARGS`가 아닌 경우
      커널 컴파일과 호환됩니다. `TARGET_CC_KERNEL_ARCH`
      이 변수를 사용하면 커널(및 관련 모듈)이 사용할 수 있습니다.
      다른 구성입니다. 참조하세요.
      ``meta/conf/machine/include/arm/feature-arm-thumb.inc`` 파일의
      예시로 소스 디렉터리를 참조하세요.

### `TARGET_CFLAGS`

      빌드 시 C 컴파일러에 전달할 플래그를 지정합니다.
      대상. 대상 컨텍스트에서 빌드할 때,
      `CFLAGS`는 이 변수의 값으로 설정됩니다.
      기본.

      또한 SDK의 환경 설정 스크립트는 `CFLAGS`를 설정합니다.
      환경 변수가 `TARGET_CFLAGS` 값으로 변환되도록 합니다.
      SDK를 사용하여 빌드된 실행 파일에도 해당 플래그가 적용됩니다.

### `TARGET_CPPFLAGS`

      C 전처리기에 전달할 플래그를 지정합니다(즉, 둘 다에 대해).
      타겟용으로 빌드할 때 C 및 C++ 컴파일러를 사용합니다.
      대상 컨텍스트에서 `CPPFLAGS`는 다음과 같이 설정됩니다.
      이 변수의 기본값입니다.

      또한 SDK의 환경 설정 스크립트는 다음을 설정합니다.
      환경 변수 `CPPFLAGS`를 `TARGET_CPPFLAGS`로 변환합니다.
      SDK를 사용하여 빌드된 실행 파일에도 해당 플래그가 포함되도록 하는 값입니다.
      적용된.

### `TARGET_CXXFLAGS`

      빌드 시 C++ 컴파일러에 전달할 플래그를 지정합니다.
      대상. 대상 컨텍스트에서 빌드할 때,
      `CXXFLAGS`는 이 변수의 값으로 설정됩니다.
      기본적으로.

      또한 SDK의 환경 설정 스크립트는 다음을 설정합니다.
      환경 변수 `CXXFLAGS`를 `TARGET_CXXFLAGS`로 변환합니다.
      SDK를 사용하여 빌드된 실행 파일에도 해당 플래그가 포함되도록 하는 값입니다.
      적용된.

### `TARGET_DBGSRC_DIR`

      디버그 소스 파일의 대상 경로를 지정합니다. 기본값은 다음과 같습니다.
      ``/usr/src/debug/${PN}/${PV}``.

### `TARGET_FPU`

      FPU 코드 처리 방법을 지정합니다. FPU가 없는 대상의 경우,
      대부분의 ARM CPU를 포함하는 경우, 해당 변수를 "soft"로 설정해야 합니다.
      그렇지 않으면 커널 에뮬레이션이 사용되어 성능이 저하됩니다.
      패널티.

### `TARGET_LD_ARCH`

      대상 시스템에 대한 아키텍처별 링커 플래그를 지정합니다.
      `TARGET_LD_ARCH`는 다음에서 초기화됩니다.
      BitBake에서 기본적으로 `TUNE_LDARGS`
      설정 파일(``meta/conf/bitbake.conf``)::

         TARGET_LD_ARCH = "${TUNE_LDARGS}"

### `TARGET_LDFLAGS`

      빌드 시 링커에 전달할 플래그를 지정합니다.
      대상. 대상 컨텍스트에서 빌드할 때,
      `LDFLAGS`는 이 변수의 값으로 설정됩니다.
      기본적으로.

      또한 SDK의 환경 설정 스크립트는 다음을 설정합니다.
      환경 변수 `LDFLAGS`에 대한 `LDFLAGS` 변수
      SDK를 사용하여 빌드된 실행 파일에도 `TARGET_LDFLAGS` 값이 적용되도록 합니다.
      플래그가 적용되어 있습니다.

### `TARGET_OS`

      대상 시스템의 운영 체제를 지정합니다. 이 변수는 다음과 같이 설정할 수 있습니다.
      glibc 기반 시스템(GNU C 라이브러리)의 경우 "linux", "linux-musl"의 경우
      musl libc의 경우입니다. ARM/EABI 타겟의 경우 가능한 값은 다음과 같습니다.
      "linux-gnueabi"와 "linux-musleabi".

### `TARGET_PREFIX`

      툴체인 바이너리 대상 도구에 사용되는 접두사를 지정합니다.

      레시피 유형과 빌드 대상에 따라,
      `TARGET_PREFIX`는 다음과 같이 설정됩니다.

      - 대상 기기용으로 레시피를 만들 때 값은 다음과 같습니다.
         "${`TARGET_SYS`}-".

      - 네이티브 레시피의 경우 빌드 시스템은 변수를 다음과 같이 설정합니다.
         `BUILD_PREFIX`의 값입니다.

      - 네이티브 SDK 레시피의 경우(:ref:`ref-classes-nativesdk`),
         빌드 시스템은 해당 변수를 `SDK_PREFIX` 값으로 설정합니다.

### `TARGET_SYS`

      시스템 아키텍처 및 운영 체제를 포함한 시스템 사양을 명시합니다.
      빌드가 진행되는 시스템의 컨텍스트는 다음과 같습니다.
      현재 레시피.

      OpenEmbedded 빌드 시스템은 이 변수를 자동으로 설정합니다.
      `TARGET_ARCH`에서,
      `TARGET_VENDOR`, 그리고
      `TARGET_OS` 변수.

      .. 메모::

         `TARGET_SYS` 변수를 직접 설정할 필요가 없습니다.

      다음 두 가지 예를 살펴보세요.

      - 32비트 x86 Linux 운영 체제에서 실행되는 네이티브 레시피가 주어졌을 때,
         값은 "i686-linux"입니다.

      - 리틀 엔디안, MIPS 타겟용으로 빌드되는 레시피를 가정해 보겠습니다.
         Linux를 실행하는 경우 값은 "mipsel-linux"일 수 있습니다.

### `TARGET_VENDOR`

      대상 공급업체의 이름을 지정합니다.

### `TC_CXX_RUNTIME`

      사용할 C/C++ STL 및 런타임 버전을 지정합니다.
      빌드 프로세스. 기본값은 'gnu'입니다.

      "gnu", "llvm" 또는 "android" 중에서 선택할 수 있습니다.

### `TCLIBC`

      사용할 GNU 표준 C 라이브러리(``libc``) 변형을 지정합니다.
      빌드 프로세스.

      "glibc", "musl", "newlib" 또는 "baremetal" 중에서 선택할 수 있습니다.

### `TCMODE`

      툴체인 선택기를 지정합니다. `TCMODE`는 다음을 제어합니다.
      생성된 패키지와 이미지의 특징을 다음과 같이 설명합니다.
      OpenEmbedded 빌드 시스템에서 사용할 툴체인 프로파일입니다. 기본값은 다음과 같습니다.
      OpenEmbedded 빌드 시스템은 자체적인 내부 툴체인을 구축합니다.
      해당 변수의 기본값은 "default"이며, 이는 내부적으로 사용됩니다.
      툴체인.

      .. 메모::

         `TCMODE`가 "default" 이외의 값으로 설정되어 있으면, 그것은 당신의 문제입니다.
         툴체인이 호환되는지 확인하는 책임
         기본 툴체인. 이전 버전 또는 이후 버전을 사용하는 경우
         구성 요소로 인해 빌드 문제가 발생할 수 있습니다. 자세한 내용은 다음을 참조하세요.
         :doc:`릴리스 정보 </migration-guides/index>`
         Yocto Project의 버전을 사용하여 특정 구성 요소를 찾으려면
         툴체인이 호환되어야 합니다.

      `TCMODE` 변수는 `TCLIBC` 변수와 유사합니다.
      이는 GNU 표준 C 라이브러리(``libc``)의 변형을 제어합니다.
      빌드 과정에서 사용되는 명령어: ``glibc`` 또는 ``musl``.

      추가 레이어를 사용하면 미리 컴파일된 외부 라이브러리를 사용할 수 있습니다.
      툴체인. 한 예로 Sourcery G++ 툴체인이 있습니다. 지원 기능은 다음과 같습니다.
      이 툴체인은 Mentor Graphics라는 별도의 저장소에 있습니다.
      ``meta-sourcery`` 레이어에서
      https://github.com/MentorEmbedded/meta-sourcery/.

      해당 레이어의 ``README`` 파일에는 사용 방법에 대한 정보가 포함되어 있습니다.
      Sourcery G++ 툴체인을 외부 툴체인으로 사용하려면 다음 단계를 따라야 합니다.
      `bblayers.conf` 파일에 레이어를 추가한 다음 설정하세요.
      `local.conf` 파일의 `EXTERNAL_TOOLCHAIN` 변수를 다음과 같이 설정하세요.
      툴체인의 위치.

      이 예시에 사용된 기본 원칙은 모든 외부 상황에 적용됩니다.
      툴체인. `meta-sourcery`를 템플릿으로 사용하여 추가할 수 있습니다.
      다른 외부 툴체인에 대한 지원.

      툴체인 구성 외에도 다음 사항이 필요합니다.
      해당 툴체인 레시피 파일입니다. 이 레시피 파일은 패키징되어야 합니다.
      툴체인에 있는 ``libgcc``와 같은 사전 빌드된 객체를 모두 활성화합니다.
      ``libstdcc++``, 모든 로케일 및 ``libc``.

### `TEMPLATECONF`

      빌드 시스템이 템플릿을 찾는 데 사용하는 디렉터리를 지정합니다.
      이를 기반으로 ``bblayers.conf`` 및 ``local.conf`` 파일을 생성합니다.
      이러한 파일을 사용자 지정하려면 이 변수를 사용하십시오. 기본값은 다음과 같습니다.
      `oe-init-build-env` 스크립트를 실행할 때 표시되는 BitBake 대상입니다.

      자세한 내용은 다음을 참조하십시오.
      :ref:`dev-manual/custom-template-configuration-directory:사용자 지정 템플릿 구성 디렉터리 생성`
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션입니다.

      .. 메모::

         이 변수를 외부 환경에 설정해야 합니다.
         제대로 작동하려면.

### `TEST_EXPORT_DIR`

      OpenEmbedded 빌드 시스템이 테스트를 내보낼 때 사용하는 위치
      `TEST_EXPORT_ONLY` 변수가 설정되었습니다.
      "1"까지.

      `TEST_EXPORT_DIR` 변수의 기본값은 다음과 같습니다.
      ``"${TMPDIR}/testimage/${PN}"``.

### `TEST_EXPORT_ONLY`

      테스트 결과만 내보내도록 지정합니다. 이 변수를 "1"로 설정하면 테스트 결과만 내보낼 수 있습니다.
      테스트를 실행하고 싶지는 않지만, 테스트 결과를 특정 형식으로 내보내고 싶습니다.
      빌드 시스템 외부에서 실행할 수 있는 방법입니다.

### `TEST_LOG_DIR`

      QEMU 시스템의 SSH 로그와 부팅 로그를 저장합니다.
      `TEST_LOG_DIR` 변수의 기본값은 ``"${WORKDIR}/testimage"``입니다.

      .. 메모::

         실제 테스트 결과는 작업 로그(``log.do_testimage``)에 저장됩니다.
         해당 파일은 ``${WORKDIR}/temp/`` 디렉토리에 있습니다.

### `TEST_POWERCONTROL_CMD`

      자동화된 하드웨어 테스트를 위해 사용할 명령어를 지정합니다.
      테스트 대상 기기의 전력을 제어합니다. 일반적으로 이는
      명령어는 적절한 작업을 수행하는 스크립트를 가리킬 것입니다.
      (예: 웹 지원 멀티탭과의 상호 작용). 지정된
      명령어는 마지막 인수로 "off", "on" 또는 ""을 받을 것으로 예상해야 합니다.
      "cycle"은 전원을 끄거나, 켜거나, 또는 주기적으로 (전원을 끈 다음 다시 켜기) 켜기를 지정합니다.
      (장치의 전원을 켜십시오.)

### `TEST_POWERCONTROL_EXTRA_ARGS`

      자동화된 하드웨어 테스트를 위해 추가 인수를 지정합니다.
      지정된 명령으로 전달합니다.
      `TEST_POWERCONTROL_CMD`. 설정 중
      `TEST_POWERCONTROL_EXTRA_ARGS`는 선택 사항입니다. 필요에 따라 사용할 수 있습니다.
      예를 들어, 기계별 및
      인수의 기계 특이적이지 않은 부분.

### `TEST_QEMUBOOT_TIMEOUT`

      자동화되기 전에 이미지가 부팅되는 데 허용되는 시간(초)
      런타임 테스트가 이미지에 대해 실행되기 시작합니다. 기본 타임아웃
      부팅 프로세스가 로그인 프롬프트에 도달하는 데 걸리는 시간은 500초입니다.
      초 단위입니다. `local.conf` 파일에서 다른 값을 지정할 수 있습니다.
      파일.

      이미지 테스트에 대한 자세한 내용은 다음을 참조하세요.
      ":ref:`test-manual/runtime-testing:자동화된 런타임 테스트 수행`"
      Yocto Project 테스트 환경 매뉴얼의 해당 섹션입니다.

### `TEST_SERIALCONTROL_CMD`

      자동화된 하드웨어 테스트를 위해 사용할 명령어를 지정합니다.
      테스트 대상 시스템의 시리얼 콘솔에 연결합니다.
      명령어는 단순히 시리얼 콘솔에 연결하고 메시지를 전달하기만 하면 됩니다.
      해당 연결은 일반 터미널과 마찬가지로 표준 입력 및 출력에 연결됩니다.
      프로그램이 그렇습니다.

      예를 들어, 시리얼 장치에서 Picocom 터미널 프로그램을 사용하려면
      ``/dev/ttyUSB0``을 115200bps로 설정하려면 변수를 다음과 같이 설정해야 합니다.

         TEST_SERIALCONTROL_CMD = "picocom /dev/ttyUSB0 -b 115200"

### `TEST_SERIALCONTROL_EXTRA_ARGS`

      자동화된 하드웨어 테스트를 위해 추가 인수를 지정합니다.
      지정된 명령으로 전달합니다.
      `TEST_SERIALCONTROL_CMD`. 설정 중
      `TEST_SERIALCONTROL_EXTRA_ARGS`는 선택 사항입니다. 필요에 따라 사용할 수 있습니다.
      예를 들어, 기계별 및
      명령어의 기계 특정적이지 않은 부분.

### `TEST_SERVER_IP`

      빌드 머신(호스트 머신)의 IP 주소입니다. 이 IP 주소는 빌드 머신의 IP 주소입니다.
      일반적으로 자동으로 감지됩니다. 하지만 감지에 실패할 경우, 이
      해당 변수는 빌드 머신의 IP 주소로 설정되어야 합니다(예:
      (건축이 진행되는 장소).

      .. 메모::

         `TEST_SERVER_IP` 변수는 소수의 경우에만 사용됩니다.
         "dnf" 테스트 스위트와 같은 테스트는 패키지를 다운로드해야 합니다.
         ``WORKDIR/oe-rootfs-repo``에서 가져왔습니다.

### `TEST_SUITES`

      이미지에 대해 실행할 테스트(모듈)의 정렬된 목록
      자동화된 런타임 테스트를 수행합니다.

      OpenEmbedded 빌드 시스템은 다음과 같은 핵심 테스트 세트를 제공합니다.
      이미지에 대해 사용될 수 있습니다.

      .. 메모::

         현재로서는 이러한 테스트를 실행하는 데 지원되는 조건은 다음과 같습니다.
         QEMU.

      테스트에는 `ping`, `ssh`, `df` 등이 포함됩니다. 추가할 수 있습니다.
      테스트 목록에 ``TEST_SUITES`를 추가하여 사용자 지정 테스트를 추가하세요.
      다음이 따릅니다::

         TEST_SUITES:append = " mytest"

      또는 다음과 같이 하실 수도 있습니다.
      모든 관련 테스트를 실행하도록 "자동" 옵션을 제공합니다.
      이미지::

         TEST_SUITES:append = " auto"

      이 옵션을 사용하면 다음과 같은 현상이 발생합니다.
      적용 가능한 테스트를 자동으로 실행하는 빌드 시스템
      이미지. 적용되지 않는 테스트는 건너뜁니다.

      테스트 실행 순서는 중요합니다. 특정 조건에 의존하는 테스트는 나중에 실행될 수 있습니다.
      다른 시험은 해당 시험보다 목록에서 나중에 나타나야 합니다.
      상황에 따라 다릅니다. 예를 들어 테스트 목록에 두 개를 추가하면 다음과 같습니다.
      `test_A`와 `test_B` 테스트에서 `test_B`는 다음 테스트에 의존합니다.
      ``test_A``를 선택했다면, 테스트 순서는 다음과 같아야 합니다.

         테스트 스위트 = "test_A test_B"

      이미지 테스트에 대한 자세한 내용은 다음을 참조하세요.
      ":ref:`test-manual/runtime-testing:자동화된 런타임 테스트 수행`"
      Yocto Project 테스트 환경 매뉴얼의 해당 섹션입니다.

### `TEST_TARGET`

      테스트를 실행할 때 사용할 대상 컨트롤러를 지정합니다.
      테스트 이미지입니다. 기본적으로 사용할 컨트롤러는 "qemu"입니다.

         TEST_TARGET = "qemu"

      타겟 컨트롤러는 이미지가 어떻게 표시되는지를 정의하는 클래스입니다.
      대상에 배포되는 방식과 대상이 시작되는 방식. 레이어는 확장될 수 있습니다.
      컨트롤러는 레이어에 모듈을 추가하여 제어합니다.
      ``/lib/oeqa/controllers`` 디렉토리와 상속을 통해
      `BaseTarget` 클래스는 추상 클래스이므로 사용할 수 없습니다.
      `TEST_TARGET`의 값으로.

      ``TEST_TARGET`에 다음 인수를 제공할 수 있습니다.

      - *"qemu":* QEMU 이미지를 부팅하고 테스트를 실행합니다. 자세한 내용은 다음을 참조하십시오.
         ":ref:`test-manual/runtime-testing:qemu에서 런타임 테스트 활성화`" 섹션
         자세한 내용은 Yocto Project 테스트 환경 설명서를 참조하십시오.
         정보.

      - *"simpleremote":* 대상 하드웨어에서 테스트를 실행합니다.
         이미 가동 중입니다. 하드웨어는 네트워크에 연결되어 있거나 그렇지 않을 수 있습니다.
         QEMU에서 이미지를 실행하는 장치일 수 있습니다. 또한 설정해야 합니다.
         `TEST_TARGET_IP`를 사용할 때
         "심플리리모트".

         .. 메모::

            이 인수는 다음과 같이 정의됩니다.
            ``meta/lib/oeqa/controllers/simpleremote.py``.

      하드웨어 테스트 실행에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`test-manual/runtime-testing:하드웨어에서 런타임 테스트 활성화`"
      Yocto Project 테스트 환경 매뉴얼의 해당 섹션입니다.

### `TEST_TARGET_IP`

      테스트 대상 하드웨어의 IP 주소입니다. `TEST_TARGET_IP`
      `TEST_TARGET`이 설정된 경우 변수는 아무런 효과가 없습니다.
      "qemu"로 설정하세요.

      IP 주소를 지정할 때 포트 번호도 함께 포함할 수 있습니다. 다음은 그 예입니다.
      예시:

         TEST_TARGET_IP = "192.168.1.4:2201"

      포트를 지정하는 것은
      SSH가 표준 포트가 아닌 곳에서 시작되거나 다음과 같은 경우에 유용합니다.
      테스트 대상 하드웨어가 방화벽이나 네트워크 뒤에 있습니다.
      호스트에서 직접 접근 가능하며 포트 주소를 설정해야 합니다.
      번역.

### `TESTIMAGE_AUTO`

      이미지에 대한 일련의 자동화된 테스트를 자동으로 실행합니다.
      이미지 빌드가 성공적으로 완료되었습니다. `TESTIMAGE_AUTO`를 "1"로 설정하면 다음과 같은 문제가 발생합니다.
      QEMU에서 자동으로 부팅되도록 성공적으로 빌드된 모든 이미지.
      해당 변수를 사용하면 종속성도 추가되므로 모든 SDK에서 사용할 수 있습니다.
      어떤 테스트가 요청되었는지에 따라 자동으로 테스트 빌드가 먼저 수행됩니다.

      이 테스트들은 `unittest`를 사용하여 Python으로 작성되었습니다.
      모듈이며, 그중 대다수는 대상 시스템에서 명령을 실행합니다.
      `ssh`를 통해 접속할 수 있습니다. `local.conf` 파일에서 이 변수를 "1"로 설정하면 됩니다.
      빌드 디렉터리에 있는 파일을 사용하려면
      OpenEmbedded 빌드 시스템은 빌드 후 이러한 테스트를 자동으로 실행합니다.
      이미지 빌드가 성공적으로 완료되었습니다:

         TESTIMAGE_AUTO = "1"

      더 자세한 정보를 원하시면
      이러한 테스트를 활성화, 실행 및 작성하는 방법에 대해서는 다음을 참조하십시오.
      ":ref:`test-manual/runtime-testing:자동화된 런타임 테스트 수행`"
      Yocto Project 테스트 환경 매뉴얼의 해당 섹션 및
      ":ref:`ref-classes-testimage`" 섹션.

### `TESTIMAGE_FAILED_QA_ARTIFACTS`

      `:ref:`ref-classes-testimage` 클래스를 사용할 때 변수는 다음과 같습니다.
      `TESTIMAGE_FAILED_QA_ARTIFACTS`는 공백으로 구분된 경로 목록을 표시합니다.
      호스트에서 가져올 대상입니다.

### `TESTSDK_SUITES`

      `ref-classes-testsdk` 클래스를 사용할 때,
      `TESTSDK_SUITES` 변수를 사용하여 테스트 목록을 제어할 수 있습니다.
      실행할 모듈입니다. 이 변수의 기본값은 빈 문자열입니다.
      그리고 찾을 수 있는 모든 테스트 모듈이 실행됩니다.

### `THISDIR`

      BitBake가 현재 파일을 파싱하고 있는 디렉터리는 다음과 같습니다.
      위치가 지정되어 있습니다. 이 변수를 수동으로 설정하지 마십시오.

### `TIME`

      빌드가 시작된 시간입니다. 시간은 시, 분 순으로 표시됩니다.
      그리고 두 번째 (HMS) 형식 (예: 1분 59초의 경우 "140159")
      오후 2시 20분).

### `TMPDIR`

      이 변수는 OpenEmbedded 빌드 시스템의 기본 디렉터리입니다.
      모든 빌드 출력 및 중간 파일(다음 제외)에 사용됩니다.
      공유 상태 캐시). 기본적으로 `TMPDIR` 변수는 다음을 가리킵니다.
      빌드 디렉터리 내의 ``tmp``입니다.

      이 디렉토리를 지정된 위치가 아닌 다른 위치에 설정하려면
      기본적으로 다음 문장의 주석을 해제하고 편집할 수 있습니다.
      소스 디렉터리에 있는 `conf/local.conf` 파일::

         #TMPDIR = "${TOPDIR}/tmp"

      이 시나리오의 예시 사용 예는 ``TMPDIR`을 로컬 디스크로 설정하는 것입니다.
      NFS를 사용하지 않지만 빌드 디렉터리는 NFS를 사용하도록 설정되어 있습니다.

      `TMPDIR`에서 사용하는 파일 시스템은 표준 파일 시스템이어야 합니다.
      의미론(예: 대소문자가 혼합된 파일은 고유하며, POSIX 파일 잠금 등)
      (영구 inode). NFS 관련 여러 문제와 일부 버그로 인해
      구현 측면에서 NFS는 이러한 최소 요구 사항을 충족하지 못합니다.
      따라서 `TMPDIR`은 NFS에 있을 수 없습니다.

### `TOOLCHAIN`

      ``TOOLCHAIN` 변수를 사용하면 사용되는 툴체인을 재정의할 수 있습니다.
      레시피에 따라.

      이 변수의 기본값은 해당 값입니다.
      `PREFERRED_TOOLCHAIN`. 설명을 참조하세요.
      `PREFERRED_TOOLCHAIN`에 대한 가능한 값 목록을 보려면
      :용어:`툴체인`.

      레시피에서 이 변수의 값을 재정의할 수 있습니다.
      이 레시피는 특정 툴체인만 지원하는 것으로 알려져 있습니다. 예를 들어,
      :oe_git:`가상 </openembedded-core/tree/meta/recipes-devtools/pseudo/pseudo_git.bb>`
      레시피는 Pseudo가 GCC 컴파일러를 사용하기 때문에 이 변수를 "gcc"로 재정의합니다.
      Clang/LLVM 컴파일러가 제공하지 않는 내장 옵션입니다.

### `TOOLCHAIN_HOST_TASK`

      이 변수는 OpenEmbedded 빌드 시스템이 사용하는 패키지 목록을 보여줍니다.
      크로스 개발 환경을 포함하는 SDK를 구축합니다.
      이 변수로 지정된 패키지는 툴체인 세트의 일부입니다.
      `SDKMACHINE`에서 실행되는 것과 각각
      패키지에는 일반적으로 ``nativesdk-`` 접두사가 붙어야 합니다. 예를 들어,
      SDK를 빌드할 때 다음 명령어를 고려하십시오.

         $ bitbake -c populate_sdk imagename

      이 경우 기본 패키지 목록은 다음과 같습니다.
      이 변수에 설정되어 있지만, 추가 패키지를 추가할 수도 있습니다.
      목록을 참조하세요.
      ":ref:`sdk-manual/appendix-customizing-standard:표준 SDK에 개별 패키지 추가`" 섹션
      Yocto 프로젝트 애플리케이션 개발 및 확장성
      자세한 내용은 소프트웨어 개발 키트(eSDK) 설명서를 참조하십시오.

      크로스 개발 툴체인에 대한 배경 정보는 다음을 참조하십시오.
      Yocto Project 개발 환경에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`sdk-manual/intro:크로스 개발 툴체인`"
      Yocto 프로젝트 개요 및 개념 설명서의 해당 섹션을 참조하십시오.
      크로스 개발 환경 설정에 대한 정보는 다음을 참조하세요.
      :doc:`/sdk-manual/index` 매뉴얼.

      참고로 이 변수는 eSDK가 아닌 SDK 빌드에 적용됩니다.
      이 경우 `TOOLCHAIN_HOST_TASK_ESDK` 설정은 다음과 같아야 합니다.
      대신 사용되었습니다.

### `TOOLCHAIN_HOST_TASK_ESDK`

      이 변수를 사용하면 호스트에 설치된 항목을 확장할 수 있습니다.
      eSDK의 일부입니다. 이는 `TOOLCHAIN_HOST_TASK`와 유사합니다.
      SDK에 적용합니다.

### `TOOLCHAIN_NATIVE`

      ``TOOLCHAIN_NATIVE` 변수를 사용하여 재정의할 수 있습니다.
      :ref:`ref-classes-native` 레시피에서 사용되는 툴체인입니다.

      이 변수의 기본값은 해당 값입니다.
      `선호하는_툴체인`(:ref:`ref-classes-native` 컨텍스트에서). 참조
      `PREFERRED_TOOLCHAIN`에 대한 설명을 통해 목록을 확인할 수 있습니다.
      `TOOLCHAIN_NATIVE`에 대한 가능한 값입니다.

      레시피에서 이 변수의 값을 재정의할 수 있습니다.
      이 레시피는 특정 툴체인만 지원하는 것으로 알려져 있습니다.

### `TOOLCHAIN_OPTIONS`

      이 변수는 컴파일러와 링커에 전달되는 추가 옵션을 저장합니다.
      네이티브 레시피가 아닌 경우에는 사용자 정의 경로를 지정해야 합니다.
      `RECIPE_SYSROOT`::가 가리키는 ``sysroot`` 폴더

         TOOLCHAIN_OPTIONS = " --sysroot=${RECIPE_SYSROOT}"

      기본 레시피는 이 변수를 설정할 필요가 없습니다.
      네이티브 컴파일러를 사용하여 호스트 시스템용으로 빌드되었습니다.

### `TOOLCHAIN_OUTPUTNAME`

      이 변수는 툴체인 출력에 사용되는 이름을 정의합니다.
      :ref:`populate_sdk_base <ref-classes-populate-sdk-*>` 클래스 세트
      `TOOLCHAIN_OUTPUTNAME` 변수는 다음과 같습니다.

         TOOLCHAIN_OUTPUTNAME ?= "${SDK_NAME}-toolchain-${SDK_VERSION}"

      보다
      `SDK_NAME` 및
      `SDK_VERSION` 변수는 추가적인 용도로 사용됩니다.
      정보.

### `TOOLCHAIN_TARGET_TASK`

      이 변수는 OpenEmbedded 빌드 시스템이 사용하는 패키지 목록을 보여줍니다.
      SDK의 대상 부분(즉, 빌드 대상 부분)을 생성합니다.
      대상 하드웨어)에는 라이브러리와 헤더가 포함되어 있습니다. 이것을 사용하십시오.
      SDK 실행 부분에 개별 패키지를 추가하는 변수입니다.
      목표물을 조준하세요. 보세요.
      ":ref:`sdk-manual/appendix-customizing-standard:표준 SDK에 개별 패키지 추가`" 섹션
      Yocto 프로젝트 애플리케이션 개발 및 확장성
      자세한 내용은 소프트웨어 개발 키트(eSDK) 설명서를 참조하십시오.

      크로스 개발 툴체인에 대한 배경 정보는 다음을 참조하십시오.
      Yocto Project 개발 환경에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`sdk-manual/intro:크로스 개발 툴체인`"
      Yocto 프로젝트 개요 및 개념 설명서의 해당 섹션을 참조하십시오.
      크로스 개발 환경 설정에 대한 정보는 다음을 참조하세요.
      :doc:`/sdk-manual/index` 매뉴얼.

### `TOPDIR`

      BitBake 설명서에서 ``bitbake:TOPDIR`을 참조하십시오.

### `TRANSLATED_TARGET_ARCH`

      `TARGET_ARCH`의 정제된 버전입니다.
      변수는 아키텍처가 값에 필요한 경우에 사용됩니다.
      예를 들어 패키지 파일 이름 내에서는 밑줄(_)을 사용할 수 없습니다.
      이 경우, 밑줄 문자 대신 대시 문자가 사용됩니다.
      `TARGET_ARCH`.

      이 변수를 수정하지 마십시오.

### `TUNE_ARCH`

      특정 아키텍처(예: )에 대한 GNU 표준 아키텍처
      ``arm``, ``armeb``, ``mips``, ``mips64`` 등). BitBake는 다음을 사용합니다.
      이 값을 설정 구성에 사용합니다.

      `TUNE_ARCH` 정의는 특정 아키텍처에 따라 다릅니다.
      정의는 단일 정적 정의일 수도 있고, 동적으로 정의될 수도 있습니다.
      조정되었습니다. 특정 CPU 제품군에 대한 자세한 내용은 다음을 참조하십시오.
      아키텍처의 ``README`` 파일. 예를 들어,
      ``meta/conf/machine/include/mips/README`` 파일의
      `소스 디렉터리`는 다음 정보를 제공합니다.
      `TUNE_ARCH`는 ``mips`` 아키텍처에 특화된 기능입니다.

      `TUNE_ARCH`는 다음과 밀접하게 관련되어 있습니다.
      `TARGET_ARCH`는 대상을 정의합니다.
      머신의 아키텍처. BitBake 설정 파일
      (``meta/conf/bitbake.conf``)는 `TARGET_ARCH`를 다음과 같이 설정합니다.

         TARGET_ARCH = "${TUNE_ARCH}"

      다음 목록은 아키텍처가 다양하기 때문에 결코 완전한 목록이 아닙니다.
      구성 가능하며 지원되는 머신 아키텍처를 보여줍니다.

      - 팔
      - i586
      - x86_64
      - 파워PC
      - 파워PC64
      - 밉스
      - 밉셀

### `TUNE_ASARGS`

      대상에 대한 아키텍처별 어셈블러 플래그를 지정합니다.
      시스템. 플래그 세트는 선택된 튜닝 기능을 기반으로 합니다.
      `TUNE_ASARGS`는 튜닝 포함 파일을 사용하여 설정됩니다.
      일반적으로 ``meta/conf/machine/include/`` 아래에 있으며 영향을 받습니다.
      `TUNE_FEATURES`를 통해. 예를 들어,
      ``meta/conf/machine/include/x86/arch-x86.inc`` 파일은 플래그를 정의합니다.
      x86 아키텍처의 경우 다음과 같습니다.

         TUNE_ASARGS += "${@bb.utils.contains("TUNE_FEATURES", "mx32", "-x32", "", d)}"

      .. 메모::

         보드 지원 패키지(BSP)에서 튜닝을 선택합니다. 선택된 튜닝은 다음과 같습니다.
         결과적으로 이는 튜닝 변수 자체에 영향을 미칩니다(즉, 튜닝은
         (자체적으로 플래그 세트를 제공합니다.)

### `TUNE_CCARGS`

      대상 아키텍처에 따른 C 컴파일러 플래그를 지정합니다.
      시스템. 플래그 세트는 선택된 튜닝 기능을 기반으로 합니다.
      `TUNE_CCARGS`는 튜닝 포함 파일을 사용하여 설정됩니다.
      일반적으로 ``meta/conf/machine/include/`` 아래에 있으며 영향을 받습니다.
      `TUNE_FEATURES`를 통해.

      .. 메모::

         보드 지원 패키지(BSP)에서 튜닝을 선택합니다. 선택된 튜닝은 다음과 같습니다.
         결과적으로 이는 튜닝 변수 자체에 영향을 미칩니다(즉, 튜닝은
         (자체적으로 플래그 세트를 제공합니다.)

### `TUNE_FEATURES`

      특정 조건에 맞춰 컴파일러를 최적으로 사용하기 위해 "조정"하는 데 사용되는 기능입니다.
      프로세서. 기능은 튜닝 파일 내에 정의되어 있으며 다음을 허용합니다.
      인수(예: ``TUNE_*ARGS``)는 다음을 기반으로 동적으로 생성됩니다.
      특징들.

      OpenEmbedded 빌드 시스템은 기능이 제대로 작동하는지 확인하기 위해 검증을 수행합니다.
      서로 상충하지 않고 지지받는다는 것입니다.

      BitBake 설정 파일(``meta/conf/bitbake.conf``)은 다음을 정의합니다.
      `TUNE_FEATURES`는 다음과 같습니다::

         TUNE_FEATURES ??= "${TUNE_FEATURES:tune-${DEFAULTTUNE}}"

      자세한 내용은 `DEFAULTTUNE` 변수를 참조하십시오.

### `TUNE_LDARGS`

      대상 시스템에 대한 아키텍처별 링커 플래그를 지정합니다.
      플래그 세트는 선택된 튜닝 기능을 기반으로 합니다.
      `TUNE_LDARGS`는 튜닝 포함 파일을 사용하여 설정됩니다.
      일반적으로 ``meta/conf/machine/include/`` 아래에 있으며 영향을 받습니다.
      `TUNE_FEATURES`를 통해. 예를 들어,
      ``meta/conf/machine/include/x86/arch-x86.inc`` 파일은 플래그를 정의합니다.
      x86 아키텍처의 경우 다음과 같습니다.

         TUNE_LDARGS += "${@bb.utils.contains("TUNE_FEATURES", "mx32", "-m elf32_x86_64", "", d)}"

      .. 메모::

         보드 지원 패키지(BSP)에서 튜닝을 선택합니다. 선택된 튜닝은 다음과 같습니다.
         결과적으로 이는 튜닝 변수 자체에 영향을 미칩니다(즉, 튜닝은
         (자체적으로 플래그 세트를 제공합니다.)

### `TUNE_PKGARCH`

      패키징 시스템이 이해하는 패키지 아키텍처는 다음과 같이 정의됩니다.
      출력 패키지의 아키텍처, ABI 및 튜닝. 구체적인 내용은 다음과 같습니다.
      튜닝은 다음과 같이 "_tune" 오버라이드를 사용하여 정의됩니다.

         TUNE_PKGARCH:tune-tune = "tune"

      이러한 튜닝별 패키지 아키텍처는 머신에 정의되어 있습니다.
      포함 파일. 다음은 "core2-32" 튜닝의 예시입니다.
      ``meta/conf/machine/include/x86/tune-core2.inc`` 파일::

         TUNE_PKGARCH:tune-core2-32 = "core2-32"

### `TUNECONFLICTS[feature]`

      CPU 또는 애플리케이션 바이너리 인터페이스(ABI) 튜닝 기능을 지정합니다.
      기능과 충돌하는 것.

      알려진 튜닝 충돌은 머신 포함 파일에 명시되어 있습니다.
      `소스 디렉터리`. 다음은 그 예입니다.
      ``meta/conf/machine/include/mips/arch-mips.inc`` 포함 파일
      "o32" 및 "n64" 기능이 "n32" 기능과 충돌한다고 나열되어 있습니다.
      특징::

         TUNECONFLICTS[n32] = "o32 n64"

### `TUNEVALID[feature]`

      유효한 CPU 또는 애플리케이션 바이너리 인터페이스(ABI) 튜닝을 지정합니다.
      기능. 지정된 기능은 플래그로 저장됩니다. 유효한 기능
      머신 포함 파일(예: )에 지정되어 있습니다.
      ``meta/conf/machine/include/arm/arch-arm.inc``). 다음은 예시입니다.
      해당 파일에서::

         TUNEVALID[bigendian] = "빅 엔디안 모드를 활성화합니다."

      소스 디렉터리에서 머신 포함 파일을 확인하세요.
      이러한 기능들을 위해서입니다.

### `UBOOT_BINARY`

      U-Boot에서 빌드한 바이너리의 이름을 지정합니다.

### `UBOOT_CONFIG`

      빌드할 하나 이상의 U-Boot 구성을 설정합니다. 각 구성은
      설정에서 `UBOOT_MACHINE`을 정의할 수 있으며 선택적으로 다음을 정의할 수 있습니다.
      `IMAGE_FSTYPES`와 `UBOOT_BINARY`.

      다음은 ``meta-freescale`` 레이어의 예시입니다. ::

         UBOOT_CONFIG ??= "sdcard-ifc-secure-boot sdcard-ifc sdcard-qspi lpuart qspi secure-boot nor"
         UBOOT_CONFIG[nor] = "ls1021atwr_nor_defconfig"
         UBOOT_CONFIG[sdcard-ifc] = "ls1021atwr_sdcard_ifc_defconfig,,u-boot-with-spl-pbl.bin"
         UBOOT_CONFIG[sdcard-qspi] = "ls1021atwr_sdcard_qspi_defconfig,,u-boot-with-spl-pbl.bin"
         UBOOT_CONFIG[lpuart] = "ls1021atwr_nor_lpuart_defconfig"
         UBOOT_CONFIG[qspi] = "ls1021atwr_qspi_defconfig"
         UBOOT_CONFIG[secure-boot] = "ls1021atwr_nor_SECURE_BOOT_defconfig"
         UBOOT_CONFIG[sdcard-ifc-secure-boot] = "ls1021atwr_sdcard_ifc_SECURE_BOOT_defconfig,,u-boot-with-spl-pbl.bin"

      이 예시에서는 가능한 7가지 구성이 모두 선택되었습니다. 각 구성은 다음과 같습니다.
      구성에서 "..._defconfig"를 `UBOOT_MACHINE`으로 지정합니다.
      "sd..." 구성은 개별 이름을 정의합니다.
      `UBOOT_BINARY`. 어떤 구성도 두 번째 매개변수를 정의하지 않습니다.
      U-Boot 이미지에 사용할 `IMAGE_FSTYPES`를 지정합니다.

      `UBOOT_CONFIG`가 처리되는 방식에 대한 자세한 내용은 다음을 참조하십시오.
      :ref:`ref-classes-uboot-config` 클래스.

### `UBOOT_DTB_LOADADDRESS`

      U-Boot에서 사용하는 dtb 이미지의 로드 주소를 지정합니다. FIT 실행 중에 사용됩니다.
      이미지 생성 시, `UBOOT_DTB_LOADADDRESS` 변수가 사용됩니다.
      로드 주소를 지정하려면 :ref:`ref-classes-kernel-fit-image` 클래스를 사용합니다.
      FIT 이미지의 이미지 트리 소스에서 dtb 섹션을 생성하는 데 사용됩니다.

### `UBOOT_DTBO_LOADADDRESS`

      U-Boot에서 사용하는 dtbo 이미지의 로드 주소를 지정합니다. FIT 실행 중에 사용됩니다.
      이미지 생성 시, `UBOOT_DTBO_LOADADDRESS` 변수가 사용됩니다.
      로드 주소를 지정하려면 :ref:`ref-classes-kernel-fit-image` 클래스를 사용합니다.
      FIT 이미지의 이미지 트리 소스의 dtbo 섹션을 생성하는 데 사용됩니다.

### `UBOOT_ENTRYPOINT`

      U-Boot 이미지의 진입점을 지정합니다. U-Boot 이미지 실행 중
      생성 시, `UBOOT_ENTRYPOINT` 변수가 전달됩니다.
      `uboot-mkimage` 유틸리티의 명령줄 매개변수입니다.

      FIT 이미지 생성을 위해 64비트 주소를 전달하려면 다음을 설정해야 합니다.
      - FIT 이미지 생성을 위한 `FIT_ADDRESS_CELLS` 변수.
      - U-Boot FIT 이미지 생성에 사용되는 `UBOOT_FIT_ADDRESS_CELLS` 변수입니다.

      이 변수는 :ref:`ref-classes-kernel-fit-image`에서 사용됩니다.
      :ref:`ref-classes-kernel-uimage`, :ref:`ref-classes-kernel`,
      :ref:`ref-classes-uboot-config` 및 :ref:`ref-classes-uboot-sign`
      수업.

### `UBOOT_ENV`

      이 변수를 사용하면 추가 환경 변수 또는 스크립트를 추가할 수 있습니다.
      U-Boot와 함께 설치해야 합니다.
      이 파일은 일반적으로 ``uEnv.txt`` 또는 ``boot.cmd``이며, 다음 위치에 설치됩니다.
      ``/boot``뿐만 아니라 `DEPLOYDIR` 디렉터리에도 복사되었습니다.

      이러한 파일 중 하나가 필요한 시스템 구성의 경우 ``.bbappend`` 파일을 추가하십시오.
      해당 파일은 U-Boot 레시피의 ``SRC_URI`에 포함되어야 합니다.

      변수 `UBOOT_ENV_SUFFIX`가 ``scr``로 설정되어 있으면 스크립트는 다음과 같습니다.
      uImage로 패키징됩니다(``mkimage -T script..``). 그렇지 않으면 오류가 발생합니다.
      그대로 설치했습니다.

      몇 가지 예를 들면 다음과 같습니다.

      - `boot.cmd` 스크립트를 uImage로 `/boot`에 추가::

            UBOOT_ENV = "부팅"
            UBOOT_ENV_SUFFIX = "scr"
            SRC_URI += "file://${UBOOT_ENV_SRC}"

      - ``uEnv.txt`` 스크립트를 일반 텍스트 파일로 ``/boot``에 추가합니다.

            UBOOT_ENV = "uEnv"
            UBOOT_ENV_SUFFIX = "txt"
            SRC_URI += "file://${UBOOT_ENV_BINARY}"

### `UBOOT_ENV_SRC_SUFFIX`

      `UBOOT_ENV_SUFFIX`가 ``scr``로 설정된 경우, 이는 접미사입니다.
      `SRC_URI`에 지정된 대로 일반 텍스트 스크립트 파일
      U-Boot 레시피입니다. 기본값은 ``cmd``입니다.

### `UBOOT_ENV_SUFFIX`

      이 변수가 ``scr``로 설정되면, 참조되는 스크립트는 다음과 같습니다.
      UBOOT_ENV는 설치되기 전에 uImage로 패키징됩니다.
      기본값은 ``txt``이며, 이는 스크립트가 있는 그대로 설치됨을 의미합니다.
      수정 없음.

### `UBOOT_FIT_ADDRESS_CELLS`

      ``#address-cells`` 값의 값을 지정합니다.
      U-Boot FIT 이미지에 대한 설명입니다.

      :ref:`ref-classes-uboot-sign`에 의해 기본값은 "1"로 설정됩니다.
      32비트 주소에 해당하는 클래스입니다.

      64비트 주소를 설정해야 하는 플랫폼의 경우
      `UBOOT_LOADADDRESS` 및 `UBOOT_ENTRYPOINT`를 사용하려면 다음이 필요합니다.
      이 값을 "2"로 설정하십시오. 32비트 값(셀) 두 개가 필요합니다.
      그러한 주소를 나타내기 위해.

      다음은 "0x400000000"을 로드 주소로 설정하는 예입니다.

         UBOOT_FIT_ADDRESS_CELLS = "2"
         UBOOT_LOADADDRESS = "0x04 0x00000000"

      `#address-cells에 대한 자세한 내용은 <https://elinux.org/Device_Tree_Usage#How_Addressing_Works>를 참조하세요.`

### `UBOOT_FIT_ARM_TRUSTED_FIRMWARE`

      `Trusted Firmware-A (TF-A) <https://www.trustedfirmware.org/projects/tf-a>`__
      이는 Arm A-Profile용 보안 환경 소프트웨어의 참조 구현입니다.
      아키텍처(Armv8-A 및 Armv7-A)에는 예외 수준 3(EL3)이 포함됩니다.
      보안 모니터. 이 변수를 사용하면 U-Boot FIT를 생성할 수 있습니다.
      Trusted Firmware-A(TF-A) 바이너리가 포함된 이미지입니다.

      기본값은 "0"이므로 이 기능을 활성화하려면 "1"로 설정하십시오.

         UBOOT_FIT_ARM_TRUSTED_FIRMWARE = ​​"1"

### `UBOOT_FIT_ARM_TRUSTED_FIRMWARE_IMAGE`

      Trusted Firmware-A(TF-A) 바이너리의 경로를 지정합니다. 기본값은 다음과 같습니다.
      값은 "bl31.bin"입니다.

         UBOOT_FIT_ARM_TRUSTED_FIRMWARE_IMAGE ?= "bl31.bin"

      상대 경로가 제공되는 경우, 해당 파일은 기준 시점을 기준으로 상대적인 경로여야 합니다.
      U-Boot의 `B` 디렉토리입니다. 절대 경로를 제공할 수도 있습니다.
      예:

         UBOOT_FIT_ARM_TRUSTED_FIRMWARE_IMAGE ?= "${DEPLOY_DIR_IMAGE}/bl31.bin"

      Trusted Firmware-A(TF-A) 바이너리가 별도의 레시피로 빌드된 경우,
      U-Boot의 ``.bbappend`` 파일에 필요한 종속성을 추가해야 합니다.
      Trusted Firmware-A(TF-A) 바이너리의 레시피 이름은 다음과 같습니다.
      ``trusted-firmware-a``는 다음에서 가져온 것입니다.
      :yocto_git:`meta-arm </meta-arm>` 레이어::

         do_compile[depends] += "trusted-firmware-a:do_deploy"

### `UBOOT_FIT_CONF_FIRMWARE`

      구성 노드의 ``firmware`` 속성에 이미지 하나를 추가합니다.
      U-Boot 이미지 트리 소스(ITS). `firmware` 속성을 설정합니다.
      먼저 부팅할 이미지를 선택하세요::

         UBOOT_FIT_CONF_FIRMWARE = ​​"fwa"

      설정되지 않은 경우 "loadables"의 첫 번째 항목이 부팅에 사용됩니다.

### `UBOOT_FIT_CONF_USER_LOADABLES`

      `loadables` 속성에 사용자 정의 이미지를 하나 이상 추가합니다.
      U-Boot 이미지 트리 소스(ITS)의 구성 노드입니다. 이 변수는
      레시피에서 현지 셸에 의해 처리되므로 적절한 탈출이 가능합니다.
      예를 들어 따옴표 이스케이프 처리와 같은 작업을 해야 합니다.

         UBOOT_FIT_CONF_USER_LOADABLES = '\"fwa\", \"fwb\"'

### `UBOOT_FIT_DESC`

      U-Boot fitImage로 인코딩될 설명 문자열을 지정합니다. 기본값은 다음과 같습니다.
      이 값은 :ref:`ref-classes-uboot-sign` 클래스에 의해 다음과 같이 설정됩니다.

         UBOOT_FIT_DESC ?= "${DISTRO_NAME}/${PV}/${MACHINE}용 U-Boot fitImage"

### `UBOOT_FIT_GENERATE_KEYS`

      U-Boot fitImage 서명용 키를 생성할지 여부를 결정합니다.
      해당 키는 이미 존재하지 않습니다. 키는 `SPL_SIGN_KEYDIR`에 생성됩니다.
      기본값은 "0"입니다.

      다음과 같이 활성화하세요::

         UBOOT_FIT_GENERATE_KEYS = "1"

      이 변수는 :ref:`ref-classes-uboot-sign` 클래스에서 사용됩니다.

### `UBOOT_FIT_HASH_ALG`

      U-Boot FIT 이미지 생성에 사용되는 해시 알고리즘을 지정합니다.
      :ref:`ref-classes-uboot-sign`에 의해 기본값이 ``sha256``으로 설정됩니다.
      수업.

### `UBOOT_FIT_KEY_GENRSA_ARGS`

      RSA 개인 키를 생성하기 위한 `openssl genrsa` 명령어의 인수
      U-Boot FIT 이미지에 서명합니다. 이 변수의 기본값은 다음과 같습니다.
      :ref:`ref-classes-uboot-sign` 클래스에 의해 "-F4"로 설정됩니다.

### `UBOOT_FIT_KEY_REQ_ARGS`

      서명용 인증서 생성을 위한 `openssl req` 함수의 인수
      U-Boot FIT 이미지. 기본값은 "-batch -new"입니다.
      :ref:`ref-classes-uboot-sign` 클래스, "batch"
      비대화형 모드와 새 키 생성을 위한 "새로 만들기" 옵션이 있습니다.

### `UBOOT_FIT_KEY_SIGN_PKCS`

      U-Boot FIT 서명에 사용되는 공개 키 인증서의 형식입니다.
      이미지. 기본값은 "x509"로 설정되어 있습니다.
      :ref:`ref-classes-uboot-sign` 클래스.

### `UBOOT_FIT_SIGN_ALG`

      U-Boot FIT 이미지 생성에 사용되는 서명 알고리즘을 지정합니다.
      이 변수는 기본적으로 "rsa2048"로 설정됩니다.
      :ref:`ref-classes-uboot-sign` 클래스.

### `UBOOT_FIT_SIGN_NUMBITS`

      U-Boot FIT 이미지 서명에 사용되는 개인 키의 크기(숫자)
      비트 단위입니다. 이 변수의 기본값은 "2048"로 설정되어 있습니다.
      :ref:`ref-classes-uboot-sign` 클래스에 의해.

### `UBOOT_FIT_TEE`

      신뢰 실행 환경(TEE)은 다음과 같은 용도로 사용되는 안전한 환경입니다.
      코드 실행, 자산 관리의 높은 신뢰도 보장
      주변 시스템. 이 변수를 통해 U-Boot를 생성할 수 있습니다.
      신뢰할 수 있는 실행 환경(TEE) 바이너리가 포함된 FIT 이미지입니다.

      기본값은 "0"이므로 이 기능을 활성화하려면 "1"로 설정하십시오.

         UBOOT_FIT_TEE = "1"

### `UBOOT_FIT_TEE_IMAGE`

      신뢰할 수 있는 실행 환경(TEE) 바이너리의 경로를 지정합니다.
      기본값은 "tee-raw.bin"입니다.

         UBOOT_FIT_TEE_IMAGE ?= "tee-raw.bin"

      상대 경로가 제공되는 경우, 해당 파일은 기준 시점을 기준으로 상대적인 경로여야 합니다.
      U-Boot의 `B` 디렉토리입니다. 절대 경로를 제공할 수도 있습니다.
      예:

         UBOOT_FIT_TEE_IMAGE ?= "${DEPLOY_DIR_IMAGE}/tee-raw.bin"

      신뢰 실행 환경(TEE) 바이너리가 별도의 환경에서 빌드된 경우
      이 레시피를 실행하려면 U-Boot ``.bbappend`` 파일에 필요한 종속성을 추가해야 합니다.
      파일입니다. 신뢰할 수 있는 실행 환경(TEE) 바이너리의 레시피 이름은 다음과 같습니다.
      `optee-os`는 :yocto_git:`meta-arm </meta-arm>`에서 유래되었습니다.
      층::

         do_compile[depends] += "optee-os:do_deploy"

### `UBOOT_FIT_USER_SETTINGS`

      U-Boot 이미지 트리 소스(ITS)에 사용자 지정 코드 조각을 추가합니다.
      이 변수를 사용하면 사용자가 하나 이상의 사용자 정의 ``/images`` 노드를 추가할 수 있습니다.
      U-Boot 이미지 트리 소스(ITS)로 이동합니다. 자세한 내용은 다음을 참조하십시오.
      https://fitspec.osfw.foundation/\ .

      U-Boot 이미지 트리 소스(ITS)의 원래 내용은 다음과 같습니다.
      다음이 따릅니다::

         이미지 {
             uboot {
                 설명 = "U-Boot 이미지";
                 데이터 = /incbin/("u-boot-nodtb.bin");
                 유형 = "독립형";
                 os = "u-boot";
                 아치 = "";
                 압축 = "없음";
                 로드 = <0x80000000>;
                 항목 = <0x80000000>;
             };
         };

      사용자는 이 변수에 사용자 지정 ITS 코드 조각을 포함할 수 있습니다. 예:

         UBOOT_FIT_FWA_ITS = '\
             fwa {\n\
                 설명 = \"FW A\";\n\
                 데이터 = /incbin/(\"fwa.bin\");\n\
                 유형 = "펌웨어";\n\
                 아치 = \"\";\n\
                 os = \"\";\n\
                 로드 = <0xb2000000>;\n\
                 항목 = <0xb2000000>;\n\
                 압축 = "없음";\n
             };\N\
         '

         UBOOT_FIT_USER_SETTINGS = "${UBOOT_FIT_FWA_ITS}"

      이 변수는 레시피 내의 로컬 셸에서 처리되므로 적절한
      따옴표를 이스케이프 처리하고 줄 바꿈을 추가하는 등 이스케이프 처리를 해야 합니다.
      ``\n``.

      U-Boot 이미지 트리 소스(ITS)에서 생성된 콘텐츠는 다음과 같습니다.
      다음이 따릅니다::

         이미지 {
             uboot {
                 설명 = "U-Boot 이미지";
                 데이터 = /incbin/("u-boot-nodtb.bin");
                 유형 = "독립형";
                 os = "u-boot";
                 아치 = "";
                 압축 = "없음";
                 로드 = <0x80000000>;
                 항목 = <0x80000000>;
             };
             fwa {
                 설명 = "FW A";
                 데이터 = /incbin/("fwa.bin");
                 유형 = "펌웨어";
                 아치 = "";
                 os = "";
                 로드 = <0xb2000000>;
                 항목 = <0xb2000000>;
                 압축 = "없음";
             };
         };

### `UBOOT_FITIMAGE_ENABLE`

      이 변수를 사용하면 U-Boot용 FIT 이미지를 생성할 수 있습니다.
      검증된 부팅 프로세스를 구현하는 방법 중 일부입니다.

      기본값은 "0"이므로 이 기능을 활성화하려면 "1"로 설정하십시오.

         UBOOT_FITIMAGE_ENABLE = "1"

      자세한 내용은 :ref:`ref-classes-uboot-sign` 클래스를 참조하십시오.

### `UBOOT_LOADADDRESS`

      U-Boot 이미지의 로드 주소를 지정합니다. U-Boot 이미지 실행 중에
      생성 시, `UBOOT_LOADADDRESS` 변수가 전달됩니다.
      `uboot-mkimage` 유틸리티의 명령줄 매개변수입니다.

      64비트 주소를 전달하려면 다음 사항도 설정해야 합니다.

      - FIT 이미지 생성을 위한 `FIT_ADDRESS_CELLS` 변수.
      - U-Boot FIT 이미지 생성에 사용되는 `UBOOT_FIT_ADDRESS_CELLS` 변수입니다.

      이 변수는 :ref:`ref-classes-kernel-fit-image`에서 사용됩니다.
      :ref:`ref-classes-kernel-uimage`, :ref:`ref-classes-kernel`,
      :ref:`ref-classes-uboot-config` 및 :ref:`ref-classes-uboot-sign`
      수업.

### `UBOOT_LOCALVERSION`

      U-Boot의 로컬 버전 이름에 문자열을 추가합니다.
      이미지. 예를 들어, 빌드된 U-Boot 이미지 버전을 가정해 보겠습니다.
      "2013.10"인 경우 U-Boot에서 보고하는 전체 버전 문자열은 다음과 같습니다.
      "2013.10-yocto"는 다음 진술을 고려합니다.

         UBOOT_LOCALVERSION = "-yocto"

### `UBOOT_MACHINE`

      빌드 시 `make` 명령줄에 전달되는 값을 지정합니다.
      U-Boot 이미지입니다. 값은 대상 플랫폼을 나타냅니다.
      구성입니다. 일반적으로 이 변수는 컴퓨터에서 설정합니다.
      설정 파일(예: `conf/machine/machine_name.conf`).

      "프로세서 아키텍처 및 보드 유형 선택" 부분을 참조하십시오.
      이 변수에 대한 유효한 값은 U-Boot README 파일의 해당 섹션을 참조하십시오.

### `UBOOT_MAKE_OPTS`

      `UBOOT_MAKE_OPTS` 변수를 사용하여 추가 옵션을 전달할 수 있습니다.
      U-Boot가 구성되고 컴파일될 때 `make` 명령을 실행합니다.

      자세한 내용은 :ref:`ref-classes-uboot-config` 클래스를 참조하십시오.

### `UBOOT_MAKE_TARGET`

      ``Makefile``에서 호출되는 타겟을 지정합니다. 기본 타겟
      "모두"입니다.

### `UBOOT_MKIMAGE`

      mkimage 명령어가 사용되는 이름을 지정합니다.
      :ref:`ref-classes-kernel-fit-image` 클래스를 조립합니다.
      FIT 이미지입니다. 이는 대체 명령인 래퍼를 대신하여 사용할 수 있습니다.
      원하는 경우 스크립트 또는 함수를 사용할 수 있습니다. 기본값은 "uboot-mkimage"입니다.

### `UBOOT_MKIMAGE_DTCOPTS`

      ``mkimage -D`` 기능에 전달되는 장치 트리 컴파일러 옵션
      :ref:`ref-classes-kernel-fit-image`를 사용하여 FIT 이미지를 생성하는 동안
      클래스입니다. 만약 `UBOOT_MKIMAGE_DTCOPTS`가 설정되지 않았다면
      :ref:`ref-classes-kernel-fit-image` 클래스는 ``-D`` 옵션을 전달하지 않습니다.
      ``mkimage``로 이동합니다.

      이 변수는 :ref:`ref-classes-uboot-sign` 클래스에서도 사용됩니다.

### `UBOOT_MKIMAGE_KERNEL_TYPE`

      `uboot-mkimage`에 전달되는 커널의 유형 인수를 지정합니다.
      기본값은 "커널"입니다.

### `UBOOT_MKIMAGE_SIGN`

      mkimage 명령어가 사용되는 이름을 지정합니다.
      :ref:`ref-classes-kernel-fit-image` 클래스에 서명합니다
      (활성화된 경우) 조립된 FIT 이미지입니다. 이를 사용할 수 있습니다.
      대체 명령, 래퍼 스크립트 또는 함수를 사용하려면
      원하는 값입니다. 기본값은 "${`UBOOT_MKIMAGE`}"입니다.

### `UBOOT_MKIMAGE_SIGN_ARGS`

      선택적으로 추가 인수를 지정합니다.
      :ref:`ref-classes-kernel-fit-image` 클래스를 전달합니다.
      FIT 이미지에 서명할 때 사용하는 mkimage 명령어입니다.

### `UBOOT_RD_ENTRYPOINT`

      RAM 디스크 이미지의 진입점을 지정합니다. FIT 이미지 실행 중
      생성 시, `UBOOT_RD_ENTRYPOINT` 변수가 사용됩니다.
      :ref:`ref-classes-kernel-fit-image` 클래스를 사용하여 진입점을 지정합니다.
      FIT 이미지의 이미지 트리 소스를 생성하는 데 사용됩니다.

### `UBOOT_RD_LOADADDRESS`

      FIT 이미지 실행 중에 RAM 디스크 이미지의 로드 주소를 지정합니다.
      생성 시, `UBOOT_RD_LOADADDRESS` 변수가 사용됩니다.
      로드 주소를 지정하려면 :ref:`ref-classes-kernel-fit-image` 클래스를 사용합니다.
      FIT 이미지의 이미지 트리 소스를 생성하는 데 사용됩니다.

### `UBOOT_SIGN_ENABLE`

      FIT 이미지 서명을 활성화합니다. 기본값은 "0"입니다.

      이 변수는 :ref:`ref-classes-uboot-config` 클래스에서 정의되고 사용됩니다.

      또한, 이는 다음의 기본값으로 사용됩니다.
      `FIT_KERNEL_SIGN_ENABLE` 변수는 다음과 같습니다.
      :ref:`ref-classes-kernel-fit-image` 클래스에서 사용됩니다.

      즉, `UBOOT_SIGN_ENABLE`이 "1"로 설정되어 있으면,
      :ref:`ref-classes-kernel-fit-image` 클래스는 FIT 이미지에 서명합니다.
      지정된 개인 키를 사용하여 빌드 시간 동안, 그리고
      :ref:`ref-classes-uboot-sign` 클래스는 해당 공개 클래스를 주입합니다.
      U-Boot의 장치 트리에 키를 입력합니다. 이렇게 하면 U-Boot가 해당 키를 검증합니다.
      부팅 시 FIT 이미지의 진위성과 무결성을 보장하여 제공합니다.
      무단 또는 변조된 이미지를 방지하는 데 도움이 되는 보안 부팅 워크플로
      로드되는 것부터.

      자세한 내용은 `<https://docs.u-boot.org/en/v2025.10/usage/fit/signature.html>`__을 참조하세요.
      U-Boot의 FIT 서명 검증에 대한 자세한 정보입니다.

### `UBOOT_SIGN_KEYDIR`

      RSA 키와 인증서가 포함된 디렉터리의 위치
      :ref:`ref-classes-kernel-fit-image`에서 사용되는 FIT 이미지에 서명합니다.
      (FIT_KERNEL_SIGN_KEYDIR 변수를 통해)
      그리고 :ref:`ref-classes-uboot-sign` 클래스입니다.

### `UBOOT_SIGN_KEYNAME`

      :ref:`ref-classes-kernel-fit-image` 클래스에서 사용되는 키의 이름
      (변수 `FIT_KERNEL_SIGN_KEYNAME`을 통해)
      `UBOOT_SIGN_KEYDIR`에 저장된 U-Boot FIT 이미지에 서명하기 위한 것입니다.
      디렉토리입니다. 예를 들어 `dev.key`라는 키와 `dev.crt`라는 파일이 있다고 가정해 보겠습니다.
      인증서는 `UBOOT_SIGN_KEYDIR` 디렉터리에 저장됩니다.
      `UBOOT_SIGN_KEYNAME`을 ``dev``로 설정해야 합니다.

### `UBOOT_SUFFIX`

      생성된 U-Boot 확장 프로그램의 경로를 지정합니다. 예를 들어, ``u-boot.sb``입니다.
      확장자는 ``.sb``입니다.

      U-Boot의 기본 확장자는 ``.bin``입니다.

### `UBOOT_TARGET`

      U-Boot 빌드에 사용할 타겟을 지정합니다. 타겟은 전달됩니다.
      "make" 명령의 일부로 직접 사용합니다(예: SPL 및 AIS). 만약 그렇게 한다면
      이 변수를 명시적으로 설정하지 않으면 OpenEmbedded 빌드 프로세스가 실행됩니다.
      U-Boot 빌드 중에 대상에 대해 "all"을 전달하고 사용합니다.
      프로세스.

### `UBOOT_VERSION`

      설치 및 배포되는 파일의 이름을 지정할 때 패키지 버전을 사용합니다.
      (`PV`)와 (`PR`) 수정 버전은 파일 이름의 일부입니다.
      `UBOOT_VERSION` 변수에는 이 정보가 포함되어 있지만,
      원하는 경우 재정의할 수 있습니다.

### `UKI_CMDLINE`

      `ref-classes-uki` 클래스를 상속할 때 커널 명령줄
      `통합 커널 이미지(UKI)`를 부팅할 때 사용합니다.
      <https://uapi-group.org/specifications/specs/unified_kernel_image/>`__.
      기본값은 ``rootwait root=LABEL=root console=${KERNEL_CONSOLE}``입니다.

### `UKI_CONFIG_FILE`

      `:ref:`ref-classes-uki` 클래스를 상속할 때 선택적 구성
      `ukify` 파일
      <https://www.freedesktop.org/software/systemd/man/latest/ukify.html>`__
      명령.

### `UKI_FILENAME`

      `:ref:`ref-classes-uki` 클래스를 상속할 때 출력 파일 이름은 다음과 같습니다.
      생성된 `통합 커널 이미지(UKI)`의 경우
      <https://uapi-group.org/specifications/specs/unified_kernel_image/>`__.
      기본값은 ``uki.efi``입니다.

### `UKI_KERNEL_FILENAME`

      `ref-classes-uki` 클래스를 상속할 때 커널 이미지 파일
      입력으로 사용할 이름입니다. 기본값은 `KERNEL_IMAGETYPE`입니다.

### `UKI_SB_CERT`

      `ref-classes-uki` 클래스를 상속할 때, 선택적 UEFI
      `UKI_SB_KEY`에 있는 개인 키와 일치하는 Secure Boot 인증서입니다.

### `UKI_SB_KEY`

      `ref-classes-uki` 클래스를 상속할 때, 선택적 UEFI
      `Unified Kernel Image (UKI)`에 서명하기 위한 Secure Boot 개인 키
      <https://uapi-group.org/specifications/specs/unified_kernel_image/>`__.

### `UKIFY_CMD`

      `ref-classes-uki` 클래스를 상속받을 때,
      빌드하려면 `ukify <https://www.freedesktop.org/software/systemd/man/latest/ukify.html>`__ 명령어를 사용하세요.
      `통합 커널 이미지(UKI) <https://uapi-group.org/specifications/specs/unified_kernel_image/>`__.
      기본값은 ``ukify 빌드``입니다.

### `UNINATIVE_CHECKSUM`

      `ref-classes-uninative` 클래스를 상속받을 때,
      `UNINATIVE_CHECKSUM` 변수 플래그에는 체크섬이 포함됩니다.
      `UNINATIVE_URL` 변수에 지정된 대로 uninative tarball입니다.
      게시된 tarball 파일 하나당 체크섬이 하나씩 있어야 합니다.
      아키텍처와 일치하는 `UNINATIVE_URL`이라는 용어가 있습니다. 예를 들면 다음과 같습니다.

         UNINATIVE_CHECKSUM[aarch64] ?= "812045d826b7fda88944055e8526b95a5a9440bfef608d5b53fd52faab49bf85"
         UNINATIVE_CHECKSUM[i686] ?= "5cc28efd0c15a75de4bcb147c6cce65f1c1c9d442173a220f08427f40a3ffa09"
         UNINATIVE_CHECKSUM[x86_64] ?= "4c03d1ed2b7b4e823aca4a1a23d8f2e322f1770fc10e859adcede5777aff4f3a"

### `UNINATIVE_URL`

      `ref-classes-uninative` 클래스를 상속받을 때,
      `UNINATIVE_URL` 변수에는 uninative가 있는 URL이 포함됩니다.
      tarball 파일이 게시되었습니다.

### `UNKNOWN_CONFIGURE_OPT_IGNORE`

      구성 스크립트에서 보고될 경우 사용될 옵션 목록을 지정합니다.
      유효하지 않으므로 경고를 발생시키지 않아야 합니다.
      :ref:`ref-tasks-configure` 작업. 일반적으로 유효하지 않음
      구성 옵션은 구성 스크립트로 전달되지 않습니다(예:
      `EXTRA_OECONF`에서 제거되어야 합니다.
      `PACKAGECONFIG_CONFARGS`).
      하지만 모든 경우에 공통적으로 전달되는 옵션들이 있습니다.
      클래스 수준에서 스크립트를 구성할 수 있지만 일부 경우에는 유효하지 않을 수 있습니다.
      스크립트를 구성합니다. 따라서 이러한 옵션에 대한 경고는 무의미합니다.
      이러한 경우 옵션이 `UNKNOWN_CONFIGURE_OPT_IGNORE`에 추가됩니다.

      구성 인자 검사는 다음을 사용합니다.
      `UNKNOWN_CONFIGURE_OPT_IGNORE`는 다음의 일부입니다.
      :ref:`ref-classes-insane` 클래스는 다음 조건이 충족될 때만 활성화됩니다.
      이 레시피는 :ref:`ref-classes-autotools` 클래스를 상속합니다.

### `UNPACKDIR`

      이 변수는 `:ref:`ref-classes-base` 클래스에서 사용됩니다.
      가져온 소스 파일을 어디에서 압축 해제해야 하는지 지정합니다.
      :ref:`ref-tasks-unpack` 작업.

### `UPDATERCPN`

      레시피가 상속받는 경우
      :ref:`ref-classes-update-rc.d` 클래스, `UPDATERCPN`
      활성화된 초기화 스크립트가 포함된 패키지를 지정합니다.

      기본값은 "${PN}"입니다. 거의 모든 레시피가 그렇다는 점을 고려하면
      레시피의 메인 패키지에 initscripts 패키지를 설치하세요.
      개별 레시피에서 이 변수를 설정해야 하는 경우는 드뭅니다.

### `UPSTREAM_CHECK_COMMITS`

      레시피별로 최신 업스트림 정보를 확인할 수 있습니다.
      소스 코드 버전은 `devtool latest-version recipe`를 호출하여 확인할 수 있습니다.
      레시피 소스 코드는 Git 저장소에서 제공되지만,
      릴리스는 Git 태그로 식별되지 않으므로 `UPSTREAM_CHECK_COMMITS`를 설정하십시오.
      레시피에서 ``1``로 설정하고 OpenEmbedded 빌드 시스템을 사용합니다.
      최신 커밋과 현재 지정된 커밋을 비교합니다.
      레시피에 따라 (`SRCREV`)::

         UPSTREAM_CHECK_COMMITS = "1"

### `UPSTREAM_CHECK_GITTAGREGEX`

      레시피별로 최신 업스트림 정보를 확인할 수 있습니다.
      소스 코드 버전은 `devtool latest-version recipe`를 호출하여 확인할 수 있습니다.
      레시피 소스 코드는 Git 저장소에서 제공됩니다.
      OpenEmbedded 빌드 시스템은 최신 업스트림 버전을 다음과 같이 결정합니다.
      저장소의 모든 태그 목록에서 최신 태그를 선택합니다.

      `UPSTREAM_CHECK_GITTAGREGEX` 변수를 사용하여 제공할 수 있습니다.
      관련 태그만 필터링하려면 정규 표현식을 사용해야 합니다.
      기본 필터가 제대로 작동하지 않습니다.

         UPSTREAM_CHECK_GITTAGREGEX = "git_tag_regex"

### `UPSTREAM_CHECK_REGEX`

      다른 정규 표현식을 지정하려면 `UPSTREAM_CHECK_REGEX` 변수를 사용하십시오.
      패키지에서 기본 정규 표현식 대신 정규 표현식을 사용합니다.
      검사 시스템은 찾은 페이지를 구문 분석하고 있습니다.
      `UPSTREAM_CHECK_URI`::

         UPSTREAM_CHECK_REGEX = "package_regex"

### `UPSTREAM_CHECK_URI`

      레시피별로 최신 업스트림 정보를 확인할 수 있습니다.
      소스 코드 버전은 `devtool latest-version recipe`를 호출하여 확인할 수 있습니다.
      소스 코드는 tarball 형태로 제공되며, 최신 버전은 다음과 같습니다.
      tarball이 있는 디렉토리 목록을 가져와서 결정합니다.
      더 최신 버전의 tarball을 찾으려고 시도합니다. 이 방법이 효과가 없을 경우,
      `UPSTREAM_CHECK_URI`를 사용하면 다른 URI를 제공할 수 있습니다.
      최신 tarball 링크가 포함되어 있습니다.

         UPSTREAM_CHECK_URI = "레시피_url"

### `UPSTREAM_VERSION_UNKNOWN`

      레시피별로 최신 업스트림 정보를 확인할 수 있습니다.
      소스 코드 버전은 ``devtool latest-version recipe``를 호출하여 확인할 수 있습니다.
      `UPSTREAM_CHECK_URI`, `UPSTREAM_CHECK_REGEX`의 어떤 조합도 사용할 수 없는 경우,
      `UPSTREAM_CHECK_GITTAGREGEX` 및 `UPSTREAM_CHECK_COMMITS` 변수
      이 레시피를 사용하면 최신 업스트림 버전이 무엇인지 확인할 수 있습니다.
      레시피에서 ``UPSTREAM_VERSION_UNKNOWN`을 ``1``로 설정할 수 있습니다.
      검사를 수행할 수 없음을 인정합니다.

         UPSTREAM_VERSION_UNKNOWN = "1"

### `USE_DEVFS`

      `/dev` 디렉터리 채우기에 `devtmpfs`를 사용할지 여부를 결정합니다.
      `USE_DEVFS`에 값이 지정되지 않은 경우 기본값은 "1"입니다.
      특별히 설정합니다. 일반적으로는 `USE_DEVFS`를 "0"으로 설정합니다.
      정적으로 채워진 ``/dev`` 디렉터리.

      ":ref:`dev-manual/device-manager:장치 관리자 선택`" 섹션을 참조하십시오.
      자세한 내용은 Yocto 프로젝트 개발 작업 매뉴얼을 참조하십시오.
      이 변수를 사용하세요.

### `USE_NLS`

      레시피에 대해 언어 번역을 구축해야 하는지 여부를 결정합니다.
      그것들을 구축하세요. 이 변수는 다음과 같을 수 있습니다:

      - 예: 번역이 활성화되어 있습니다.
      - ``아니요``: 번역이 비활성화되었습니다.

      레시피는 이 변수 ​​값을 사용하여 언어를 활성화할 수 있습니다.
      빌드 과정에서 번역이 이루어집니다. :ref:`ref-classes-gettext`와 같은 클래스가 있습니다.
      이 변수의 값을 사용하여 :wikipedia:`Gettext <Gettext>`를 활성화하세요.
      지원하다.

### `USE_VT`

      사용 시
      :ref:`SysVinit <dev-manual/new-recipe:시스템 서비스 활성화>`,
      `Getty`를 실행할지 여부를 결정합니다.
      가상 터미널을 통해 로그인할 수 있도록 하려면 모든 가상 터미널에서 다음과 같은 작업을 수행해야 합니다.
      터미널.

      `USE_VT`에 사용되는 기본값은 기본값이 지정되지 않은 경우 "1"입니다.
      특별히 설정합니다. 일반적으로 `USE_VT`를 "0"으로 설정합니다.
      그래픽 인터페이스가 없는 기기용 기기 구성 파일
      디스플레이가 연결되어 있으므로 가상 터미널이 필요하지 않습니다.
      기능.

### `USER_CLASSES`

      전역적으로 상속받을 클래스 목록입니다. 이 클래스들은 다음에서 사용됩니다.
      추가 기능을 활성화하기 위한 OpenEmbedded 빌드 시스템.

      `USER_CLASSES`를 사용하여 상속된 클래스는 다음 위치에 있어야 합니다.
      `classes-global/` 또는 `classes/` 하위 디렉터리.

      기본 목록은 ``local.conf`` 파일에 설정되어 있습니다.

         USER_CLASSES ?= "buildstats"

      더 자세한 내용은 다음을 참조하세요.
      ``meta-poky/conf/templates/default/local.conf.sample``에서
      `소스 디렉토리`.

### `USERADD_DEPENDS`

      사용자/그룹을 생성하는 레시피 목록을 지정합니다(via).
      `USERADD_PARAM` / `GROUPADD_PARAM`) 레시피
      ~에 따라 달라집니다. 이는 해당 사용자/그룹을 사용할 수 있도록 보장합니다.
      레시피를 만들 때.

### `USERADD_ERROR_DYNAMIC`

      `error`로 설정하면 OpenEmbedded 빌드 시스템이 오류를 발생시키도록 강제합니다.
      사용자 식별자(``uid``)와 그룹이 일치하지 않으면 오류가 발생합니다.
      식별자(``gid``) 값은 어떤 파일에도 정의되어 있지 않습니다.
      `USERADD_UID_TABLES`에 나열되어 있습니다.
      `USERADD_GID_TABLES`. 설정된 경우
      `warn`을 입력하면 경고 메시지가 표시됩니다.

      빌드 시스템의 기본 동작은 동적으로 적용하는 것입니다.
      `uid` 및 `gid` 값. 결과적으로,
      `USERADD_ERROR_DYNAMIC` 변수는 기본적으로 설정되어 있지 않습니다. 설정하려면 다음 단계를 따르세요.
      정적으로 할당된 `gid` 및 `uid` 값을 사용할 때는 다음 사항을 고려해야 합니다.
      `local.conf` 파일에 ``USERADD_ERROR_DYNAMIC` 변수를 설정하세요.
      다음과 같이 파일을 작성하십시오::

         USERADD_ERROR_DYNAMIC = "오류"

      재정의
      기본 동작은 설정 단계도 밟을 것임을 의미합니다.
      정적 ``uid`` 및 ``gid`` 값은 다음을 사용하여 얻습니다.
      `USERADDEXTENSION`,
      `USERADD_UID_TABLES`, 및
      `USERADD_GID_TABLES` 변수.

      .. 메모::

         설정에 따라 동작 방식에 차이가 있습니다.
         `USERADD_ERROR_DYNAMIC`을 `error`로 변경하고 `warn`으로 설정합니다.
         `warn`으로 설정하면 빌드 시스템에서 경고를 보고합니다.
         모든 레시피에서 정의되지 않은 `uid`와 `gid`가 있습니다. 하지만 설정되면...
         `error`로 설정하면 실제로 오류가 발생한 레시피에 대해서만 오류를 보고합니다.
         세워짐.
         이렇게 하면 레시피에 고정 ID를 추가할 필요가 없습니다.
         그것은 결코 지어지지 않을 것이라는 것을 알고 있다.

### `USERADD_GID_TABLES`

      정적 그룹을 얻는 데 사용할 암호 파일을 지정합니다.
      OpenEmbedded 빌드 시스템에서 식별(``gid``) 값
      패키지 설치 중에 시스템에 그룹을 추가합니다.

      정적 그룹 식별자(``gid``) 값을 적용할 때,
      OpenEmbedded 빌드 시스템은 BBPATH에서 다음을 찾습니다.
      `files/group` 파일을 열고 해당 `uid` 값을 적용합니다. 설정합니다.
      `local.conf` 파일에 다음과 같이 변수를 추가하세요.


         USERADD_GID_TABLES = "파일/그룹"

      .. 메모::

         `USERADDEXTENSION` 변수를 "useradd-staticids"로 설정합니다.
         빌드 시스템이 정적 ``gid`` 값을 사용하도록 합니다.

### `USERADD_PACKAGES`

      :ref:`ref-classes-useradd` 클래스를 상속할 때,
      이 변수는 레시피 내의 개별 패키지를 지정합니다.
      사용자 및/또는 그룹을 추가해야 하는 경우.

      레시피가 해당 클래스를 상속받는 경우 이 변수를 설정해야 합니다.
      예를 들어, 다음은 메인 패키지에 사용자를 추가하는 방법입니다.
      레시피::

         USERADD_PACKAGES = "${PN}"

      .. 메모::

         따라서 `USERADD_PACKAGES` 명령어를 사용하려면 다음과 같은 사항을 고려해야 합니다.
         변수를 사용하려면 `USERADD_PARAM` 중 하나 이상을 설정해야 합니다.
         `GROUPADD_PARAM` 또는 `GROUPMEMS_PARAM` 변수입니다.

### `USERADD_PARAM`

      :ref:`ref-classes-useradd` 클래스를 상속할 때,
      이 변수는 패키지에 전달해야 하는 매개변수를 지정합니다.
      시스템에 사용자를 추가할 때 `useradd` 명령어를 사용합니다.
      패키지가 설치되었습니다.

      다음은 ``dbus`` 레시피의 예입니다.

         USERADD_PARAM:${PN} = "--system --home ${localstatedir}/lib/dbus \
                                --no-create-home --shell /bin/false \
                                --사용자 그룹 메시지버스"

      자세한 내용은 다음을 참조하십시오.
      표준 Linux 셸 명령 `useradd`를 참조하십시오.
      https://linux.die.net/man/8/useradd.

### `USERADD_UID_TABLES`

      정적 사용자 정보를 얻기 위해 사용할 암호 파일을 지정합니다.
      OpenEmbedded 빌드 시스템에서 식별(``uid``) 값
      패키지 설치 중에 시스템에 사용자를 추가합니다.

      정적 사용자 식별(``uid``) 값을 적용할 때,
      OpenEmbedded 빌드 시스템은 BBPATH에서 다음을 찾습니다.
      `files/passwd` 파일을 열고 해당 `uid` 값을 적용합니다. 설정하세요.
      `local.conf` 파일에 다음과 같이 변수를 추가하세요.

         USERADD_UID_TABLES = "files/passwd"

      .. 메모::

         `USERADDEXTENSION` 변수를 "useradd-staticids"로 설정합니다.
         빌드 시스템이 정적 `uid` 값을 사용하도록 합니다.

### `USERADDEXTENSION`

      "useradd-staticids"로 설정하면 OpenEmbedded 빌드 시스템이 작동합니다.
      모든 사용자 및 그룹 추가를 정적 ``passwd``를 기반으로 합니다.
      ``그룹`` 파일이 `BBPATH`에서 발견되었습니다.

      정적 사용자 식별자(``uid``) 및 그룹 식별자를 사용하려면
      (``gid``) 값을 설정하려면 ``local.conf`` 파일에 다음과 같이 변수를 설정하세요.
      파일: USERADDEXTENSION = "useradd-staticids"

      .. 메모::

         이 변수를 정적 `uid` 및 `gid`를 사용하도록 설정합니다.
         값으로 인해 OpenEmbedded 빌드 시스템이 다음을 사용하게 됩니다.
         :ref:`ref-classes-useradd` 클래스.

      정적 `uid` 및 `gid` 정보를 사용하는 경우 다음 사항도 준수해야 합니다.
      `files/passwd` 및 `files/group` 파일을 지정하려면 다음을 설정하십시오.
      `USERADD_UID_TABLES` 및
      `USERADD_GID_TABLES` 변수.
      또한, 다음 사항도 설정해야 합니다.
      `USERADD_ERROR_DYNAMIC` 변수.

### `VIRTUAL-RUNTIME`

      `VIRTUAL-RUNTIME`은 가상 런타임을 정의할 때 일반적으로 사용되는 접두사입니다.
      런타임 사용을 위한 패키지이며, 일반적으로 `RDEPENDS`에서 사용됩니다.
      또는 이미지 정의에서.

      예를 들어 ``VIRTUAL-RUNTIME_base-utils``는 이를 가능하게 합니다.
      BusyBox 기반 유틸리티를 사용하려면::

         VIRTUAL-RUNTIME_base-utils = "busybox"

      또는 GNU Coreutils에서 제공하는 모든 기능을 갖춘 구현체
      기타 프로젝트::

         VIRTUAL-RUNTIME_base-utils = "packagegroup-core-base-utils"

      다음은 이 가상 런타임 패키지를 사용하는 두 가지 예입니다.
      첫 번째는 :yocto_git:`initramfs-framework_1.0.bb`에 있습니다.
      </poky/tree/meta/recipes-core/initrdscripts/initramfs-framework_1.0.bb?h=scarthgap>`::

         RDEPENDS:${PN} += "${VIRTUAL-RUNTIME_base-utils}"

      두 번째 예시는 :yocto_git:`core-image-initramfs-boot`에 있습니다.
      </poky/tree/meta/recipes-core/images/core-image-initramfs-boot.bb?h=scarthgap>`
      이미지 정의::

         PACKAGE_INSTALL = "${INITRAMFS_SCRIPTS} ${VIRTUAL-RUNTIME_base-utils} base-passwd"

### `WARN_QA`

      실패 시 보고되는 품질 보증 검사를 지정합니다.
      OpenEmbedded 빌드 시스템에서 경고가 표시됩니다. 이 변수는 다음 위치에서 설정합니다.
      배포 구성 파일입니다. 검사 목록을 보려면 다음을 참조하세요.
      이 변수를 통해 제어할 수 있습니다. 자세한 내용은 다음을 참조하세요.
      ":ref:`ref-classes-insane`" 섹션.

### `WATCHDOG_RUNTIME_SEC`

      `systemd` 레시피의 경우, 이것은 다음 값을 제어합니다.
      `/etc/systemd/system.conf` 파일의 `RuntimeWatchdogSec` 옵션입니다. 기본값은 다음과 같습니다.
      값은 빈 문자열입니다.

### `WATCHDOG_TIMEOUT`

      `watchdog-config` 레시피에서 사용하는 타임아웃 시간을 초 단위로 지정합니다.
      또한 재부팅 시 ``systemd``에 의해서도 설정됩니다. 기본값은 60초입니다.

### `WESTON_USER`

      `WESTON_USER` 변수는 `Weston` 사용자의 사용자 이름을 정의합니다.
      사용자.

### `WESTON_USER_HOME`

      ``WESTON_USER` 변수는 홈 디렉터리의 경로를 정의합니다.
      `Weston` 사용자님께.

### `WIC_CREATE_EXTRA_ARGS`

      `IMAGE_FSTYPES` 변수에 "wic"가 포함되어 있으면 빌드가 실행됩니다.
      생성할 것입니다
      :ref:`Wic 이미지 <dev-manual/wic:wic를 사용한 파티션 이미지 생성>`
      BitBake가 이미지 레시피를 빌드할 때 자동으로 수행됩니다.
      이 과정에서 BitBake는 "`wic create`" 명령어를 실행합니다.
      `WIC_CREATE_EXTRA_ARGS` 변수는 이 끝에 배치됩니다.
      사용자가 추가 인수를 제공할 수 있도록 하는 명령입니다.

      이 메커니즘의 유용한 용도 중 하나는 ``-D``(또는)를 추가하는 것입니다.
      `wic create` 명령에 `--debug` 인수를 추가합니다. 이렇게 하면 디버그 레벨이 증가합니다.
      디버깅 과정에서 Wic 로그에 기록되는 디버깅 정보의 양
      Wic 제작 과정.

### `WIC_SECTOR_SIZE`

      변수 `WIC_SECTOR_SIZE`는 WIC의 섹터 크기를 제어합니다.
      이미지. 백그라운드에서 이것은 값을 제어합니다.
      `parted`에 전달되는 `PARTED_SECTOR_SIZE` 환경 변수
      이미지를 생성하는 데 사용되는 명령줄 유틸리티입니다. 기본값은 다음과 같습니다.
      ``512``.

      Wic 이미지를 만드는 방법에 대한 자세한 내용은 다음을 참조하세요.
      ":ref:`dev-manual/wic:wic를 사용하여 파티션된 이미지 생성`" 섹션
      Yocto 프로젝트 개발 작업 매뉴얼.

### `WIRELESS_DAEMON`

      `connman`과 `packagegroup-base`의 경우 무선 설정을 지정합니다.
      사용할 데몬입니다. 기본값은 "wpa-supplicant"입니다(값에 유의하세요).
      밑줄이 아닌 대시를 사용합니다.

### `WKS_FILE`

      Wic 킥스타트 파일의 위치를 ​​지정합니다.
      파티션된 이미지를 생성하기 위한 OpenEmbedded 빌드 시스템
      (``image.wic``). 파티션된 파일을 생성하는 방법에 대한 정보는 다음을 참조하세요.
      이미지를 보려면 클릭하세요.
      ":ref:`dev-manual/wic:wic를 사용하여 파티션된 이미지 생성`"
      Yocto 프로젝트 개발 작업 매뉴얼의 해당 섹션을 참조하십시오. 자세한 내용은
      킥스타트 파일 형식에 대한 자세한 내용은 ":doc:`/ref-manual/kickstart`" 장을 참조하십시오.

### `WKS_FILE_DEPENDS`

      이미지를 생성하는 레시피에 이 변수를 넣으면 다음과 같은 결과가 나타납니다.
      빌드 시간 종속성. `WKS_FILE_DEPENDS` 변수는 단지
      Wic 이미지가 활성화된 경우(즉, 활성화된 경우)에 적용됩니다.
      `IMAGE_FSTYPES`에는 관련 항목이 포함되어 있습니다.
      Wic에). 레시피에서 Wic 이미지를 생성하지 않는 경우 변수는 다음과 같습니다.
      아무런 효과가 없습니다.

      `WKS_FILE_DEPENDS` 변수는 다음과 유사합니다.
      `DEPENDS` 변수. 이 변수를 사용할 때
      Wic 이미지를 생성하는 레시피와 나열된 종속성
      `WKS_FILE_DEPENDS` 변수가 `DEPENDS` 변수에 추가됩니다.

      `WKS_FILE_DEPENDS` 변수를 사용하면 다음과 같은 가능성이 열립니다.
      추가 종속성 목록(예: 네이티브 도구)을 지정합니다.
      Wic 이미지를 빌드하는 데 필요한 부트로더 등입니다.
      다음은 예시입니다.

         WKS_FILE_DEPENDS = "some-native-tool"

      그 안에서
      이전 예시에서 some-native-tool은 실제 도구로 대체됩니다.
      빌드가 의존하는 네이티브 도구입니다.

### `WKS_FILES`

      Wic 킥스타트에서 사용할 후보 파일 목록을 지정합니다.
      파티션된 이미지를 생성하기 위한 OpenEmbedded 빌드 시스템.
      왼쪽에서 오른쪽으로 가장 먼저 발견되는 것이 사용됩니다.

      이는 여러 개의 ``.wks`` 파일이 있을 때만 유용합니다.
      이미지를 생성하는 데 사용됩니다. 대표적인 예는 여러 레이어가 사용되는 경우입니다.
      서로 다른 하드웨어 플랫폼에서 사용되며, 각 플랫폼은 서로 다른 기능을 제공합니다.
      ``.wks`` 파일입니다. 이 경우, 가능한 모든 옵션을 지정합니다.
      `WKS_FILES`.

      ``.wks`` 파일이 하나만 사용되는 경우, 대신 `WKS_FILE`을 설정하십시오.

### `WORKDIR`

      OpenEmbedded 빌드가 실행되는 작업 디렉터리의 경로명입니다.
      시스템이 레시피를 생성합니다. 이 디렉토리는 다음 위치에 있습니다.
      `TMPDIR` 디렉터리 구조는 특정 용도에 특화되어 있습니다.
      현재 만들어지고 있는 레시피와 그 레시피가 만들어지고 있는 시스템.

      `WORKDIR` 디렉터리는 다음과 같이 정의됩니다.

         ${TMPDIR}/work/${MULTIMACH_TARGET_SYS}/${PN}/${EXTENDPE}${PV}-${PR}

      실제 디렉토리는 여러 요인에 따라 달라집니다.

      - `TMPDIR`: 최상위 빌드 출력 디렉터리
      - `MULTIMACH_TARGET_SYS`: 대상 시스템 식별자
      - `PN`: 레시피 이름
      - `EXTENDPE`: 에포크 --- `PE`가 지정되지 않은 경우,
         대부분의 레시피에서 일반적으로 그렇듯이, 이 경우 `EXTENDPE`는 비어 있습니다.
      - `PV`: 레시피 버전
      - `PR`: 레시피 수정

      예를 들어, 소스 디렉터리 최상위 폴더 이름이 다음과 같다고 가정해 보겠습니다.
      `poky`는 기본 빌드 디렉토리인 `poky/build`를 가지며,
      ``qemux86-poky-linux`` 머신 대상 시스템이라고 가정해 봅시다. 또한,
      레시피 이름이 ``foo_1.3.0-r0.bb``입니다. 이 경우 작업은
      빌드 시스템이 패키지를 빌드하는 데 사용하는 디렉터리는 다음과 같습니다.
      다음이 따릅니다::

         poky/build/tmp/work/qemux86-poky-linux/foo/1.3.0-r0

### `XSERVER`

      X를 제공하기 위해 설치해야 하는 패키지를 지정합니다.
      현재 머신의 서버 및 드라이버(이미지를 기준으로 함)
      ``packagegroup-core-x11-xserver``를 직접 포함하거나, 또는
      간접적으로, "x11-base"를 포함합니다.
      `이미지_특징`.

      머신에 지정되지 않은 경우 `XSERVER`의 기본값입니다.
      구성은 "xserver-xorg xf86-video-fbdev xf86-input-evdev"입니다.

### `XZ_MEMLIMIT`

      xz 압축에 사용할 최대 메모리 용량을 백분율로 지정합니다.
      시스템 메모리. 제약이 없을 경우 xz 압축기는 상당한 양의 메모리를 사용할 수 있습니다.
      메모리 사용량이 많아지고 빌드 과정의 다른 부분에서 병렬 처리 문제가 발생할 수 있습니다.
      "50%"가 적절한 값으로 밝혀졌습니다.

### `XZ_THREADS`

      병렬로 실행해야 하는 스레드 수를 지정합니다.
      xz 압축을 사용합니다.

      기본적으로 이 값은 코어 수에 따라 증가하지만 2보다 작게 설정되지는 않습니다.
      멀티스레드 모드가 항상 사용되도록 하여 출력이 정확하게 나오도록 합니다.
      파일 내용은 확정적입니다. 값이 1인 경우에도 빌드는 정상적으로 작동합니다.
      하지만 출력 결과는 압축 결과와 다를 것입니다.
      두 개 이상의 스레드를 사용할 때 생성됩니다.

      많은 작업이 병렬로 실행되는 시스템에서는 이에 제한을 설정하는 것이 좋습니다.
      시스템 리소스 사용량을 제어하는 ​​데 도움이 될 수 있습니다.

### `ZSTD_COMPRESSION_LEVEL`

      ZStandard 압축에 사용할 압축 수준을 지정합니다.
      (``1``부터 ``19``까지이며, 상위 선택에 따라 기본값은 ``3``으로 설정됩니다.)
      레벨이 높을수록 파일 크기는 작아지지만 완료하는 데 시간이 더 오래 걸립니다.

### `ZSTD_THREADS`

      병렬로 실행해야 하는 스레드 수를 지정합니다.
      ZStandard 압축 방식을 사용합니다.

      기본적으로 이 값은 코어 수에 따라 증가하지만 2보다 작게 설정되지는 않습니다.
      멀티스레드 모드가 항상 사용되도록 하여 출력이 정확하게 나오도록 합니다.
      파일 내용은 확정적입니다. 값이 1인 경우에도 빌드는 정상적으로 작동합니다.
      하지만 출력 결과는 압축 결과와 다를 것입니다.
      두 개 이상의 스레드를 사용할 때 생성됩니다.

      많은 작업이 병렬로 실행되는 시스템에서는 이에 제한을 설정하는 것이 좋습니다.
      시스템 리소스 사용량을 제어하는 ​​데 도움이 될 수 있습니다.