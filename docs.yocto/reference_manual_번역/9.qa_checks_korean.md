# QA 오류 및 경고 메시지

## 9.1 소개

레시피를 빌드할 때 OpenEmbedded 빌드 시스템은 출력에 대해 다양한 QA 검사를 수행하여 일반적인 문제가 감지되고 보고되도록 합니다. 새 레시피를 작성하여 새 소프트웨어를 빌드할 때 문제 없이 빌드될 수 있습니다. 그렇지 않은 경우이거나 소프트웨어를 빌드할 때 QA 문제가 있을 경우 해결하는 데 약간의 시간이 걸릴 수 있습니다.

QA 메시지를 무시하거나 QA 검사를 비활성화하려는 유혹이 있을 수 있지만, 보고된 QA 문제를 해결하려고 시도하는 것이 가장 좋습니다. 이 장에서는 QA 메시지 목록과 발생할 수 있는 문제에 대한 간단한 설명을 제공하여 문제를 적절히 해결할 수 있도록 합니다.

다음 섹션에서는 기본 구성을 기반으로 하는 모든 QA 오류 및 경고 메시지의 목록을 제공합니다. 각 항목은 메시지 또는 오류 형식과 설명을 제공합니다.

> **참고:**
>
> - 각 메시지의 끝에 관련 QA 테스트의 이름(insane 섹션에 나열됨)이 대괄호 안에 나타납니다.
> - 언급했듯이 이 오류 및 경고 메시지 목록은 QA 검사용입니다. 이 목록은 발생할 수 있는 모든 빌드 오류 또는 경고를 포함하지 않습니다.
> - 일부 QA 검사는 기본적으로 비활성화되어 있으므로 이 목록에는 모든 가능한 QA 검사 오류 및 경고가 포함되지 않습니다.

## 9.2 오류 및 경고

### libexec 경로 문제 [libexec]

`<packagename>: <path> is using libexec please relocate to <libexecdir>`

지정된 패키지는 distro 구성이 `<libexecdir>`에 다른 경로를 사용할 때 `/usr/libexec`에 파일을 포함합니다. 기본적으로 `<libexecdir>`는 `$prefix/libexec`입니다. 그러나 이 기본값을 변경할 수 있습니다(예: `${libdir}`).

### 잘못된 RPATH [rpaths]

`package <packagename> contains bad RPATH <rpath> in file <file>`

레시피에서 생성된 지정된 바이너리는 TMPDIR과 같은 빌드 시스템 경로를 포함하는 동적 라이브러리 로드 경로(rpaths)를 포함하며, 이는 타겟에 대해 잘못되었으며 보안 문제가 될 수 있습니다.

do_compile 로그에서 링커에 전달되는 잘못된 `-rpath` 옵션을 확인하세요. 빌드 중인 소프트웨어에서 사용되는 빌드 시스템에 따라 빌드 내에서 rpath 사용을 완전히 비활성화하는 구성 옵션이 있을 수 있습니다.

### 불필요한 RPATH [useless-rpaths]

`<packagename>: <file> contains probably-redundant RPATH <rpath>`

레시피에서 생성된 지정된 바이너리는 표준 시스템에서 기본적으로 링커가 검색하는 경로(예: `/lib` 및 `/usr/lib`)를 포함하는 동적 라이브러리 로드 경로(rpaths)를 포함합니다. 이러한 경로는 손상을 일으키지 않지만 공간을 낭비하고 불필요합니다. 빌드 중인 소프트웨어에서 사용되는 빌드 시스템에 따라 빌드 내에서 rpath 사용을 완전히 비활성화하는 구성 옵션이 있을 수 있습니다.

### 파일 레벨 의존성 누락 [file-rdeps]

`<packagename> requires <files>, but no providers in its RDEPENDS`

지정된 패키지에서 지정된 파일에 대한 파일 레벨 의존성이 식별되었지만 RDEPENDS에 명시적인 해당 항목이 없습니다. 특정 파일이 런타임에 필요한 경우 RDEPENDS를 레시피에 선언하여 이들을 제공하는 패키지가 빌드되도록 해야 합니다.

### 빌드 의존성 누락 [build-deps]

`<packagename1> rdepends on <packagename2>, but it isn't a build dependency?`

두 지정된 패키지 간에 런타임 의존성이 있지만 OpenEmbedded 빌드 시스템이 해당 의존성을 충족하도록 보장할 수 있도록 하는 레시피 내 명시적인 것이 없습니다. 이 조건은 일반적으로 RDEPENDS 값이 업전 추가되기보다는 패키징 단계에서 추가될 때 트리거되며, 일반적으로 패키지의 내용을 기반으로 자동입니다. 대부분의 경우 의존성에 대한 명시적 RDEPENDS를 추가하도록 레시피를 변경해야 합니다.

### 개발 심볼릭 링크 파일 위치 오류 [dev-so]

`non -dev/-dbg/nativesdk- package contains symlink .so: <packagename> path '<path>'`

심볼릭 링크 `.so` 파일은 개발용입니다. 따라서 `-dev` 패키지로 이동해야 합니다. 이 상황은 `*.so*` 대신 `*.so.*`를 비개발 패키지에 추가할 때 발생할 수 있습니다. FILES(그리고 PACKAGES)를 변경하여 지정된 `.so` 파일이 적절한 `-dev` 패키지로 이동하도록 하세요.

### 정적 라이브러리 위치 오류 [staticdev]

`non -staticdev package contains static .a library: <packagename> path '<path>'`

정적 `.a` 라이브러리 파일은 `-staticdev` 패키지로 이동해야 합니다. FILES(그리고 PACKAGES)를 변경하여 지정된 `.a` 파일이 적절한 `-staticdev` 패키지로 이동하도록 하세요.

### 라이브러리 디렉토리 오류 [libdir]

`<packagename>: found library in wrong location`

지정된 파일이 잘못된(아마도 하드코딩된) 설치 경로로 설치되었을 수 있습니다. 예를 들어 이 테스트는 `${base_libdir}`이 "lib32"일 때 `/lib/bar.so`를 설치하는 레시피를 포착합니다. 또 다른 예는 `${libdir}`이 "/usr/lib"일 때 레시피가 `/usr/lib64/foo.so`를 설치하는 경우입니다. 거짓 양성이 가끔 존재합니다. 이러한 경우 패키지의 INSANE_SKIP에 "libdir"을 추가하세요.

### 디버그 디렉토리 오류 [debug-files]

`non debug package contains .debug directory: <packagename> path <path>`

지정된 패키지는 `-dbg` 패키지가 아닌 것에는 표시되지 않아야 하는 `.debug` 디렉토리를 포함합니다. 이 상황은 `.debug` 디렉토리를 포함하는 경로를 추가하지만 `.debug` 디렉토리를 명시적으로 `-dbg` 패키지에 추가하지 않을 때 발생할 수 있습니다. 이 경우 `.debug` 디렉토리를 명시적으로 `FILES:${PN}-dbg`에 추가하세요. FILES에 대한 추가 정보는 FILES를 참조하세요.

### 빈 디렉토리에 파일 설치 [empty-dirs]

`<packagename> installs files in <path>, but it is expected to be empty`

지정된 패키지는 일반적으로 비어 있어야 하는 디렉토리(예: `/tmp`)에 파일을 설치하고 있습니다. 이러한 파일은 다른 위치에 더 적절하게 설치되거나 일반적으로 do_install 작업/함수를 업데이트하여 전혀 설치되지 않을 수 있습니다.

### 아키텍처 불일치 [arch]

`Architecture did not match (<file_arch>, expected <machine_arch>) in <file>`

기본적으로 OpenEmbedded 빌드 시스템은 실행 가능 및 연결 가능 형식(ELF) 유형, 비트 크기 및 모든 바이너리의 엔디언을 확인하여 타겟 아키텍처와 일치하는지 확인합니다. 바이너리가 유형과 일치하지 않으면 이 테스트가 실패하므로 호환되지 않을 수 있습니다. 이 테스트는 잘못된 컴파일러 또는 컴파일러 옵션이 사용되었음을 나타낼 수 있습니다. 때로는 부트로더와 같은 소프트웨어가 이 검사를 우회해야 할 수도 있습니다. 오류를 받는 파일이 타겟 운영 체제 내에서 실행되지 않거나 장치 내의 별도 프로세서에서 실행되도록 의도된 펌웨어인 경우 패키지의 INSANE_SKIP에 "arch"를 추가할 수 있습니다. 또 다른 옵션은 do_compile 로그를 확인하고 사용되는 컴파일러 옵션이 올바른지 확인하는 것입니다.

### 비트 크기 불일치 [arch]

`Bit size did not match (<file_bits>, expected <machine_bits>) in <file>`

기본적으로 OpenEmbedded 빌드 시스템은 실행 가능 및 연결 가능 형식(ELF) 유형, 비트 크기 및 모든 바이너리의 엔디언을 확인하여 타겟 아키텍처와 일치하는지 확인합니다. 바이너리가 유형과 일치하지 않으면 이 테스트가 실패하므로 호환되지 않을 수 있습니다. 이 테스트는 잘못된 컴파일러 또는 컴파일러 옵션이 사용되었음을 나타낼 수 있습니다. 때로는 부트로더와 같은 소프트웨어가 이 검사를 우회해야 할 수도 있습니다. 오류를 받는 파일이 타겟 운영 체제 내에서 실행되지 않거나 장치 내의 별도 프로세서에서 실행되도록 의도된 펌웨어인 경우 패키지의 INSANE_SKIP에 "arch"를 추가할 수 있습니다.

### 엔디언 불일치 [arch]

`Endianness did not match (<file_endianness>, expected <machine_endianness>) in <file>`

기본적으로 OpenEmbedded 빌드 시스템은 실행 가능 및 연결 가능 형식(ELF) 유형, 비트 크기 및 모든 바이너리의 엔디언을 확인하여 타겟 아키텍처와 일치하는지 확인합니다. 바이너리가 유형과 일치하지 않으면 이 테스트가 실패하므로 호환되지 않을 수 있습니다. 이 테스트는 잘못된 컴파일러 또는 컴파일러 옵션이 사용되었음을 나타낼 수 있습니다. 때로는 부트로더와 같은 소프트웨어가 이 검사를 우회해야 할 수도 있습니다. 오류를 받는 파일이 타겟 운영 체제 내에서 실행되지 않거나 장치 내의 별도 프로세서에서 실행되도록 의도된 펌웨어인 경우 패키지의 INSANE_SKIP에 "arch"를 추가할 수 있습니다.

### 텍스트 재배치 [textrel]

`ELF binary '<file>' has relocations in .text`

지정된 ELF 바이너리는 `.text` 섹션에 재배치를 포함합니다. 이 상황은 런타임에서 성능 영향을 초래할 수 있습니다.

일반적으로 이 성능 문제를 해결하는 방법은 컴파일러 명령 줄 옵션에 "-fPIC" 또는 "-fpic"를 추가하는 것입니다. 예를 들어 CFLAGS를 읽는 소프트웨어가 있을 경우 레시피에 다음을 추가할 수 있습니다:

```
CFLAGS:append = " -fPIC "
```

런타임 텍스트 재배치에 대한 자세한 정보는 https://www.akkadia.org/drepper/textrelocs.html을 참조하세요.

### GNU_HASH 누락 [ldflags]

`File '<file>' in package '<package>' doesn't have GNU_HASH (didn't pass LDFLAGS?)`

이는 레시피를 빌드할 때 생성된 바이너리가 빌드 시스템에서 제공하는 LDFLAGS 옵션으로 연결되지 않았음을 나타냅니다. LDFLAGS 변수가 링커 명령으로 전달되고 있는지 확인하세요. 이 상황에 대한 일반적인 해결 방법은 다음과 같이 레시피 내 TARGET_CC_ARCH를 사용하여 LDFLAGS를 전달하는 것입니다:

```
TARGET_CC_ARCH += "${LDFLAGS}"
```

### Xorg 드라이버 ABI 의존성 [xorg-driver-abi]

`Package <packagename> contains Xorg driver (<driver>) but no xorg-abi- dependencies`

지정된 패키지는 Xorg 드라이버를 포함하지만 해당 ABI 패키지 의존성이 없습니다. xserver-xorg 레시피는 드라이버 ABI 이름을 제공합니다. 모든 드라이버는 빌드된 ABI 버전에 의존해야 합니다. `xorg-driver-input.inc` 또는 `xorg-driver-video.inc`를 포함하는 드라이버 레시피는 자동으로 이러한 버전을 가져옵니다. 따라서 바이너리 드라이버 레시피에만 명시적으로 의존성을 추가하면 됩니다.

### 정보 디렉토리 파일 [infodir]

`The /usr/share/info/dir file is not meant to be shipped in a particular package.`

`/usr/share/info/dir`은 패키지에 포함되면 안 됩니다. 다음 줄을 do_install 작업 또는 레시피의 `do_install:append`에 추가하세요:

```
rm ${D}${infodir}/dir
```

### TMPDIR을 가리키는 심볼릭 링크 [symlink-to-sysroot]

`Symlink <path> in <packagename> points to TMPDIR`

지정된 심볼릭 링크는 호스트의 TMPDIR을 가리킵니다. 이러한 심볼릭 링크는 호스트에서 작동합니다. 그러나 타겟에서 실행할 때는 명확하게 유효하지 않습니다. 상대 경로를 사용하도록 심볼릭 링크를 수정하거나 심볼릭 링크를 제거해야 합니다.

### .la 파일 경로 오류 [la]

`<file> failed sanity test (workdir) in path <path>`

지정된 `.la` 파일은 TMPDIR 경로를 포함합니다. 이러한 경로를 포함하는 모든 `.la` 파일은 `libtool`이 파일을 사용할 때 자동으로 올바른 sysroot 접두사를 추가하므로 잘못됩니다.

### .pc 파일 경로 오류 [pkgconfig]

`<file> failed sanity test (tmpdir) in path <path>`

지정된 `.pc` 파일은 TMPDIR/WORKDIR 경로를 포함합니다. 이러한 경로를 포함하는 모든 `.pc` 파일은 `pkg-config`가 파일에 접근할 때 자동으로 올바른 sysroot 접두사를 추가하므로 잘못됩니다.

### 디버그 패키지 의존성 [debug-deps]

`<packagename> rdepends on <debug_packagename>`

지정된 비dbg 패키지(이름이 `-dbg`로 끝나지 않는 패키지)와 `dbg` 패키지 간에 의존성이 있습니다. `dbg` 패키지는 디버그 심볼을 포함하며 여러 다른 방법으로 도입됩니다:

- `dbg-pkgs` IMAGE_FEATURES 값 사용
- IMAGE_INSTALL 사용
- 위의 방법 중 하나를 사용하여 도입된 다른 `dbg` 패키지의 의존성

의존성은 `dbg` 패키지가 포함해서는 안 되는 파일을 잘못 포함하고 있기 때문에(예: 비심볼릭 링크 `.so` 파일) 자동으로 추가되었을 수도 있고 수동으로 추가되었을 수도 있습니다(예: RDEPENDS에 추가).

### 개발 패키지 의존성 [dev-deps]

`<packagename> rdepends on <dev_packagename>`

지정된 비개발 패키지(이름이 `-dev`로 끝나지 않는 패키지)와 `dev` 패키지 간에 의존성이 있습니다. `dev` 패키지는 개발 헤더를 포함하며 일반적으로 여러 다른 방법으로 도입됩니다:

- `dev-pkgs` IMAGE_FEATURES 값 사용
- IMAGE_INSTALL 사용
- 위의 방법 중 하나를 사용하여 도입된 다른 `dev` 패키지의 의존성

의존성은 `dev` 패키지가 포함해서는 안 되는 파일을 잘못 포함하고 있기 때문에(예: 비심볼릭 링크 `.so` 파일) 자동으로 추가되었을 수도 있고 수동으로 추가되었을 수도 있습니다(예: RDEPENDS에 추가).

### 버전 의존성 비교 오류 [dep-cmp]

`<var>:<packagename> is invalid: <comparison> (<value>) only comparisons <, =, >, <=, and >= are allowed`

의존성 변수(RDEPENDS, RRECOMMENDS, RSUGGESTS, RPROVIDES, RREPLACES, RCONFLICTS) 중 하나에 버전 의존성 관계를 추가할 때는 명명된 비교 연산자만 사용해야 합니다. 추가 중인 버전 의존성 값을 메시지에 나열된 것과 일치하도록 변경하세요.

### 크로스 컴파일 호스트 경로 - 컴파일 [compile-host-path]

`<recipename>: The compile log indicates that host include and/or library paths were used. Please check the log '<logfile>' for more information.`

do_compile 작업의 로그는 파일에 대해 호스트 경로를 검색했음을 나타내며, 이는 크로스 컴파일할 때 적절하지 않습니다. 지정된 로그 파일에서 "is unsafe for cross-compilation" 또는 "CROSS COMPILE Badness"를 찾으세요.

### 크로스 컴파일 호스트 경로 - 설치 [install-host-path]

`<recipename>: The install log indicates that host include and/or library paths were used. Please check the log '<logfile>' for more information.`

do_install 작업의 로그는 파일에 대해 호스트 경로를 검색했음을 나타내며, 이는 크로스 컴파일할 때 적절하지 않습니다. 지정된 로그 파일에서 "is unsafe for cross-compilation" 또는 "CROSS COMPILE Badness"를 찾으세요.

### Autoconf 안전 문제 [configure-unsafe]

`This autoconf log indicates errors, it looked at host include and/or library paths while determining system capabilities. Rerun configure task after fixing this.`

do_configure 작업의 로그는 파일에 대해 호스트 경로를 검색했음을 나타내며, 이는 크로스 컴파일할 때 적절하지 않습니다. 지정된 로그 파일에서 "is unsafe for cross-compilation" 또는 "CROSS COMPILE Badness"를 찾으세요.

### 패키지 이름 형식 [pkgname]

`<packagename> doesn't match the [a-z0-9.+-]+ regex`

OpenEmbedded 빌드 시스템(때로는 패키지 관리자 자체에 의해 시행됨) 내의 규칙은 패키지 이름을 모두 소문자로 요구하고 제한된 문자 집합을 허용하는 것입니다. 레시피 이름이 이와 일치하지 않거나 규칙을 준수하지 않는 패키지를 PACKAGES에 추가하면 이 오류가 발생합니다. 레시피의 이름을 바꾸거나 비준수 패키지 이름을 PACKAGES에 추가한 경우 패키지 이름을 적절하게 변경하세요.

### 구성 옵션 인식 불가 [unknown-configure-option]

`<recipe>: configure was passed unrecognized options: <options>`

구성 스크립트는 지정된 옵션을 인식하지 못한다고 보고합니다. 이 상황은 옵션이 이전에 유효했지만 구성 스크립트에서 제거되었기 때문일 수 있습니다. 또는 옵션이 추가될 때 실수가 있었고 대신 사용해야 할 다른 옵션이 있을 수 있습니다. 확실하지 않으면 업스트림 빌드 설명서, `./configure --help` 출력 및 업스트림 변경 로그 또는 릴리스 노트를 참조하세요. 적절한 변경 사항을 파악한 후 EXTRA_OECONF, PACKAGECONFIG_CONFARGS 또는 개별 PACKAGECONFIG 옵션 값을 적절하게 업데이트할 수 있습니다.

### PN 오버라이드 [pn-overrides]

`Recipe <recipefile> has PN of "<recipename>" which is in OVERRIDES, this can result in unexpected behavior.`

지정된 레시피는 OVERRIDES에 나타나는 이름(PN) 값을 가집니다. 레시피 이름이 OVERRIDES에 이미 있는 것과 일치하도록 지정되면(예: PN이 MACHINE 또는 DISTRO와 같음) 예상치 못한 결과가 발생할 수 있습니다. 예를 들어 `FILES:${PN}` 같은 할당이 예상과 다르게 작동할 수 있습니다.

### 패키지별 변수 확인 [pkgvarcheck]

`<recipefile>: Variable <variable> is set as not being package specific, please fix this.`

특정 변수(RDEPENDS, RRECOMMENDS, RSUGGESTS, RCONFLICTS, RPROVIDES, RREPLACES, FILES, `pkg_preinst`, `pkg_postinst`, `pkg_prerm`, `pkg_postrm`, ALLOW_EMPTY 등)는 패키지별로 지정되어야 합니다. 패키지 이름 오버라이드(예: `RDEPENDS:${PN} = "value"` 대신 `RDEPENDS = "value"`)를 사용하여 이를 달성할 수 있습니다. 이 오류가 발생하면 레시피 내 이 변수에 대한 할당을 수정하세요.

### DEPENDS에 PN 사용 [pkgvarcheck]

`recipe uses DEPENDS:${PN}, should use DEPENDS`

이 검사는 `DEPENDS:${PN}`을 설정하는 인스턴스를 찾으며, 이는 잘못되었습니다(DEPENDS는 레시피 전체 변수이므로 특정 패키지에 대해 지정하는 것은 올바르지 않으며 그러한 할당이 실제로 작동하지 않습니다). 대신 DEPENDS를 설정하세요.

### 이미 제거된 바이너리 [already-stripped]

`File '<file>' from <recipename> was already stripped, this will prevent future debugging!`

생성된 바이너리는 빌드 시스템이 디버그 심볼을 추출하기 전에 이미 제거되었습니다. 업스트림 소프트웨어 프로젝트가 출력 바이너리에 대해 기본적으로 디버그 심볼을 제거하는 것은 일반적입니다. 타겟에서 `-dbg` 패키지를 사용하여 디버깅이 작동하도록 하려면 이 제거를 비활성화해야 합니다.

빌드 중인 소프트웨어에서 사용되는 빌드 시스템에 따라 이 제거를 비활성화하는 것은 추가 구성 옵션을 지정하는 것만큼 쉬울 수 있습니다. 그렇지 않으면 제거를 비활성화하려면 빌드 스크립트에 패치를 적용해야 할 수도 있습니다. 후자의 경우 "strip" 또는 "STRIP"에 대한 참조를 찾거나 링커 명령 줄(컴파일러 명령 줄을 통해 "-Wl,"로 앞에 나오는 경우)에서 "-s" 또는 "-S" 명령 줄 옵션을 지정하십시오.

> **참고:** 여기서 제거를 비활성화한다고 해서 최종 패키지 바이너리가 제거되지 않는다는 의미는 아닙니다. OpenEmbedded 빌드 시스템이 디버그 심볼을 `-dbg` 패키지로 분리하면 바이너리에서 심볼을 제거합니다.

### PACKAGES 목록 중복 [packages-list]

`<packagename> is listed in PACKAGES multiple times, this leads to packaging errors.`

패키지 이름은 PACKAGES 변수에 한 번만 나타나야 합니다. 변수의 값에 이미 있는 PACKAGES에 패키지를 추가하려고 하면 이 오류가 발생할 수 있습니다.

### FILES 변수 '//' 문자 [files-invalid]

`FILES variable for package <packagename> contains '//' which is invalid. Attempting to fix this but you should correct the metadata.`

"//" 문자열은 Unix 경로에서 유효하지 않습니다. FILES 변수에서 이 문자열이 나타나는 모든 발생을 수정하여 단일 "/"만 있도록 하세요.

### 설치되었지만 배송되지 않은 파일 [installed-vs-shipped]

`<recipename>: Files/directories were installed but not shipped in any package`

파일이 do_install 작업 내에 설치되었지만 FILES 변수를 통해 어떤 패키지에도 포함되지 않았습니다. 패키지에 나타나지 않는 파일은 나중에 빌드 프로세스의 이미지에 존재할 수 없습니다. 다음 중 하나를 수행해야 합니다:

- 파일을 나타나길 원하는 패키지의 FILES에 추가합니다(예: `FILES:${PN}`).
- 파일이 어떤 패키지에도 필요하지 않으면 do_install 작업이 끝날 때 파일을 삭제합니다.

### 공유 라이브러리 제공자 변경 [shlib-provider]

`<oldpackage>-<oldpkgversion> was registered as shlib provider for <library>, changing it to <newpackage>-<newpkgversion> because it was built later`

이 메시지는 `<oldpackage>`과 `<newpackage>` 모두 지정된 공유 라이브러리를 제공함을 의미합니다. 레시피의 이름이 바뀐 경우 이 메시지가 예상될 수 있습니다. 그러나 그렇지 않은 경우 메시지는 라이브러리의 개인 버전이 공용 라이브러리의 제공자로 잘못 선택되고 있음을 나타낼 수 있습니다. 이 경우 라이브러리의 `.so` 파일 이름을 라이브러리의 개인 버전을 제공하는 레시피의 PRIVATE_LIBS에 추가해야 합니다.

### 미등재 패키지 라이선스 [unlisted-pkg-lics]

`LICENSE:<packagename> includes licenses (<licenses>) that are not listed in LICENSE`

레시피의 LICENSE는 이 레시피에서 생성된 모든 패키지의 모든 라이선스의 상위 집합이어야 합니다. 즉, `LICENSE:*`의 모든 라이선스는 LICENSE에도 나타나야 합니다.

### Gettext 상속 필요 [configure-gettext]

`AM_GNU_GETTEXT used but no inherit gettext`

레시피가 automake를 사용하는 것을 빌드하고 있으며 automake 파일에 `AM_GNU_GETTEXT` 지시문이 포함되어 있으면 이 검사는 빌드 중에 gettext를 사용 가능하도록 보장하는 `inherit gettext` 문이 없으면 실패합니다. 경고를 제거하려면 `inherit gettext`를 추가하세요.

### MIME 타입 상속 필요 [mime]

`package contains mime types but does not inherit mime: <packagename> path '<file>'`

지정된 패키지는 MIME 타입 파일(`${datadir}/mime/packages`의 `.xml` 파일)을 포함하지만 이러한 파일이 제대로 설치되도록 보장하는 mime 클래스를 상속하지 않습니다. 레시피에 `inherit mime`을 추가하거나 do_install 단계에서 필요하지 않으면 파일을 제거하세요.

### MIME XDG 상속 필요 [mime-xdg]

`package contains desktop file with key 'MimeType' but does not inhert mime-xdg: <packagename> path '<file>'`

지정된 패키지는 'MimeType' 키가 있는 .desktop 파일을 포함하지만 이를 활성화하기 위해 필요한 mime-xdg 클래스를 상속하지 않습니다. 레시피에 `inherit mime`을 추가하거나 do_install 단계에서 필요하지 않으면 파일을 제거하세요.

### 불안정한 GitHub 아카이브 [src-uri-bad]

`<recipename>: SRC_URI uses unstable GitHub archives`

GitHub는 "아카이브" 타르볼을 제공하지만 이들은 즉석에서 재생성될 수 있으며 파일의 서명이 반드시 SRC_URI의 체크섬과 일치할 필요는 없습니다. 향후 빌드 실패로 이어질 수 있습니다. 공식 릴리스 타르볼을 사용하거나 실제 git 저장소에서 해당 리비전을 가져오도록 전환하는 것이 좋습니다.

### SRC_URI에서 PN 사용 [src-uri-bad]

`SRC_URI uses PN not BPN`

SRC_URI의 일부가 레시피 이름을 참조해야 하는 경우 `${PN}` 대신 `${BPN}`을 사용해야 합니다. 후자는 BBCLASSEXTEND 또는 multilib을 사용할 때와 같은 동일한 레시피의 다른 변형에서 변경됩니다. 이 검사는 SRC_URI 값 내에서 `${PN}`에 대한 참조를 찾으면 실패하며 대신 `${BPN}`으로 변경하세요.

### 미처리 기능 검사 [unhandled-features-check]

`<recipename>: recipe doesn't inherit features_check`

이 검사는 features_check 클래스가 지원하는 변수(예: REQUIRED_DISTRO_FEATURES) 중 하나가 사용된 경우 레시피가 features_check를 상속하여 요구 사항이 실제로 작동하도록 보장합니다. 이 메시지가 표시되면 레시피에 `inherit features_check`를 추가하거나 변수에 대한 참조를 제거하세요.

### 업데이트 대안 상속 필요 [missing-update-alternatives]

`<recipename>: recipe defines ALTERNATIVE:<packagename> but doesn't inherit update-alternatives. This might fail during do_rootfs later!`

이 검사는 레시피가 ALTERNATIVE 변수를 설정하면 레시피가 update-alternatives를 상속하여 대안이 올바르게 설정되도록 보장합니다. 이 메시지가 표시되면 레시피에 `inherit update-alternatives`를 추가하거나 변수에 대한 참조를 제거하세요.

### Shebang 크기 초과 [shebang-size]

`<packagename>: <file> maximum shebang size exceeded, the maximum size is 128.`

이 검사는 스크립트의 shebang 줄(`#!` 첫 번째 줄)이 128자를 초과하지 않도록 보장합니다. 운영 체제에 따라 런타임에 오류를 발생시킬 수 있습니다. 이 메시지가 표시되면 지정된 스크립트에 런타임 문제를 방지하기 위해 더 짧은 shebang이 필요할 수 있습니다.

### perllocal.pod 파일 [perllocalpod]

`<packagename> contains perllocal.pod (<files>), should not be installed`

`perllocal.pod`은 로컬로 설치된 모듈의 인덱스 파일이므로 배포 패키지에서 설치해서는 안 됩니다. cpan\* 클래스는 이미 `NO_PERLLOCAL`을 설정하여 대부분의 Perl 레시피에서 이 파일이 생성되는 것을 방지하지만, 레시피가 `MakeMaker`를 직접 사용하는 경우 이를 올바르게 수행하지 않을 수 있습니다. 이 검사는 perllocal.pod가 어떤 패키지에도 없도록 보장하여 여러 패키지가 이 파일을 배송하고 함께 설치되면 패키지 충돌을 방지합니다.

### usrmerge 분배 기능 [usrmerge]

`<packagename> package is not obeying usrmerge distro feature. /<path> should be relocated to /usr.`

`usrmerge`가 DISTRO_FEATURES에 있으면 이 검사는 어떤 패키지도 루트(`/bin`, `/sbin`, `/lib`, `/lib64`) 디렉토리에 파일을 설치하지 않도록 보장합니다. 이 메시지가 표시되면 do_install 단계(또는 do_install이 호출하는 빌드 프로세스, 예: `make install`)가 하드코딩된 경로를 사용하고 있음을 나타내며 이를 위해 설정된 변수를 대신 사용하도록 변경해야 합니다(`bindir`, `sbindir` 등).

### 패치 Fuzz [patch-fuzz]

`Fuzz detected: <patch output>`

이 검사는 do_patch 작업 내에 패치를 적용할 때 "fuzz" 증거를 찾습니다. 패치 fuzz는 `patch` 도구가 패치를 적용하기 위해 일부 컨텍스트 줄을 무시할 때의 상황입니다.

#### Fuzz 경고 제거 방법

경고에서 설명한 대로 `devtool` 명령을 사용합니다. 먼저 소스를 devtool 워크스페이스에 언팩합니다:

```
devtool modify <recipe>
```

이는 모든 패치를 적용하고 워크스페이스에서 패치 컨텍스트가 업데이트된 새 커밋을 생성합니다.

그런 다음 레시피 레이어의 패치를 교체합니다:

```
devtool finish --force-patch-refresh <recipe> <layer_path>
```

패치 업데이트를 검토해야 합니다(가능하면 나란히 비교 도구를 사용하여):

1. 파일 내의 올바른 위치에 적용되고 있는지 확인합니다.
2. 중복 줄을 도입하거나 더 이상 필요하지 않은 다른 작업을 하지 않습니다.

이를 확인하려면 devtool의 워크스페이스에서 패치된 소스 코드를 검토할 수 있습니다(일반적으로 `<build_dir>/workspace/sources/<recipe>/`).

검토가 완료되면 패치 업데이트를 수정하는 레이어 커밋을 생성하고 게시할 수 있습니다. Devtool은 다른 것들도 패치에서 새로 고칠 수 있으며, 이들을 버릴 수 있습니다.

### 패치 업스트림 상태 [patch-status]

`Missing Upstream-Status in patch <patchfile> Please add according to <url>`

`Upstream-Status` 값은 지정된 패치 파일의 헤더에서 누락됩니다. 이 값은 패치가 업스트림으로 전송되었는지, 병합되었는지 등을 추적하기 위한 것입니다.

자세한 정보는 Yocto Project 및 OpenEmbedded 기여 가이드의 "Patch Upstream Status" 섹션을 참조하세요.

`Malformed Upstream-Status in patch <patchfile> Please correct according to <url>`

지정된 패치 파일의 헤더의 `Upstream-Status` 값이 유효하지 않습니다. 올바른 형식이어야 합니다. 위의 "Missing Upstream-Status" 항목을 참조하세요.

### 빌드 경로 포함 [buildpaths]

`File <filename> in package <packagename> contains reference to TMPDIR`

이 검사는 빌드 시스템 경로(TMPDIR 포함)가 출력 파일에 나타나지 않도록 보장하여 빌드 시스템 구성을 타겟에 유출하고 빌드 시스템 구성이 변경되면 출력이 변경되므로 이진 재현성을 방해합니다.

일반적으로 이러한 경로는 레시피에서 빌드되는 소프트웨어의 구성 또는 컴파일의 일부 메커니즘을 통해 출력에 들어갑니다. 이 문제를 해결하려면 감지된 경로가 출력에 어떻게 들어가는지 결정해야 합니다. 때로는 절대 경로 대신 상대 경로를 사용하도록 스크립트나 코드를 조정하거나 런타임 구성이나 환경 변수에서 경로를 선택해야 할 수 있습니다.

### 구현되지 않은 ptest [unimplemented-ptest]

`<tool> tests detected`

이 검사는 패키지의 소스가 일부 업스트림 제공 테스트를 포함하는 경우 감지합니다. 이 경우 이 레시피에 대해 ptest가 구현되었는지 확인합니다. Yocto Project 개발 작업 설명서의 "Testing Packages With ptest" 섹션을 참조하세요. ptest 섹션도 참조하세요.

### Virtual 컨텍스트 오류

`<variable> is set to <value> but the substring 'virtual/' holds no meaning in this context. It only works for build time dependencies, not runtime ones. It is suggested to use 'VIRTUAL-RUNTIME_' variables instead.`

`virtual/`은 런타임 컨텍스트(RPROVIDES 및 RDEPENDS)가 아니라 빌드 컨텍스트(PROVIDES 및 DEPENDS)에서 사용하기 위한 규칙입니다. 대신 후자를 위해 VIRTUAL-RUNTIME 변수를 사용하세요.

## 9.3 QA 검사 구성 및 비활성화

WARN_QA 및 ERROR_QA 변수를 각각 사용하여 특정 검사 실패가 경고 또는 오류 메시지를 발생시키도록 QA 검사를 전역적으로 구성할 수 있습니다. 또한 INSANE_SKIP을 사용하여 특정 레시피 내에서 검사를 비활성화할 수 있습니다. QA 검사로 작업하는 방법에 대한 정보는 insane 섹션을 참조하세요.

> **참고:** QA 검사는 패키지된 출력에서 실제 또는 잠재적 문제를 감지하기 위한 것입니다. 따라서 이 검사를 비활성화할 때 주의하세요.
