# Tasks (작업)

Tasks는 BitBake의 실행 단위입니다. 레시피(`.bb` 파일)는 소프트웨어 설정, 컴파일 및 패키징을 완료하기 위해 작업을 사용합니다. 이 장은 OpenEmbedded 빌드 시스템에 정의된 작업의 참조를 제공합니다.

## 6.1 일반 레시피 빌드 작업

다음 섹션에서는 레시피를 빌드하는 것과 관련된 일반 작업을 설명합니다. 작업 및 의존성에 대한 자세한 내용은 BitBake 사용자 설명서의 "Tasks" 및 "Dependencies" 섹션을 참조하세요.

### 6.1.1 `do_build`

모든 레시피에 대한 기본 작업입니다. 이 작업은 레시피를 빌드하기 위해 필요한 다른 모든 일반 작업에 따라 달라집니다.

### 6.1.2 `do_compile`

소스 코드를 컴파일합니다. 이 작업은 현재 작업 디렉토리를 `${B}`로 설정하여 실행됩니다.

이 작업의 기본 동작은 Makefile(`Makefile`, `makefile` 또는 `GNUmakefile`)이 발견되면 `oe_runmake` 함수를 실행하는 것입니다. 이러한 파일이 없으면 do_compile 작업은 아무것도 수행하지 않습니다.

### 6.1.3 `do_compile_ptest_base`

빌드 중인 소프트웨어에 포함된 런타임 테스트 스위트를 컴파일합니다.

### 6.1.4 `do_configure`

빌드되는 소프트웨어에 대한 빌드 시간 및 구성 옵션을 활성화하고 비활성화하여 소스를 구성합니다. 작업은 현재 작업 디렉토리를 `${B}`로 설정하여 실행됩니다.

이 작업의 기본 동작은 Makefile(`Makefile`, `makefile` 또는 `GNUmakefile`)이 발견되고 `CLEANBROKEN`이 "1"로 설정되지 않은 경우 `oe_runmake clean`을 실행하는 것입니다. 이러한 파일이 없거나 `CLEANBROKEN` 변수가 "1"로 설정되면 do_configure 작업은 아무것도 수행하지 않습니다.

### 6.1.5 `do_configure_ptest_base`

빌드 중인 소프트웨어에 포함된 런타임 테스트 스위트를 구성합니다.

### 6.1.6 `do_deploy`

`${DEPLOY_DIR_IMAGE}`에 배포할 출력 파일을 씁니다. 작업은 현재 작업 디렉토리를 `${B}`로 설정하여 실행됩니다.

이 작업을 구현하는 레시피는 `deploy` 클래스를 상속받아야 하고 출력을 `${DEPLOYDIR}`에 써야 합니다. 이는 `${DEPLOY_DIR}`과 혼동되어서는 안 됩니다. `deploy` 클래스는 do_deploy를 공유 상태(sstate) 작업으로 설정하여 sstate 사용을 통해 가속될 수 있습니다. sstate 메커니즘은 `${DEPLOYDIR}`에서 `${DEPLOY_DIR_IMAGE}`로의 출력 복사를 처리합니다.

> **참고:** 이렇게 하면 sstate 메커니즘이 오작동하므로 `${DEPLOY_DIR_IMAGE}`에 출력을 직접 쓰지 마세요.

do_deploy 작업은 기본적으로 작업으로 추가되지 않으므로 수동으로 추가해야 합니다. do_compile 후에 작업을 실행하려면 다음을 수행하여 추가할 수 있습니다:

```
addtask deploy after do_compile
```

다른 작업 후에 do_deploy를 추가하는 것도 동일한 방식으로 작동합니다.

> **참고:** `addtask` 명령에 `before do_build`를 추가할 필요는 없습니다(무해하지만), `base` 클래스에는 다음이 포함되어 있기 때문입니다:
>
> ```
> do_build[recrdeptask] += "do_deploy"
> ```

do_deploy 작업이 다시 실행되면 이전 출력이 제거됩니다(즉, "정리됨").

### 6.1.7 `do_fetch`

소스 코드를 가져옵니다. 이 작업은 `SRC_URI` 변수 및 인수의 접두사를 사용하여 올바른 수집기 모듈을 결정합니다.

### 6.1.8 `do_image`

이미지 생성 프로세스를 시작합니다. do_image 작업은 OpenEmbedded 빌드 시스템이 do_rootfs 작업을 실행한 후 실행되며, 이 작업 중에 패키지가 이미지에 설치하기 위해 식별되고 루트 파일시스템이 사후 처리와 함께 생성됩니다.

do*image 작업은 `IMAGE_PREPROCESS_COMMAND`를 통해 이미지에 대한 사전 처리를 수행하고 필요에 따라 do_image*\* 작업을 동적으로 생성합니다.

### 6.1.9 `do_image_complete`

이미지 생성 프로세스를 완료합니다. do*image_complete 작업은 OpenEmbedded 빌드 시스템이 do_image 작업을 실행한 후 실행되며, 이 작업 중에 이미지 사전 처리가 발생하고 동적으로 생성된 do_image*\* 작업을 통해 이미지가 생성됩니다.

do_image_complete 작업은 `IMAGE_POSTPROCESS_COMMAND`를 통해 이미지에 대한 사후 처리를 수행합니다.

### 6.1.10 `do_install`

패키지될 파일을 보류 영역 `${D}`로 복사합니다. 이 작업은 현재 작업 디렉토리를 `${B}`(컴파일 디렉토리)로 설정하여 실행됩니다. do*install 작업 및 설치된 파일에 직접 또는 간접적으로 의존하는 다른 작업(예: do_package, do_package_write*\*, do_rootfs)은 fakeroot 아래에서 실행됩니다.

> **참고:** 파일을 설치할 때, 설치된 파일의 소유자 및 그룹 ID를 의도하지 않은 값으로 설정하지 않도록 주의하세요. 특히 재귀적 `cp` 명령을 사용할 때와 같은 일부 파일 복사 방법은 원본 파일의 UID 및/또는 GID를 보존할 수 있으며, 이는 일반적으로 원하는 것이 아닙니다. `host-user-contaminated` QA 검사는 잘못된 소유권을 가진 파일을 확인합니다.

파일 설치를 위한 안전한 방법은 다음을 포함합니다:

- `install` 유틸리티. 이 유틸리티는 선호되는 방법입니다.
- `--no-preserve=ownership` 옵션이 있는 `cp` 명령.
- `--no-same-owner` 옵션이 있는 `tar` 명령. 소스 디렉토리의 `meta/classes-recipe` 하위 디렉토리에서 `bin_package.bbclass` 파일을 참조하세요.

### 6.1.11 `do_install_ptest_base`

컴파일 디렉토리에서 런타임 테스트 스위트 파일을 보류 영역으로 복사합니다.

### 6.1.12 `do_package`

보류 영역 `${D}`의 콘텐츠를 분석하고 사용 가능한 패키지 및 파일을 기반으로 콘텐츠를 부분 집합으로 분할합니다. 이 작업은 `PACKAGES` 및 `FILES` 변수를 사용합니다.

do_package 작업은 do_packagedata 작업과 함께 중요한 패키지 메타데이터를 저장하기도 합니다.

### 6.1.13 `do_package_qa`

패키징된 파일에 대해 QA 검사를 실행합니다. 이러한 검사에 대한 자세한 정보는 `insane` 클래스를 참조하세요.

### 6.1.14 `do_package_write_deb`

Debian 패키지(즉, `*.deb` 파일)를 만들고 패키지 피드 영역의 `${DEPLOY_DIR_DEB}` 디렉토리에 배치합니다.

### 6.1.15 `do_package_write_ipk`

IPK 패키지(즉, `*.ipk` 파일)를 만들고 패키지 피드 영역의 `${DEPLOY_DIR_IPK}` 디렉토리에 배치합니다.

### 6.1.16 `do_package_write_rpm`

RPM 패키지(즉, `*.rpm` 파일)를 만들고 패키지 피드 영역의 `${DEPLOY_DIR_RPM}` 디렉토리에 배치합니다.

### 6.1.17 `do_packagedata`

do_package 작업으로 생성된 패키지 메타데이터를 `PKGDATA_DIR`에 저장하여 전역적으로 사용 가능하게 합니다.

### 6.1.18 `do_patch`

패치 파일을 찾아 소스 코드에 적용합니다.

소스 파일을 가져온 후 압축을 푼 후 빌드 시스템은 레시피의 `SRC_URI` 명령을 사용하여 패치 파일을 찾아 소스 코드에 적용합니다.

> **참고:** 빌드 시스템은 `FILESPATH` 변수를 사용하여 패치를 검색할 때 기본 디렉토리 세트를 결정합니다.

패치 파일은 기본적으로 레시피 파일을 포함하는 디렉토리의 하위 디렉토리에서 생성 및 유지되는 `*.patch` 및 `*.diff` 파일입니다.

`SRC_URI` 문에 "apply=yes" 매개변수를 사용하여 모든 파일을 패치 파일로 표시할 수 있습니다:

```
SRC_URI = " \
    git://path_to_repo/some_package \
    file://file;apply=yes \
    "
```

반대로, 파일 유형이 `.patch` 또는 `.diff`이지만 do_patch 작업이 패치 단계 중에 적용하지 않도록 제외하려면 `SRC_URI` 명령에서 "apply=no" 매개변수를 사용할 수 있습니다:

```
SRC_URI = " \
    git://path_to_repo/some_package \
    file://file1.patch \
    file://file2.patch;apply=no \
    "
```

앞의 예에서 `file1.patch`는 기본적으로 패치로 적용되는 반면 `file2.patch`는 적용되지 않습니다.

### 6.1.19 `do_populate_lic`

레시피의 라이선스 정보를 작성하며, 나중에 이미지를 구성할 때 수집됩니다.

### 6.1.20 `do_populate_sdk`

설치 가능한 SDK의 파일 및 디렉토리 구조를 만듭니다.

### 6.1.21 `do_populate_sdk_ext`

설치 가능한 확장 가능 SDK(eSDK)의 파일 및 디렉토리 구조를 만듭니다.

### 6.1.22 `do_populate_sysroot`

do_install 작업으로 설치된 파일의 부분 집합을 적절한 sysroot로 스테이징(복사)합니다. 다른 레시피에서 이러한 파일에 접근하는 방법에 대한 정보는 `STAGING_DIR*` 변수를 참조하세요. 빌드 시간에 다른 레시피에서 필요하지 않을 가능성이 높은 디렉토리(예: `/etc`)는 기본적으로 복사되지 않습니다.

기본적으로 복사되는 디렉토리에 대한 정보는 `SYSROOT_DIRS*` 변수를 참조하세요. 빌드 시간에 다른 레시피에서 추가(또는 더 적은) 디렉토리를 사용 가능하게 해야 하는 경우 레시피 내에서 이 변수를 변경할 수 있습니다.

do_populate_sysroot 작업은 공유 상태(sstate) 작업입니다. 즉, 작업을 sstate 사용을 통해 가속할 수 있습니다. 작업을 다시 실행하면 이전 출력이 제거됩니다(즉, "정리됨").

### 6.1.23 `do_prepare_recipe_sysroot`

`DEPENDS`로 지정된 의존성에 따라 개별 레시피별 sysroot(`${WORKDIR}` 아래의 `recipe-sysroot` 및 `recipe-sysroot-native`)에 파일을 설치합니다.

### 6.1.24 `do_rm_work`

OpenEmbedded 빌드 시스템이 작업을 완료한 후 작업 파일을 제거합니다.

### 6.1.25 `do_unpack`

소스 코드를 `${UNPACKDIR}`이 가리키는 작업 디렉토리로 압축 해제합니다. 이 디렉토리를 지정하는 레거시 방법은 `S` 및 `WORKDIR` 변수를 통하는 것입니다.

## 6.2 수동으로 호출되는 작업

다음 작업은 일반적으로 수동으로 트리거됩니다(예: `bitbake -c` 명령행 옵션 사용):

### 6.2.1 `do_checkuri`

`SRC_URI` 값을 검증합니다.

### 6.2.2 `do_clean`

do_unpack 작업 이후로 대상에 대한 모든 출력 파일을 제거합니다(즉, do_unpack, do_configure, do_compile, do_install, do_package).

다음과 같이 BitBake를 사용하여 이 작업을 실행할 수 있습니다:

```bash
$ bitbake -c clean recipe
```

이 작업을 실행해도 sstate 캐시 파일이 제거되지 않습니다. 결과적으로, 변경 사항이 없고 정리 후 레시피가 다시 빌드되면 출력 파일이 단순히 sstate 캐시에서 복원됩니다. 레시피의 sstate 캐시 파일을 제거하려면 대신 do_cleansstate 작업을 사용해야 합니다(즉, `bitbake -c cleansstate recipe`).

### 6.2.3 `do_cleanall`

대상에 대한 모든 출력 파일, 공유 상태(sstate) 캐시 및 다운로드된 소스 파일(`DL_DIR`의 내용)을 제거합니다. 본질적으로 do_cleanall 작업은 do_cleansstate 작업과 동일하며 다운로드된 소스 파일의 추가 제거가 있습니다.

다음과 같이 BitBake를 사용하여 이 작업을 실행할 수 있습니다:

```bash
$ bitbake -c cleanall recipe
```

정상적인 시나리오에서는 do_cleanall 작업을 사용하면 안 됩니다. do_fetch 작업부터 시작하려면 대신 다음을 사용하세요:

```bash
$ bitbake -f -c fetch recipe
```

### 6.2.4 `do_cleansstate`

대상에 대한 모든 출력 파일 및 공유 상태(sstate) 캐시를 제거합니다. 본질적으로 do_cleansstate 작업은 do_clean 작업과 동일하며 공유 상태(sstate) 캐시의 추가 제거가 있습니다.

다음과 같이 BitBake를 사용하여 이 작업을 실행할 수 있습니다:

```bash
$ bitbake -c cleansstate recipe
```

do_cleansstate 작업을 실행하면 OpenEmbedded 빌드 시스템은 더 이상 sstate를 사용하지 않습니다. 결과적으로, 레시피를 처음부터 빌드하는 것이 보장됩니다.

> **참고:** 공유 `SSTATE_DIR`에서 do_cleansstate를 사용하는 것은 권장되지 않습니다. 왜냐하면 별도의 BitBake 인스턴스의 빌드 중에 오류를 트리거할 수 있기 때문입니다.

신뢰할 수 있고 선호되는 새 빌드를 강제하는 방법은 `bitbake -f`를 사용하는 것입니다.

### 6.2.5 `do_pydevshell`

대화형 Python 인터프리터를 사용하여 BitBake 빌드 환경과 상호 작용할 수 있는 셸을 시작합니다. 이 셸 내에서 BitBake 환경 내에서 데이터 저장소의 비트를 직접 검사 및 설정하고 함수를 실행할 수 있습니다.

### 6.2.6 `do_devshell`

개발, 디버깅 또는 둘 다를 위해 환경이 설정된 셸을 시작합니다.

### 6.2.7 `do_listtasks`

대상에 대해 정의된 모든 작업을 나열합니다.

### 6.2.8 `do_package_index`

패키지 피드 영역의 인덱스를 만들거나 업데이트합니다.

> **참고:** 이 작업은 이 섹션의 다른 작업처럼 `bitbake -c` 명령행 옵션으로 트리거되지 않습니다. 이 작업은 `package-index` 레시피에 특정하므로 `bitbake package-index`를 사용하여 실행합니다.

## 6.3 이미지 관련 작업

다음 작업은 이미지 레시피에 적용 가능합니다.

### 6.3.1 `do_bootimg`

부팅 가능한 라이브 이미지를 만듭니다. `IMAGE_FSTYPES` 변수를 참조하여 라이브 이미지 유형에 대한 추가 정보를 얻으세요.

### 6.3.2 `do_bundle_initramfs`

Initramfs 이미지와 커널을 합쳐 하나의 이미지를 형성합니다.

### 6.3.3 `do_rootfs`

이미지에 대한 루트 파일시스템(파일 및 디렉토리 구조)을 만듭니다.

### 6.3.4 `do_testimage`

이미지를 부팅하고 이미지 내에서 런타임 테스트를 수행합니다.

### 6.3.5 `do_testimage_auto`

이미지를 부팅하고 빌드된 후 즉시 이미지 내에서 런타임 테스트를 수행합니다. 이 작업은 `TESTIMAGE_AUTO`를 "1"로 설정할 때 활성화됩니다.

## 6.4 커널 관련 작업

다음 작업은 커널 레시피에 적용 가능합니다. 이러한 작업 중 일부(예: do_menuconfig 작업)는 BusyBox 레시피와 같이 Linux 커널 스타일 구성을 사용하는 레시피에도 적용 가능합니다.

### 6.4.1 `do_compile_kernelmodules`

커널 모듈을 빌드하는 단계를 실행합니다(필요한 경우). 커널을 빌드하는 것은 두 단계로 구성됩니다: 1) 커널(`vmlinux`)이 빌드되고, 2) 모듈이 빌드됩니다(즉, `make modules`).

### 6.4.2 `do_diffconfig`

사용자가 호출하면, 이 작업은 do_kernel_configme 작업으로 생성된 원본 구성과 사용자가 다른 방법(즉, do_kernel_menuconfig 사용)으로 수행한 변경 사항 사이의 차이를 포함하는 파일을 만듭니다. 차이 파일이 생성되면 차이만 포함하는 구성 조각을 만드는 데 사용할 수 있습니다. 다음과 같이 명령행에서 이 작업을 호출할 수 있습니다:

```bash
$ bitbake linux-yocto -c diffconfig
```

### 6.4.3 `do_kernel_checkout`

새로 압축 해제된 커널 소스를 OpenEmbedded 빌드 시스템이 작업할 수 있는 형태로 변환합니다. 커널 소스는 여러 가지 다른 방식으로 가져올 수 있으므로 do_kernel_checkout 작업은 후속 작업이 올바른 분기가 체크아웃된 커널의 깨끗한 작업 트리 복사본을 받도록 합니다.

### 6.4.4 `do_kernel_configcheck`

do_kernel_menuconfig 작업으로 생성된 구성을 검증합니다. do_kernel_configcheck 작업은 요청된 구성이 최종 `.config` 파일에 나타나지 않거나 하드웨어 구성 조각에서 정책 구성을 재정의할 때 경고를 생성합니다. 다음 명령을 사용하여 이 작업을 명시적으로 실행하고 출력을 볼 수 있습니다:

```bash
$ bitbake linux-yocto -c kernel_configcheck -f
```

### 6.4.5 `do_kernel_configme`

커널이 do_patch 작업으로 패치된 후, do_kernel_configme 작업은 모든 커널 구성 조각을 조합하고 병합하여 커널 구성 단계에 전달될 수 있는 병합된 구성을 생성합니다. 이는 사용자가 지정한 defconfig가 존재하면 적용되고 `--allnoconfig`와 같은 구성 모드가 적용되는 시간입니다.

### 6.4.6 `do_kernel_menuconfig`

linux-yocto 레시피를 빌드하는 데 사용되는 `.config` 파일을 조작하기 위해 사용자가 호출합니다. 이 작업은 Linux 커널 구성 도구를 시작하며, 이를 사용하여 커널 구성을 수정합니다.

> **참고:** 다음과 같이 명령행에서 이 도구를 호출할 수도 있습니다:
>
> ```bash
> $ bitbake linux-yocto -c menuconfig
> ```

### 6.4.7 `do_kernel_metadata`

`SRC_URI` 또는 Git 리포지토리에서 오는지 여부에 관계없이 주어진 커널 빌드에 필요한 모든 기능을 수집합니다. 수집 후 do_kernel_metadata 작업은 기능을 일련의 구성 조각 및 패치로 처리하며, 이를 나중에 do_patch 및 do_kernel_configme와 같은 후속 작업으로 적용할 수 있습니다.

### 6.4.8 `do_menuconfig`

커널에 대해 `make menuconfig`를 실행합니다.

### 6.4.9 `do_savedefconfig`

사용자가 호출하면, 기본 defconfig 대신 사용할 수 있는 defconfig 파일을 만듭니다. 저장된 defconfig에는 기본 defconfig와 사용자가 다른 방법(즉, do_kernel_menuconfig 작업)을 사용하여 수행한 변경 사항 간의 차이가 포함됩니다. 다음 명령을 사용하여 작업을 호출할 수 있습니다:

```bash
$ bitbake linux-yocto -c savedefconfig
```

### 6.4.10 `do_shared_workdir`

커널이 컴파일된 후 하지만 커널 모듈이 컴파일되기 전에, 이 작업은 모듈 빌드 및 커널 빌드에서 생성되는 파일이 필요한 파일을 공유 작업 디렉토리로 복사합니다. 이 복사가 성공적으로 복사되면 do_compile_kernelmodules 작업이 다음 빌드 단계에서 커널 모듈을 성공적으로 빌드할 수 있습니다.

### 6.4.11 `do_sizecheck`

커널이 빌드된 후, 이 작업은 제거된 커널 이미지의 크기를 `KERNEL_IMAGE_MAXSIZE`와 비교합니다. 해당 변수가 설정되고 제거된 커널의 크기가 해당 크기를 초과하면 커널 빌드가 그 효과에 대한 경고를 생성합니다.

### 6.4.12 `do_strip`

`KERNEL_IMAGE_STRIP_EXTRA_SECTIONS`이 정의되면, 이 작업은 해당 변수에 명명된 섹션을 `vmlinux`에서 제거합니다. 이 제거는 일반적으로 크기에 민감한 구성에서 `.comment` 섹션과 같은 불필요한 섹션을 제거하는 데 사용됩니다.

### 6.4.13 `do_validate_branches`

커널이 압축 해제된 후 하지만 패치되기 전에, 이 작업은 `SRCREV` 변수로 지정된 머신 및 메타데이터 분기가 지정된 분기에 실제로 존재하는지 확인합니다. 그렇지 않으면 `AUTOREV`를 사용하지 않는 경우 do_validate_branches 작업이 빌드 중에 실패합니다.
