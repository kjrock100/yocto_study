# 소스 디렉토리 구조

소스 디렉토리는 많은 파일, 디렉토리 및 하위 디렉토리로 구성되며, 이들의 위치와 내용을 이해하는 것은 Yocto Project를 효과적으로 사용하기 위한 핵심입니다. 이 장에서는 소스 디렉토리를 설명하고 이러한 파일 및 디렉토리에 대한 정보를 제공합니다.

개발 시스템에서 로컬 소스 디렉토리를 설정하는 방법에 대한 정보는 Yocto Project 개발 작업 설명서의 "Locating Yocto Project Source Files" 섹션을 참조하세요.

> **참고:** OpenEmbedded 빌드 시스템은 공백을 포함하는 파일 또는 디렉토리 이름을 지원하지 않습니다. 사용하는 소스 디렉토리에 이러한 유형의 이름이 없는지 확인하세요.

## 4.1 최상위 코어 구성 요소(Top-Level Core Components)

이 섹션에서는 소스 디렉토리의 최상위 구성 요소를 설명합니다.

### 4.1.1 `bitbake/`

이 디렉토리는 사용 편의성을 위해 BitBake의 사본을 포함합니다. 사본은 일반적으로 BitBake 프로젝트의 현재 안정적인 BitBake 릴리스와 일치합니다. 메타데이터 인터프리터인 BitBake는 Yocto Project 메타데이터를 읽고 해당 데이터에 의해 정의된 작업을 실행합니다. 실패는 일반적으로 메타데이터의 오류로 인해 발생하며 BitBake 자체의 오류가 아닙니다.

`bitbake` 명령을 실행하면 주요 BitBake 실행 파일(`bitbake/bin/` 디렉토리에 있음)이 시작됩니다. 환경 설정 스크립트를 소싱하면 (즉, oe-init-build-env), `scripts/` 및 `bitbake/bin/` 디렉토리(해당 순서)가 쉘의 `PATH` 환경 변수에 배치됩니다.

BitBake에 대한 자세한 정보는 BitBake 사용자 설명서를 참조하세요.

### 4.1.2 `build/`

이 디렉토리는 사용자 구성 파일 및 소스 트리가 출력과 결합되는 표준 구성에서 OpenEmbedded 빌드 시스템에서 생성된 출력을 포함합니다. Build Directory는 OpenEmbedded 빌드 환경 설정 스크립트(oe-init-build-env)를 소싱할 때 처음 생성됩니다.

소스 oe-init-build-env 스크립트를 소싱할 때 디렉토리 이름을 제공하여 출력 및 구성 파일을 소스 디렉토리와 별도의 디렉토리에 배치할 수도 있습니다. 로컬 소스 디렉토리 파일에서 출력을 분리하는 방법(일반적으로 "out of tree" 빌드로 설명됨)에 대한 정보는 "oe-init-build-env" 섹션을 참조하세요.

Build Directory의 내용에 대한 자세한 내용은 "The Build Directory — build/" 섹션을 참조하세요.

### 4.1.3 `documentation/`

이 디렉토리는 Yocto Project 문서의 소스뿐만 아니라 설명서의 PDF 및 HTML 버전을 생성할 수 있는 템플릿 및 도구를 보유합니다. 각 설명서는 자신의 하위 폴더에 포함됩니다. 예를 들어 이 참조 설명서의 파일은 `ref-manual/` 디렉토리에 있습니다.

### 4.1.4 `meta/`

이 디렉토리는 최소한의 기본 OpenEmbedded-Core 메타데이터를 포함합니다. 디렉토리는 엄격하게 에뮬레이션되는 타겟(`qemux86`, `qemuarm` 등)에 대한 레시피, 공통 클래스 및 머신 구성을 보유합니다.

### 4.1.5 `meta-poky/`

`meta/` 콘텐츠 위에 설계된 이 디렉토리는 Poky 참조 배포판을 정의하기에 충분한 메타데이터만 추가합니다.

### 4.1.6 `meta-yocto-bsp/`

이 디렉토리는 Yocto Project 참조 하드웨어 Board Support Packages (BSPs)를 포함합니다. BSP에 대한 자세한 정보는 Yocto Project Board Support Package Developer's Guide를 참조하세요.

### 4.1.7 `meta-selftest/`

이 디렉토리는 빌드 시스템의 동작을 검증하기 위해 OpenEmbedded selftests에서 사용하는 추가 레시피 및 추가 파일을 추가합니다. selftests를 실행하려는 경우가 아니면 이 레이어를 `bblayers.conf` 파일에 추가할 필요가 없습니다.

### 4.1.8 `meta-skeleton/`

이 디렉토리는 BSP 및 커널 개발을 위한 템플릿 레시피를 포함합니다.

### 4.1.9 `scripts/`

이 디렉토리는 Yocto Project 환경(예: QEMU 스크립트)에서 추가 기능을 구현하는 다양한 통합 스크립트를 포함합니다. oe-init-build-env 스크립트는 이 디렉토리를 쉘의 `PATH` 환경 변수에 앞에 배치합니다.

`scripts` 디렉토리는 `create-pull-request` 및 `send-pull-request`와 같이 Yocto Project에 다시 기여하는 데 도움이 되는 유용한 스크립트를 가지고 있습니다.

### 4.1.10 `oe-init-build-env`

이 스크립트는 OpenEmbedded 빌드 환경을 설정합니다. 쉘에서 `source` 명령으로 이 스크립트를 실행하면 `PATH`를 변경하고 현재 작업 디렉토리를 기반으로 다른 핵심 BitBake 변수를 설정합니다. BitBake 명령을 실행하기 전에 환경 설정 스크립트를 실행해야 합니다. 스크립트는 `scripts` 디렉토리 내의 다른 스크립트를 사용하여 대부분의 작업을 수행합니다.

이 스크립트를 실행하면 Yocto Project 환경이 설정되고, Build Directory가 생성되며, 작업 디렉토리가 Build Directory가 되고, 빌드할 수 있는 가능한 타겟 목록을 포함한 다음에 할 작업에 대한 간단한 제안이 제시됩니다. 예는 다음과 같습니다:

```bash
$ source oe-init-build-env

### Shell environment set up for builds. ###

You can now run 'bitbake <target>'

Common targets are:
    core-image-minimal
    core-image-sato
    meta-toolchain
    meta-ide-support

You can also run generated QEMU images with a command like 'runqemu qemux86-64'
```

`oe-init-build-env` 스크립트의 기본 출력은 소스 디렉토리 내의 `meta-poky` 디렉토리에 있는 `conf-summary.txt` 및 `conf-notes.txt` 파일에서 제공합니다. 사용자 정의 배포판을 설계하는 경우 배포판에서 정의한 타겟 목록과 같은 짧은 요약 및 상세한 사용 노트를 제공할 수 있는 이 구성 파일의 자신의 버전을 포함할 수 있습니다. 자세한 정보는 Yocto Project 개발 작업 설명서의 "Creating a Custom Template Configuration Directory" 섹션을 참조하세요.

기본적으로 Build Directory 인수 없이 이 스크립트를 실행하면 현재 작업 디렉토리에 `build/` 디렉토리가 생성됩니다. 스크립트를 소싱할 때 Build Directory 인수를 제공하면 선택한 Build Directory를 만들도록 OpenEmbedded 빌드 시스템에 지시합니다. 예를 들어 다음 명령은 소스 디렉토리 외부에 있는 `mybuilds/`라는 Build Directory를 생성합니다:

```bash
$ source oe-init-build-env ~/mybuilds
```

OpenEmbedded 빌드 시스템은 템플릿 구성 파일을 사용하며, 이들은 기본적으로 소스 디렉토리의 `meta-poky/conf/templates/default` 디렉토리에 있습니다. 자세한 정보는 Yocto Project 개발 작업 설명서의 "Creating a Custom Template Configuration Directory" 섹션을 참조하세요.

> **참고:** OpenEmbedded 빌드 시스템은 파일 또는 디렉토리 이름에 공백을 포함하는 것을 지원하지 않습니다. 파일 또는 디렉토리 이름에 공백이 포함된 소스 디렉토리에서 `oe-init-build-env` 스크립트를 실행하려고 하면 그러한 파일 또는 디렉토리가 없음을 나타내는 오류가 반환됩니다. 공백을 포함하는 이름이 없는 소스 디렉토리를 사용해야 합니다.

### 4.1.11 `LICENSE`, `README`, and `README.hardware`

이들은 표준 최상위 파일입니다.

## 4.2 Build Directory — `build/`

OpenEmbedded 빌드 시스템은 빌드 환경 설정 스크립트 oe-init-build-env를 실행할 때 Build Directory를 생성합니다. Build Directory를 설정 스크립트를 실행할 때 특정 이름을 지정하지 않으면 이름은 기본적으로 `build/`입니다.

후속 구문 분석 및 처리를 위해 Build Directory의 이름은 TOPDIR 변수를 통해 사용 가능합니다.

### 4.2.1 `build/buildhistory/`

OpenEmbedded 빌드 시스템은 buildhistory 클래스 파일을 통해 빌드 기록을 활성화할 때 이 디렉토리를 생성합니다. 디렉토리는 빌드 정보를 이미지, 패키지 및 SDK 하위 디렉토리로 구성합니다. 빌드 기록 기능에 대한 정보는 Yocto Project 개발 작업 설명서의 "Maintaining Build Output Quality" 섹션을 참조하세요.

### 4.2.2 `build/cache/`

이 디렉토리는 OpenEmbedded 빌드 시스템에서 사용하는 여러 내부 파일을 포함합니다. 이 디렉토리로의 경로는 PERSISTENT_DIR 변수로 정의됩니다.

또한 TMPDIR, SSTATE_DIR의 값, 호스트 배포판의 이름 및 버전과 같은 중요한 빌드 정보를 추적하는 텍스트 파일인 `sanity_info`를 포함합니다.

### 4.2.3 `build/conf/local.conf`

이 구성 파일은 빌드 환경에 대한 모든 로컬 사용자 구성을 포함합니다. `local.conf` 파일은 다양한 구성 옵션에 대한 설명서를 포함합니다. 여기에 설정된 모든 변수는 해당 변수가 파일 내에 하드 코딩되지 않는 한(예: '?=' 대신 '='을 사용하여) 환경의 다른 곳에 설정된 모든 변수를 재정의합니다. 일부 변수는 다양한 이유로 하드 코딩되어 있지만 그러한 변수는 비교적 드뭅니다.

최소한 이 파일을 편집하여 대상 MACHINE을 선택하고, 사용할 패키지 유형(PACKAGE_CLASSES)을 선택하고, 다운로드된 파일에 액세스할 위치(DL_DIR)를 선택해야 합니다.

빌드를 시작할 때 `local.conf`가 없으면 OpenEmbedded 빌드 시스템은 최상위 빌드 환경 설정 스크립트 oe-init-build-env를 소싱할 때 `local.conf.sample`에서 이를 생성합니다.

사용되는 소스 `local.conf.sample` 파일은 TEMPLATECONF 스크립트 변수에 따라 달라지며, Yocto Project 개발 환경에서 빌드할 때 기본값은 `meta-poky/conf/templates/default`이고 OpenEmbedded-Core 환경에서 빌드할 때 기본값은 `meta/conf/templates/default`입니다. 스크립트 변수가 `local.conf.sample` 파일의 소스를 가리키므로 이는 최상위 빌드 환경 설정 스크립트에서 변수를 설정하여 모든 레이어에서 빌드 환경을 구성할 수 있음을 의미합니다:

```bash
TEMPLATECONF=your_layer/conf/templates/your_template_name
```

빌드 프로세스가 샘플 파일을 가져온 후 `sed`를 사용하여 모든 `##OEROOT##` 값을 최종 `${OEROOT}` 값으로 대체합니다.

> **참고:** 소스 디렉토리에서 `scripts/oe-setup-builddir` 스크립트를 확인하여 TEMPLATECONF 변수가 어떻게 사용되는지 볼 수 있습니다. `meta-poky/conf/templates/default` 디렉토리에서 Yocto Project 버전의 `local.conf.sample` 파일을 찾을 수 있습니다.

### 4.2.4 `build/conf/bblayers.conf`

이 구성 파일은 BitBake에 의해 탐색(또는 보행)되는 디렉토리 트리인 레이어를 정의합니다. `bblayers.conf` 파일은 BBLAYERS 변수를 사용하여 BitBake이 찾으려고 하는 레이어를 나열합니다.

빌드를 시작할 때 `bblayers.conf`가 없으면 OpenEmbedded 빌드 시스템은 최상위 빌드 환경 설정 스크립트(oe-init-build-env)를 소싱할 때 `bblayers.conf.sample`에서 이를 생성합니다.

`local.conf` 파일과 마찬가지로 사용되는 소스 `bblayers.conf.sample` 파일은 TEMPLATECONF 스크립트 변수에 따라 달라지며, Yocto Project 개발 환경에서 빌드할 때 기본값은 `meta-poky/conf/templates/default`이고 OpenEmbedded-Core 환경에서 빌드할 때 기본값은 `meta/conf/templates/default`입니다. 스크립트 변수가 `bblayers.conf.sample` 파일의 소스를 가리키므로 최상위 빌드 환경 설정 스크립트에서 변수를 설정하여 모든 레이어에서 빌드를 기반으로 할 수 있습니다:

```bash
TEMPLATECONF=your_layer/conf/templates/your_template_name
```

빌드 프로세스가 샘플 파일을 가져온 후 `sed`를 사용하여 모든 `##OEROOT##` 값을 최종 `${OEROOT}` 값으로 대체합니다.

> **참고:** 소스 디렉토리에서 `scripts/oe-setup-builddir` 스크립트로 TEMPLATECONF 변수가 정의되는 방식을 볼 수 있습니다. `meta-poky/conf/templates/default` 디렉토리에서 Yocto Project 버전의 `bblayers.conf.sample` 파일을 찾을 수 있습니다.

### 4.2.5 `build/conf/bblock.conf`

이 구성 파일은 `bblock`에 의해 생성되며 `bblock`에 의해 잠긴 서명을 포함합니다. 기본적으로 존재하지 않으며 `bblock`의 첫 번째 호출 시 생성됩니다.

### 4.2.6 `build/conf/auto.conf`

이 파일은 bitbake-config-build와 같은 도구에 의해 자동으로 수정되는 구성 변수를 포함합니다. 이 파일은 수동으로 수정하면 안 됩니다.

### 4.2.7 `build/downloads/`

이 디렉토리는 다운로드된 업스트림 소스 타르볼을 포함합니다. 여러 빌드에 대해 디렉토리를 재사용하거나 디렉토리를 다른 위치로 이동할 수 있습니다. DL_DIR 변수를 통해 이 디렉토리의 위치를 제어할 수 있습니다.

### 4.2.8 `build/sstate-cache/`

이 디렉토리는 공유 상태 캐시를 포함합니다. 여러 빌드에 대해 디렉토리를 재사용하거나 디렉토리를 다른 위치로 이동할 수 있습니다. SSTATE_DIR 변수를 통해 이 디렉토리의 위치를 제어할 수 있습니다.

### 4.2.9 `build/tmp/`

OpenEmbedded 빌드 시스템은 빌드 시스템의 모든 출력에 대해 이 디렉토리를 생성하고 사용합니다. TMPDIR 변수는 이 디렉토리를 가리킵니다.

BitBake는 존재하지 않으면 이 디렉토리를 생성합니다. 마지막 수단으로 빌드를 정리하고 처음부터 시작하려면(다운로드 제외) `tmp` 디렉토리의 모든 것을 제거하거나 디렉토리를 완전히 제거할 수 있습니다. 그렇게 하면 `build/sstate-cache` 디렉토리도 완전히 제거해야 합니다.

#### 4.2.9.1 `build/tmp/buildstats/`

이 디렉토리는 buildstats 클래스에서 생성한 빌드 통계를 저장합니다.

#### 4.2.9.2 `build/tmp/cache/`

BitBake이 메타데이터(레시피 및 구성 파일)를 구문 분석할 때 향후 빌드를 빠르게 하기 위해 결과를 `build/tmp/cache/`에 캐시합니다. 결과는 머신 기준으로 저장됩니다.

후속 빌드 중에 BitBake는 각 레시피(예: 포함되거나 추가된 파일을 포함하여)를 확인하여 수정되었는지 확인합니다. 변경은 예를 들어 파일 수정 시간(mtime) 변경 및 파일 내용 해싱을 통해 감지할 수 있습니다. 파일에 대한 변경이 감지되지 않으면 캐시에 저장된 구문 분석 결과가 재사용됩니다. 파일이 변경되면 다시 구문 분석됩니다.

#### 4.2.9.3 `build/tmp/deploy/`

이 디렉토리는 OpenEmbedded 빌드 프로세스의 모든 "최종 결과" 출력을 포함합니다. DEPLOY_DIR 변수는 이 디렉토리를 가리킵니다. 배포 디렉토리의 내용에 대한 자세한 내용은 Yocto Project 개요 및 개념 설명서의 "Images" 및 "Application Development SDK" 섹션을 참조하세요.

##### 4.2.9.3.1 `build/tmp/deploy/deb/`

이 디렉토리는 빌드 프로세스에서 생성된 모든 `.deb` 패키지를 수신합니다. 패키지는 다양한 아키텍처 유형의 피드로 정렬됩니다.

##### 4.2.9.3.2 `build/tmp/deploy/rpm/`

이 디렉토리는 빌드 프로세스에서 생성된 모든 `.rpm` 패키지를 수신합니다. 패키지는 다양한 아키텍처 유형의 피드로 정렬됩니다.

##### 4.2.9.3.3 `build/tmp/deploy/ipk/`

이 디렉토리는 빌드 프로세스에서 생성된 `.ipk` 패키지를 수신합니다.

##### 4.2.9.3.4 `build/tmp/deploy/licenses/`

이 디렉토리는 패키지 라이선스 정보를 수신합니다. 예를 들어 디렉토리는 `bash`, `busybox`, `glibc`(및 기타 포함) 등에 대한 하위 디렉토리를 포함하며, 이들은 차례로 적절한 `COPYING` 라이선스 파일 및 기타 라이선싱 정보를 포함합니다. 라이선싱에 대한 정보는 Yocto Project 개발 작업 설명서의 "Maintaining Open Source License Compliance During Your Product's Lifecycle" 섹션을 참조하세요.

##### 4.2.9.3.5 `build/tmp/deploy/images/`

이 디렉토리는 빌드 프로세스의 기본 출력 객체(빌드 프로세스의 "생성된 아티팩트"로 생각함)로 채워지며, 부트로더 이미지, 커널, 루트 파일시스템 등을 포함합니다. 빌드 결과 이미지를 디바이스에 플래시하려면 여기서 필요한 구성 요소를 찾으세요.

이 디렉토리의 파일을 삭제할 때 주의하세요. 이 디렉토리에서 이전 이미지(예: `core-image-*`)를 안전하게 삭제할 수 있습니다. 그러나 커널(`*zImage*`, `*uImage*` 등), 부트로더 및 기타 보조 파일이 이미지 빌드 전에 여기에 배포될 수 있습니다. 이 파일들은 이미지에서 직접 생성되지 않으므로 삭제하면 이미지를 다시 빌드할 때 자동으로 다시 생성되지 않습니다.

실수로 파일을 삭제한 경우 다시 생성되도록 강제해야 합니다. 이를 위해서는 파일을 생성한 대상을 알아야 합니다. 예를 들어 이 명령은 커널 파일을 다시 빌드하고 다시 생성합니다:

```bash
$ bitbake -c clean virtual/kernel
$ bitbake virtual/kernel
```

##### 4.2.9.3.6 `build/tmp/deploy/sdk/`

OpenEmbedded 빌드 시스템은 이 디렉토리를 생성하여 실행 시 타겟 하드웨어와 일치하는 sysroot를 설치하는 도구 체인 설치 스크립트를 보유합니다. Yocto Project Application Development and the Extensible Software Development Kit (eSDK) 설명서의 "Building an SDK Installer" 섹션에서 이러한 설치 프로그램에 대해 자세히 알아볼 수 있습니다.

#### 4.2.9.4 `build/tmp/hosttools/`

OpenEmbedded 빌드 시스템은 이 디렉토리를 사용하여 작업 내에서 호출할 수 있는 호스트 구성 요소 중 일부에 대한 심볼릭 링크를 생성합니다. 이들은 빌드 호스트용 필수 패키지 섹션에 나열된 기본 구성 요소입니다. 이 구성 요소들은 또한 HOSTTOOLS 변수에 나열되어 있으며 호스트 오염을 방지하기 위해 이 목록으로 제한됩니다.

#### 4.2.9.5 `build/tmp/pkgdata/`

OpenEmbedded 빌드 시스템은 이 디렉토리를 사용하여 do_packagedata 작업 중에 생성된 패키지 메타데이터를 저장합니다. 이 디렉토리에 저장된 파일은 OpenEmbedded 빌드 시스템에서 생성된 각 출력 패키지에 대한 정보를 포함하며 "Viewing Package Information with oe-pkgdata-util"과 같은 빌드 시스템에 의해 다양한 방식으로 사용됩니다.

#### 4.2.9.6 `build/tmp/sstate-control/`

OpenEmbedded 빌드 시스템은 이 디렉토리를 공유 상태 매니페스트 파일에 사용합니다. 공유 상태 코드는 이 파일을 사용하여 각 sstate 작업에서 설치된 파일을 기록하므로 레시피를 정리하거나 최신 버전이 설치될 예정일 때 파일을 제거할 수 있습니다. 빌드 시스템은 또한 매니페스트를 사용하여 한 작업의 파일이 다른 작업의 파일을 덮어쓸 때를 감지하고 경고를 생성합니다.

#### 4.2.9.7 `build/tmp/sysroots-components/`

이 디렉토리는 do_prepare_recipe_sysroot 작업이 DEPENDS에 나열된 각 레시피의 레시피별 sysroot에 링크하거나 복사하는 sysroot 내용의 위치입니다. 이 디렉토리의 채우기는 공유 상태를 통해 처리되며 경로는 COMPONENTS_DIR 변수로 지정됩니다. 몇 가지 비정상적인 경우를 제외하고는 `sysroots-components` 디렉토리의 처리가 자동이어야 하며 레시피가 직접 `build/tmp/sysroots-components`를 참조해서는 안 됩니다.

#### 4.2.9.8 `build/tmp/sysroots/`

OpenEmbedded 빌드 시스템의 이전 버전은 머신당 전역 공유 sysroot와 네이티브 sysroot를 생성하는 데 사용되었습니다. Yocto Project의 2.3 버전 이후로 레시피별 WORKDIR 디렉토리에 sysroot이 있습니다. 따라서 `build/tmp/sysroots/` 디렉토리는 사용되지 않습니다.

> **참고:** `build/tmp/sysroots/` 디렉토리는 여전히 `bitbake build-sysroots` 명령을 사용하여 채워질 수 있으며 일부 경우에 호환성을 위해 사용할 수 있습니다. 그러나 일반적으로 이 디렉토리를 채우는 것은 권장되지 않습니다. 개별 레시피별 sysroot를 사용해야 합니다.

#### 4.2.9.9 `build/tmp/stamps/`

이 디렉토리는 어떤 작업이 실행되었는지 그리고 언제 실행되었는지 추적하기 위해 BitBake이 회계 목적으로 사용하는 정보를 보유합니다. 디렉토리는 아키텍처, 패키지 이름 및 버전으로 세분화됩니다. 예는 다음과 같습니다:

```
stamps/all-poky-linux/distcc-config/1.0-r0.do_build-2fdd....2do
```

디렉토리의 파일은 데이터가 비어 있지만 BitBake는 파일 이름과 타임스탬프를 추적 목적으로 사용합니다.

BitBake이 스탬프 파일을 사용하여 작업을 다시 실행해야 하는지 여부를 결정하는 방법에 대한 정보는 Yocto Project 개요 및 개념 설명서의 "Stamp Files and the Rerunning of Tasks" 섹션을 참조하세요.

#### 4.2.9.10 `build/tmp/log/`

이 디렉토리는 패키지의 WORKDIR을 사용하여 다르게 배치되지 않은 일반 로그를 포함합니다. 로그의 예는 `do_check_pkg` 또는 `do_distro_check` 작업의 출력입니다. 빌드를 실행하면 반드시 이 디렉토리가 생성되는 것은 아닙니다.

#### 4.2.9.11 `build/tmp/work/`

이 디렉토리는 BitBake에서 빌드한 패키지에 대한 아키텍처별 작업 하위 디렉토리를 포함합니다. 모든 작업은 적절한 작업 디렉토리에서 실행됩니다. 예를 들어 특정 패키지의 소스는 자신의 작업 디렉토리 내에서 언팩, 패치, 구성 및 컴파일됩니다. 작업 디렉토리 내에서 구성은 WORKDIR로 정의된 패키지 그룹 및 소스를 컴파일하는 버전을 기반으로 합니다.

일반적인 작업 디렉토리의 구조를 고려할 가치가 있습니다. 예를 들어, Yocto Project 내의 머신 `qemux86`에서 빌드한 `linux-yocto-kernel-3.0`을 고려하세요. 이 패키지의 경우 WORKDIR이라고 하는 `tmp/work/qemux86-poky-linux/linux-yocto/3.0+git1+<.....>` 작업 디렉토리가 생성됩니다. 이 디렉토리 내에서 소스는 `linux-qemux86-standard-build`로 언팩된 다음 Quilt에 의해 패치됩니다. (Yocto Project 개발 작업 설명서의 "Using Quilt in Your Workflow" 섹션을 참조하세요.)

`linux-qemux86-standard-build` 디렉토리 내에서 표준 Quilt 디렉토리 `linux-3.0/patches` 및 `linux-3.0/.pc`가 생성되고 표준 Quilt 명령을 사용할 수 있습니다.

WORKDIR 내에서 생성된 다른 디렉토리가 있습니다. 가장 중요한 디렉토리는 각 작업의 로그 파일(`log.do_*.pid`)과 BitBake이 각 작업(`run.do_*.pid`)에 대해 실행하는 스크립트를 포함하는 `WORKDIR/temp/`입니다. `WORKDIR/image/` 디렉토리는 "make install"이 출력을 배치한 다음 `WORKDIR/packages-split/` 내의 하위 패키지로 분할되는 곳입니다.

##### 4.2.9.11.1 `build/tmp/work/tunearch/recipename/version/`

레시피 작업 디렉토리 — `${WORKDIR}`.

앞의 "build/tmp/sysroots/" 섹션에서 설명한 대로 Yocto Project의 2.3 릴리스부터 OpenEmbedded 빌드 시스템은 자신의 작업 디렉토리(즉, WORKDIR)에서 각 레시피를 빌드합니다. 작업 디렉토리로의 경로는 주어진 빌드의 아키텍처(예: TUNE_PKGARCH, MACHINE_ARCH 또는 "allarch"), 레시피 이름 및 레시피 버전(즉, PE:PV-PR)을 사용하여 구성됩니다.

각 레시피 작업 디렉토리 내의 주요 하위 디렉토리는 다음과 같습니다:

- `${WORKDIR}/temp`: 이 레시피에 대해 실행된 각 작업의 로그 파일과 BitBake이 각 작업에 대해 실행하는 코드를 포함하는 "run" 파일 및 작업이 실행된 순서를 나열하는 `log.task_order` 파일을 포함합니다.
- `${WORKDIR}/image`: do_install 작업의 출력을 포함하며, 이는 해당 작업의 `${D}` 변수에 해당합니다.
- `${WORKDIR}/pseudo`: 레시피에 대해 pseudo 아래에서 실행된 모든 작업에 대한 pseudo 데이터베이스 및 로그를 포함합니다.
- `${WORKDIR}/sysroot-destdir`: do_populate_sysroot 작업의 출력을 포함합니다.
- `${WORKDIR}/package`: 출력이 개별 패키지로 분할되기 전에 do_package 작업의 출력을 포함합니다.
- `${WORKDIR}/packages-split`: 출력이 개별 패키지로 분할된 후 do_package 작업의 출력을 포함합니다. 레시피에서 생성한 각 개별 패키지에 대한 하위 디렉토리가 있습니다.
- `${WORKDIR}/recipe-sysroot`: 레시피의 타겟 의존성으로 채워지는 디렉토리입니다. 이 디렉토리는 타겟 파일시스템처럼 보이며 레시피가 링크해야 할 수도 있는 라이브러리(예: C 라이브러리)를 포함합니다.
- `${WORKDIR}/recipe-sysroot-native`: 레시피의 네이티브 의존성으로 채워지는 디렉토리입니다. 이 디렉토리는 레시피가 빌드하는 데 필요한 도구(예: 컴파일러, Autoconf, libtool 등)를 포함합니다.
- `${WORKDIR}/build`: 이 하위 디렉토리는 소스가 빌드 아티팩트와 분리된 빌드를 지원하는 레시피에만 적용됩니다. OpenEmbedded 빌드 시스템은 이 디렉토리를 별도의 빌드 디렉토리(즉, `${B}`)로 사용합니다.

#### 4.2.9.12 `build/tmp/work-shared/`

효율성을 위해 OpenEmbedded 빌드 시스템은 다른 레시피와 작업 디렉토리를 공유하는 레시피를 보유하기 위해 이 디렉토리를 생성하고 사용합니다. 예를 들어 `gcc` 및 그 변형(예: `gcc-cross`, `libgcc`, `gcc-runtime` 등)이나 kernel 클래스에서 커널 소스 코드 및 커널 빌드 아티팩트를 out-of-tree 커널 모듈 또는 기타 커널 종속 레시피에 사용 가능하게 하는 데 사용됩니다.

실제로 적은 수의 레시피만 `work-shared` 디렉토리를 사용합니다. 이 디렉토리는 표준 Sysroot 메커니즘과 공유된다면 많은 저장 공간을 차지하는 레시피에 특히 유용합니다.

## 4.3 메타데이터 — `meta/`

앞서 언급했듯이 메타데이터는 Yocto Project의 핵심입니다. 메타데이터에는 여러 가지 중요한 세분화가 있습니다:

### 4.3.1 `meta/classes*/`

이 디렉토리는 `*.bbclass` 파일을 포함합니다. 클래스 파일은 공통 코드를 추상화하여 여러 패키지에서 재사용할 수 있도록 합니다. 모든 패키지는 base 파일을 상속합니다. 다른 중요한 클래스의 예는 autotools*입니다. 이론적으로 Autotool이 활성화된 모든 패키지가 최소한의 노력으로 Yocto Project와 작동할 수 있습니다. 또 다른 예는 Linux 커널 작업에 대한 공통 코드 및 함수를 포함하는 kernel입니다. 이미지 생성 또는 패키징과 같은 함수도 image, rootfs* 및 package\*.bbclass와 같은 자신의 특정 클래스 파일을 가집니다.

클래스에 대한 참조 정보는 "Classes" 장을 참조하세요.

### 4.3.2 `meta/conf/`

이 디렉토리는 `bitbake.conf`에서 시작하는 핵심 구성 파일 집합을 포함하며 다른 모든 구성 파일이 포함됩니다. `bitbake.conf` 파일의 끝에 있는 포함 명령문을 참조하면 `local.conf`도 여기서 로드되는 것을 알 수 있습니다. `bitbake.conf`가 기본값을 설정하지만 (`local.conf`) 파일, 머신 파일 또는 배포 구성 파일을 사용하여 종종 이들을 재정의할 수 있습니다.

#### 4.3.2.1 `meta/conf/machine/`

이 디렉토리는 모든 머신 구성 파일을 포함합니다. `MACHINE = "qemux86"`을 설정하면 OpenEmbedded 빌드 시스템은 이 디렉토리에서 `qemux86.conf` 파일을 찾습니다. `include` 디렉토리는 여러 머신에 공통인 다양한 데이터를 포함합니다. 새 머신에 대한 지원을 Yocto Project에 추가하려면 이 디렉토리를 살펴보세요.

#### 4.3.2.2 `meta/conf/distro/`

이 디렉토리의 내용은 배포판별 구성을 제어합니다. Yocto Project의 경우 `defaultsetup.conf`가 여기의 주요 파일입니다. 이 디렉토리는 여기에서 구성된 응용 프로그램의 버전 및 SRCDATE 정의를 포함합니다. 대안 구성의 예는 `poky-bleeding.conf`일 수 있습니다. 이 파일은 주로 Poky에서 구성을 상속하지만.

#### 4.3.2.3 `meta/conf/machine-sdk/`

OpenEmbedded 빌드 시스템은 SDKMACHINE의 값에 해당하는 구성 파일에 대해 이 디렉토리를 검색합니다. 기본적으로 32비트 및 64비트 x86 파일이 일부 SDK 호스트를 지원하는 Yocto Project와 함께 제공됩니다. 그러나 다른 레이어 내의 이 하위 디렉토리에 추가 구성 파일을 추가하여 해당 지원을 다른 SDK 호스트로 확장할 수 있습니다.

### 4.3.3 `meta/files/`

이 디렉토리는 공통 라이선스 파일 및 빌드 시스템에서 사용되는 여러 텍스트 파일을 포함합니다. 텍스트 파일은 최소한의 디바이스 정보 및 알려진 권한이 있는 파일 및 디렉토리 목록을 포함합니다.

### 4.3.4 `meta/lib/`

이 디렉토리는 빌드 프로세스 중에 사용되는 OpenEmbedded Python 라이브러리 코드를 포함합니다. `meta/conf/local.conf`의 `addpylib` 지시문을 통해 활성화됩니다. 자세한 정보는 "Extending Python Library Code"를 참조하세요.

### 4.3.5 `meta/recipes-bsp/`

이 디렉토리는 특정 하드웨어 또는 하드웨어 구성 정보(예: "u-boot" 및 "grub")에 연결되는 모든 것을 포함합니다.

### 4.3.6 `meta/recipes-connectivity/`

이 디렉토리는 다른 디바이스와의 통신과 관련된 라이브러리 및 응용 프로그램을 포함합니다.

### 4.3.7 `meta/recipes-core/`

이 디렉토리는 일반적으로 사용되는 의존성을 포함한 기본 작동 Linux 이미지를 빌드하는 데 필요한 것을 포함합니다.

### 4.3.8 `meta/recipes-devtools/`

이 디렉토리는 주로 빌드 시스템에서 사용되는 도구를 포함합니다. 그러나 도구는 타겟에서도 사용할 수 있습니다.

### 4.3.9 `meta/recipes-extended/`

이 디렉토리는 핵심의 대안에 비해 기능을 추가하는 필수가 아닌 응용 프로그램을 포함합니다. 전체 도구 기능을 위해 이 디렉토리가 필요할 수 있습니다.

### 4.3.10 `meta/recipes-gnome/`

이 디렉토리는 GTK+ 응용 프로그램 프레임워크와 관련된 모든 것을 포함합니다.

### 4.3.11 `meta/recipes-graphics/`

이 디렉토리는 X 및 기타 그래픽 관련 시스템 라이브러리를 포함합니다.

### 4.3.12 `meta/recipes-kernel/`

이 디렉토리는 강한 커널 의존성을 가진 커널 및 일반 응용 프로그램과 라이브러리를 포함합니다.

### 4.3.13 `meta/recipes-multimedia/`

이 디렉토리는 오디오, 이미지 및 비디오에 대한 코덱 및 지원 유틸리티를 포함합니다.

### 4.3.14 `meta/recipes-rt/`

이 디렉토리는 `PREEMPT_RT` 커널을 사용 및 테스트하기 위한 패키지 및 이미지 레시피를 포함합니다.

### 4.3.15 `meta/recipes-sato/`

이 디렉토리는 Sato 데모/참조 UI/UX 및 관련 응용 프로그램과 구성 데이터를 포함합니다.

### 4.3.16 `meta/recipes-support/`

이 디렉토리는 다른 레시피에서 사용되는 레시피를 포함하지만 이미지에 직접 포함되지 않습니다(즉, 다른 레시피의 의존성).

### 4.3.17 `meta/site/`

이 디렉토리는 다양한 아키텍처에 대한 캐시된 결과 목록을 포함합니다. 특정 "autoconf" 테스트 결과는 크로스 컴파일할 때 테스트가 라이브 시스템에서 실행될 수 없기 때문에 결정할 수 없으므로 이 디렉토리의 정보가 다양한 아키텍처에 대해 "autoconf"로 전달됩니다.

### 4.3.18 `meta/recipes.txt`

이 파일은 `recipes-*`의 내용에 대한 설명입니다.
