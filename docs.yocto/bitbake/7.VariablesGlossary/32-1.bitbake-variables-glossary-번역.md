# 변수 용어집

이 장에서는 BitBake에서 사용되는 일반적인 변수들을 나열하고 각각의 변수에 대한 설명을 제공합니다.
기능 및 내용에 대한 개요.

## 메모

   다음은 여기에 나열된 변수와 관련된 몇 가지 사항입니다.
   어휘:

- 이 용어집에 나열된 변수는 BitBake에만 해당됩니다.
      따라서 설명은 해당 맥락에 한정됩니다.

- 또한 BitBake를 사용하는 다른 시스템에도 변수가 존재합니다(예: The).
      Yocto Project 및 OpenEmbedded와 같이 이름이 동일한 프로젝트들
      이 용어집에서 찾을 수 있습니다. 이러한 경우, 해당 변수들은 다음과 같습니다.
      시스템은 변수의 기능을 있는 그대로 확장합니다.
      이 용어집에 설명되어 있습니다.

## 용어집

   :정렬됨:

### `ASSUME_PROVIDED`

      레시피 이름(PN 값) 목록을 표시합니다. BitBake는 그렇지 않습니다.
      빌드를 시도하는 대신, BitBake는 이러한 레시피가 이미 생성되었다고 가정합니다.
      지어졌습니다.

      OpenEmbedded-Core에서 `ASSUME_PROVIDED`는 대부분 네이티브를 지정합니다.
      빌드해서는 안 되는 도구들입니다. 예를 들어 `git-native`가 있습니다.
      지정된 경우 호스트의 Git 바이너리를 사용할 수 있습니다.
      `git-native`를 빌드하는 대신에.

### `AUTOREV`

      이는 데이터 가져오기 중에 사용되는 특수 변수입니다. `SRCREV`가 다음과 같을 때
      이 변수의 값으로 설정되며, 이는 해당 버전의 최신 수정 버전입니다.
      관리형 소스 코드 저장소가 사용됩니다.
      다음과 같이 설정해야 합니다.

         SRCREV = "${AUTOREV}"

### `AZ_SAS`

      Azure Storage 공유 액세스 서명을 사용할 때
      :ref:`Azure Storage fetcher <bitbake-user-manual/bitbake-user-manual-fetching:fetchers>`
      이 변수는 페처가 인증에 사용할 수 있도록 정의할 수 있습니다.
      비공개 자료에 접근할 수 있게 됩니다.

         AZ_SAS = ""se=2021-01-01&sp=r&sv=2018-11-09&sr=c&skoid=<skoid>&sig=<서명>""

      자세한 내용은 Microsoft Azure Storage 설명서를 참조하세요.
      https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview

### `B`

      BitBake가 레시피 실행 중에 함수를 실행하는 디렉토리입니다.
      빌드 프로세스.

### `BB_ALLOWED_NETWORKS`

      페처가 허용할 수 있는 호스트 목록을 공백으로 구분하여 지정합니다.
      필요한 소스 코드를 얻기 위해 사용할 방법은 다음과 같습니다.
      이 변수와 관련된 고려 사항:

      - 이 호스트 목록은 다음과 같은 경우에만 사용됩니다.
         `BB_NO_NETWORK`가 설정되지 않았거나
         "0"으로 설정합니다.

      - 일치 검색 시 와일드카드 문자 "``*``"에 대한 지원이 제한적입니다.
         호스트 이름의 시작 부분에 대한 반대 의견이 존재합니다. 예를 들어,
         다음 설정은 ``git.gnu.org``, ``ftp.gnu.org``와 일치합니다.
         ``foo.git.gnu.org``. ::

            BB_ALLOWED_NETWORKS = "\*.gnu.org"

         .. 중요한::

            "``*``" 문자는 시작 부분에서만 사용할 수 있습니다.
            호스트 이름이어야 하며, 나머지 부분과 분리되어야 합니다.
            호스트 이름입니다. 다른 곳에서는 와일드카드 문자를 사용할 수 없습니다.
            이름의 위치 또는 앞부분과 결합
            이름.

            예를 들어, `*.foo.bar`는 지원되지만 `*aa.foo.bar`는 지원되지 않습니다.
            그렇지 않습니다.

      - 호스트 목록에 없는 미러는 건너뛰고 디버그 로그에 기록됩니다.

      - 호스트 목록에 없는 네트워크에 접근하려고 하면 오류가 발생합니다.

      `BB_ALLOWED_NETWORKS`를 함께 사용하면
      `PREMIRRORS`는 매우 유용합니다. 추가하면
      `PREMIRRORS`를 사용하여 소스 코드 결과를 표시하려면 호스트를 지정하세요.
      허용된 위치에서 가져오므로 오류 발생을 방지합니다.
      허용되지 않은 호스트가 있는 경우
      `SRC_URI` 문입니다. 이는 다음과 같은 이유 때문입니다.
      fetcher는 `SRC_URI`에 나열된 호스트를 사용하려고 시도하지 않습니다.
      `PREMIRRORS`에서 성공적으로 데이터를 가져왔습니다.

### `BB_BASEHASH_IGNORE_VARS`

      체크섬 및 종속성 데이터에서 제외되는 변수 목록입니다.
      따라서 제외된 변수는 변경되더라도 영향을 미치지 않습니다.
      체크섬 메커니즘. 일반적인 예로는 변수가 있습니다.
      빌드 경로입니다. BitBake의 출력은 그렇지 않아야 하지만 (대개는 그렇지 않습니다).
      빌드된 디렉터리에 따라 달라지지 않습니다.

### `BB_CACHEDIR`

      코드 파서 캐시 디렉터리를 지정합니다(``CACHE`와는 다릅니다).
      `PERSISTENT_DIR`도 같은 값으로 설정할 수 있습니다.
      원하는 경우). 기본값은 "${TOPDIR}/cache"입니다.

### `BB_CHECK_SSL_CERTS`

      SSL 인증서를 가져올 때 확인할지 여부를 지정합니다. 기본값은
      값이 ``1``이면 인증서 검사가 수행되지 않고, 값이 ``0``으로 설정된 경우에는 인증서 검사가 수행되지 않습니다.

### `BB_HASH_CODEPARSER_VALS`

      코드파서 캐시를 채울 때 사용할 변수 값을 지정합니다.
      이 기능은 특정 변수를 피하기 위해 더미 값을 설정하는 데 선택적으로 사용할 수 있습니다.
      코드파서 캐시가 파싱할 때마다 점점 커집니다. 일반적으로 변수는 다음과 같습니다.
      포함될 항목은 값이 중요하지 않은 경우입니다.
      코드파서 캐시가 사용됩니다(예: 변수 종속성을 계산할 때).
      (코드 조각.) 값은 따옴표 없이 공백으로 구분됩니다.
      예::

         BB_HASH_CODEPARSER_VALS = "T=/ WORKDIR=/ DATE=1234 TIME=1234"

### `BB_CONSOLELOG`

      BitBake 사용자 인터페이스의 로그 파일 경로를 지정합니다.
      빌드 중에 출력을 기록합니다.

### `BB_CURRENTTASK`

      현재 실행 중인 작업의 이름을 포함합니다. 이름에는 다음이 포함되지 않습니다.
      ``do_`` 접두사를 포함하세요.

### `BB_CURRENT_MC`

      현재 작업이 실행 중인 멀티구성의 이름을 포함합니다.
      이름은 멀티컨피규어 설정 파일(파일)에서 따왔습니다.
      ``mc1.conf`` 파일을 사용하면 이 변수가 ``mc1``과 같아집니다.

### `BB_DEFAULT_TASK`

      ``-c``와 같이 아무 작업도 지정되지 않은 경우 사용할 기본 작업입니다.
      명령줄 옵션). 지정된 작업 이름에는 다음이 포함되어서는 안 됩니다.
      ``do_`` 접두사.

### `BB_DEFAULT_UMASK`

      지정된 경우 작업에 적용할 기본 umask이며, 작업별로 특정되지 않은 경우에 적용됩니다.
      umask 플래그가 설정되었습니다.

### `BB_DEFER_BBCLASSES`

      이 변수에 나열된 클래스는 상속을 받습니다.
      `<ref-bitbake-user-manual-metadata-inherit>` 호출은 자동으로 승격됩니다.
      지연 상속으로 변경하려면 :ref:`inherit_defer`를 참조하세요.
      자세한 내용은 <ref-bitbake-user-manual-metadata-inherit-defer>`를 참조하세요.
      지연 상속.

      즉, `BB_DEFER_BBCLASSES`가 다음과 같이 설정된 경우::

         BB_DEFER_BBCLASSES = "foo"

      다음 진술::

         상속받은 foo

      자동으로 호출과 동일하게 됩니다.

         inherit_defer foo

### `BB_DISKMON_DIRS`

      빌드 중에 디스크 공간과 사용 가능한 inode를 모니터링하고 허용합니다.
      이러한 매개변수를 기반으로 빌드를 제어할 수 있습니다.

      디스크 공간 모니터링은 기본적으로 비활성화되어 있습니다. 이 설정을 변경하려면 다음을 참조하십시오.
      변수의 경우 다음 형식을 사용하십시오.

         BB_DISKMON_DIRS = "<action>,<dir>,<threshold> [...]"

         어디:

            <action>은 다음과 같습니다:
               HALT: 빌드가 중단될 경우 즉시 빌드를 중지합니다.
                          임계점이 무너졌다.
               작업 중지: 현재 작업 후 빌드를 중지합니다.
                          실행 중인 작업이 완료되었습니다.
                          임계점이 무너졌다.
               경고: 경고를 표시하되 계속 진행하십시오.
                          임계값이 돌파될 때 빌드됩니다.
                          이후 경고는 다음과 같이 발령됩니다.
                          정의됨
                          BB_DISKMON_WARNINTERVAL 변수,
                          정의되어야 할 사항입니다.

            <dir>은 다음과 같습니다:
               원하는 디렉토리를 선택하세요. 하나를 지정할 수도 있고,
               더 많은 디렉터리를 모니터링하려면 분리하십시오.
               공백으로 그룹화합니다. 두 디렉터리가 있는 경우
               같은 기기에서 첫 번째 디렉토리만
               모니터링되고 있습니다.

            <임계값>은 다음과 같습니다:
               최소 디스크 공간 확보 또는
               최소 사용 가능한 이노드 수, 또는
               둘 다. 최소 하나는 지정해야 합니다.
               둘 중 하나를 생략하거나, 단순히 값을 생략하면 됩니다.
               기가바이트(GB) 단위로 G, M, K를 사용하여 임계값을 지정하십시오.
               각각 메가바이트(MB)와 킬로바이트(KB)입니다. 만약 그렇다면
               G, M, 또는 K를 지정하지 않으면 Kbytes로 간주됩니다.
               기본값입니다. GB, MB 또는 KB를 사용하지 마십시오.

      다음은 몇 가지 예입니다.

         BB_DISKMON_DIRS = "HALT,${TMPDIR},1G,100K WARN,${SSTATE_DIR},1G,100K"
         BB_DISKMON_DIRS = "중지 작업,${TMPDIR},1G"
         BB_DISKMON_DIRS = "HALT,${TMPDIR},,100K"

      첫 번째 예시는 다음 사항도 함께 설정했을 경우에만 작동합니다.
      `BB_DISKMON_WARNINTERVAL`
      변수입니다. 이 예시는 빌드 시스템을 즉시 중단시킵니다.
      ``${TMPDIR}``의 디스크 공간이 1GB 미만으로 떨어지거나
      사용 가능한 여유 inode가 100KB 미만으로 떨어집니다. 두 개 때문입니다.
      디렉터리는 변수와 함께 제공되며, 빌드 시스템 또한 마찬가지입니다.
      ``${SSTATE_DIR}``의 디스크 공간이 부족할 경우 경고를 표시합니다.
      디렉토리 크기가 1GB 미만으로 떨어지거나 사용 가능한 inode 수가 감소합니다.
      100KB 미만입니다. 이후 경고는 다음과 같은 간격으로 표시됩니다.
      `BB_DISKMON_WARNINTERVAL` 변수에 의해 정의됩니다.

      두 번째 예시는 현재 실행 중인 모든 작업이 완료된 후 빌드를 중지합니다.
      ``${TMPDIR}``의 최소 디스크 공간이 확보되면 작업이 완료됩니다.
      디렉터리 용량이 1GB 미만으로 떨어졌습니다. 여유 공간에 대한 디스크 모니터링은 수행되지 않습니다.
      이 경우에는 이노드입니다.

      마지막 예시에서는 숫자가 특정 값에 도달하면 빌드가 즉시 중단됩니다.
      ``${TMPDIR}`` 디렉터리의 사용 가능한 inode가 100KB 미만으로 떨어졌습니다. 아니요.
      이 경우 디렉터리 자체에 대한 디스크 공간 모니터링이 수행됩니다.

### `BB_DISKMON_WARNINTERVAL`

      디스크 공간 및 사용 가능한 inode에 대한 경고 간격을 정의합니다.

      `BB_DISKMON_WARNINTERVAL` 변수를 사용하려면,
      또한 `BB_DISKMON_DIRS`를 사용해야 합니다.
      변수를 지정하고 해당 동작 방식을 "경고"로 정의합니다. 빌드 중에
      디스크 공간 또는 사용 가능한 디스크 수가 부족할 때마다 후속 경고가 발행됩니다.
      inode 수는 해당 간격만큼 더 감소합니다.

      `BB_DISKMON_WARNINTERVAL` 변수를 제공하지 않으면
      `BB_DISKMON_DIRS`를 "WARN" 액션과 함께 사용하십시오.
      모니터링 간격의 기본값은 다음과 같습니다.
      BB_DISKMON_WARNINTERVAL = "50M,5K"

      설정 파일에서 변수를 지정할 때는 다음을 사용하십시오.
      다음 형식::

         BB_DISKMON_WARNINTERVAL = "<디스크 공간 간격>,<디스크 inode 간격>"

         어디:

            <disk_space_interval>은 다음과 같습니다.
               기억의 간격은 다음 중 하나로 표현됩니다.
               G, M 또는 K는 각각 기가바이트(Gbytes), 메가바이트(Mbytes) 또는 킬로바이트(Kbytes)를 나타냅니다.
               각각 해당됩니다. GB, MB 또는 KB는 사용할 수 없습니다.

            <disk_inode_interval>은 다음과 같습니다.
               자유 이노드 간격은 다음 중 하나로 표현됩니다.
               G, M 또는 K는 각각 기가바이트(Gbytes), 메가바이트(Mbytes) 또는 킬로바이트(Kbytes)를 나타냅니다.
               각각 해당됩니다. GB, MB 또는 KB는 사용할 수 없습니다.

      다음은 예시입니다.

         BB_DISKMON_DIRS = "경고,${SSTATE_DIR},1G,100K"
         BB_DISKMON_WARNINTERVAL = "50M,5K"

      이러한 변수들로 인해 BitBake가 작동합니다.
      사용 가능한 디스크 공간이 부족해질 때마다 후속 경고를 표시합니다.
      50MB 감소하거나 사용 가능한 inode 수가 추가로 감소합니다.
      `${SSTATE_DIR}` 디렉터리에 5KB가 있습니다. 이후 경고가 표시됩니다.
      간격에 따라 해당 간격이 발생할 때마다 발생합니다.
      초기 경고값(즉, 1GB 및 100KB)을 초과했습니다.

### `BB_ENV_PASSTHROUGH`

      통과를 허용할 내부 변수 목록을 지정합니다.
      외부 환경의 값을 BitBake의 데이터 저장소로 가져옵니다. 값이
      이 변수가 지정되지 않았습니다(기본값).
      리스트가 사용됩니다: `BBPATH`, `BB_PRESERVE_ENV`,
      `BB_ENV_PASSTHROUGH` 및 `BB_ENV_PASSTHROUGH_ADDITIONS`.

      .. 메모::

         이 변수를 외부 환경에 설정해야 합니다.
         제대로 작동하려면.

### `BB_ENV_PASSTHROUGH_ADDITIONS`

      통과를 허용할 추가 변수 집합을 지정합니다.
      외부 환경을 BitBake의 데이터 저장소로 가져옵니다. 다음은 변수 목록입니다.
      내부 목록에서 최상위에 있습니다.
      `BB_ENV_PASSTHROUGH`.

      .. 메모::

         이 변수를 외부 환경에 설정해야 합니다.
         제대로 작동하려면.

### `BB_FETCH_PREMIRRORONLY`

      "1"로 설정하면 BitBake의 페처 모듈이 특정 조건 하에서만 검색합니다.
      파일에 대한 `PREMIRRORS`를 사용합니다. BitBake는 그렇지 않습니다.
      메인 `SRC_URI`를 검색하거나
      :용어:`거울`.

### `BB_FILENAME`

      현재 실행 중인 레시피의 파일 이름을 포함합니다.
      예를 들어, `do_fetch` 작업이 다음과 같은 위치에 있는 경우
      ``my-recipe.bb``가 실행 중입니다. `BB_FILENAME` 변수에는 다음 내용이 포함됩니다.
      "/foo/path/my-recipe.bb".

### `BB_GENERATE_MIRROR_TARBALLS`

      Git 메타데이터를 포함한 Git 저장소의 tarball을 생성합니다.
      `DL_DIR` 디렉토리에 배치해야 합니다. 누구든지
      소스 미러를 생성하려는 경우 이 변수를 활성화해야 합니다.

      성능상의 이유로 Git의 tarball을 생성하고 배치하는 것이 좋습니다.
      BitBake에서 저장소는 기본 동작이 아닙니다.

         BB_GENERATE_MIRROR_TARBALLS = "1"

### `BB_GENERATE_SHALLOW_TARBALLS`

      `BB_GIT_SHALLOW`도 설정된 경우 이 변수를 "1"로 설정합니다.
      "1"을 선택하면 bitbake는 git을 가져올 때 얕은 미러 tarball을 생성합니다.
      저장소. 얕은 미러에 포함된 커밋 수
      tarball은 `BB_GIT_SHALLOW_DEPTH`에 의해 제어됩니다.

      `BB_GIT_SHALLOW`와 `BB_GENERATE_MIRROR_TARBALLS`가 모두 다음과 같으면
      이 옵션을 활성화하면 Bitbake는 기본적으로 Git용으로 얕은 미러 tarball을 생성합니다.
      저장소. 이 별도의 변수는 얕은 tarball을 생성하기 위해 존재합니다.
      일반 미러링을 활성화하지 않고도 생성 기능을 활성화할 수 있습니다.
      원하지 않는 경우 생성되지 않습니다.

      사용 예시는 `BB_GIT_SHALLOW`를 참조하십시오.

### `BB_GIT_DEFAULT_DESTSUFFIX`

      Git fetcher의 기본 대상 디렉터리
      `<git-fetcher>`는 소스 코드를 압축 해제합니다. 이 변수가 설정되지 않으면,
      소스 코드는 "git"이라는 이름의 디렉터리에 압축 해제됩니다.

### `BB_GIT_SHALLOW`

      이 변수를 "1"로 설정하면 가져오기, 사용 및 지원이 활성화됩니다.
      `shallow git repositories <https://riptutorial.com/git/example/4584/shallow-clone>`_의 미러 tarball을 생성합니다.
      외부 `git-make-shallow <https://git.openembedded.org/bitbake/tree/bin/git-make-shallow>`_
      이 스크립트는 얕은 미러 tarball 생성에 사용됩니다.

      `BB_GIT_SHALLOW` 옵션이 활성화되면 bitbake는 얕은 쿼리를 시도합니다.
      미러 tarball. 얕은 미러 tarball을 가져올 수 없는 경우,
      전체 미러 tarball을 다운로드하여 사용해 보세요.

      이 설정은 처음에 완전한 복제본을 만드는 대신 얕은 복제본을 만듭니다.
      초기 복제 과정에서 전송되는 데이터 양이 크게 줄어듭니다.

      하지만 소스 수정 버전(참조: `SRCREV`)이 생성될 때마다
      다운로드 디렉토리 내의 캐시 여부와 관계없이 변경 사항이 발생합니다.
      (DL_DIR로 정의됨)이 정리되었는지 여부,
      데이터 전송량이 상당히 높을 수 있는데, 그 이유는 전적으로
      소스 버전 변경 시마다 새로운 얕은 클론이 필요합니다.

      시간이 지남에 따라 수많은 얕은 클론들이 누적적으로 전이될 수 있습니다.
      초기 전체 베어 클론과 동일한 양의 데이터입니다.
      이는 특히 대규모 저장소의 경우에 해당됩니다.

      이 설정 없이 생성된 기존 초기 전체 베어 클론,
      계속 사용될 것입니다.

      Git 오류 "서버에서 광고되지 않은 객체에 대한 요청을 허용하지 않습니다"가 발생하는 경우
      이 문제가 발생하면 초기 전체 베어 클론이 자동으로 가져와집니다.
      이는 Git 서버가 요청을 허용하지 않는 경우에 발생할 수 있습니다.
      또는 Git 클라이언트가 이 기능을 사용하는 데 문제가 있는 경우입니다.

      또한 `BB_GIT_SHALLOW_DEPTH`를 참조하십시오.
      `BB_GENERATE_SHALLOW_TARBALLS`.

      사용 예시:

         BB_GIT_SHALLOW ?= "1"

         # 최상위 커밋만 남겨두세요
         BB_GIT_SHALLOW_DEPTH ?= "1"

         # BB_GIT_SHALLOW와 둘 다 설정된 경우 기본적으로 활성화됩니다.
         # BB_GENERATE_MIRROR_TARBALLS가 활성화되었습니다
         BB_GENERATE_SHALLOW_TARBALLS ?= "1"

### `BB_GIT_SHALLOW_DEPTH`

      `BB_GENERATE_SHALLOW_TARBALLS`와 함께 사용될 때, 이 변수는 설정됩니다.
      생성된 얕은 미러 tarball에 포함할 커밋 수입니다.
      깊이가 1인 경우, `SRCREV`에 참조된 커밋만 해당됩니다.
      얕은 거울 타르볼에 포함되어 있습니다. 깊이를 늘리면 다음이 포함됩니다.
      커밋 기록을 거슬러 올라가면서 추가적인 상위 커밋을 확인합니다.

      이 변수가 설정되지 않은 경우, bitbake는 기본적으로 깊이 1을 사용합니다.
      얕은 미러 타르볼을 생성합니다.

      사용 예시는 `BB_GIT_SHALLOW`를 참조하십시오.

### `BB_GLOBAL_PYMODULES`

      전역 네임스페이스에 배치할 Python 모듈 목록을 지정합니다.
      이 설정은 핵심 레이어에서만 이루어져야 하며, 그 목적은 다음과 같습니다.
      매우 작은 목록이어야 하며, 일반적으로 ``os``와 ``sys``만 포함됩니다.
      `BB_GLOBAL_PYMODULES`는 첫 번째 실행 전에 설정되어야 합니다.
      ``addpylib`` 지시문.
      ":ref:`bitbake-user-manual/bitbake-user-manual-metadata:파이썬 라이브러리 코드 확장`"도 참조하세요.

### `BB_HASHCHECK_FUNCTION`

      "setscene" 부분에서 호출할 함수의 이름을 지정합니다.
      작업 실행 과정을 검증하여 작업 해시 목록의 유효성을 확인합니다.
      이 함수는 실행되어야 할 setscene 작업 목록을 반환합니다.
      실행되었습니다.

      코드 실행의 이 시점에서 목표는 다음과 같습니다.
      주어진 setscene 함수가 제대로 작동할지 여부를 신속하게 확인할 수 있습니다.
      setscene 함수 목록을 한 번에 확인하는 것이 더 쉽습니다.
      여러 개별 작업을 호출합니다. 반환되는 목록은 반드시 다음과 같을 필요는 없습니다.
      완전히 정확합니다. 주어진 장면 설정 작업은 나중에 실패할 수도 있습니다.
      하지만 반환되는 데이터가 정확할수록 효율성은 높아집니다.
      빌드될 것입니다.

### `BB_HASHCONFIG_IGNORE_VARS`

      기본 구성 체크섬에서 제외되는 변수 목록입니다.
      이는 캐시를 재사용할 수 있는지 여부를 판단하는 데 사용됩니다.

      BitBake가 메인 파일을 다시 파싱할지 여부를 결정하는 방법 중 하나는 다음과 같습니다.
      메타데이터는 데이터 저장소에 있는 변수들의 체크섬을 통해 얻어집니다.
      기본 구성 데이터입니다. 일반적으로 사용하는 변수들이 있습니다.
      재구문 분석 여부를 확인할 때 제외하고 싶으므로
      캐시를 재구축합니다. 예를 들어, 일반적으로 ``TIME``을 제외합니다.
      그리고 ``DATE``` 변수는 항상 변하기 때문입니다. 만약 당신이 그랬다면...
      그것들을 제외하지 않더라도 BitBake는 캐시를 재사용하지 않습니다.

### `BB_HASHSERVE`

      사용할 해시 등가 서버를 지정합니다.

      `auto`로 설정하면 BitBake는 자동으로 자체 서버를 시작합니다.
      UNIX 도메인 소켓을 통해 연결할 수 있습니다. 이 서버에 연결하는 것도 하나의 옵션입니다.
      `BB_HASHSERVE_UPSTREAM`을 설정하여 상위 서버로 전송할 수 있습니다.

      ``unix://path``로 설정하면 BitBake는 기존 서버에 연결합니다.
      UNIX 도메인 소켓을 통해 이용 가능한 해시 서버.

      `host:port`로 설정하면 BitBake는 해당 호스트의 원격 서버에 연결합니다.
      지정된 호스트입니다. 이를 통해 여러 클라이언트가 동일한 호스트를 공유할 수 있습니다.
      해시 등가 데이터.

      원격 서버는 다음을 통해 수동으로 시작할 수 있습니다.
      BitBake에서 제공하는 ``bin/bitbake-hashserv`` 스크립트,
      이 스크립트는 UNIX 도메인 소켓도 지원합니다. 또한 이 스크립트는 다음과 같은 기능을 제공합니다.
      서버를 읽기 전용 모드로 시작하여 수락을 방지합니다.
      공유 상태 캐시에 해당하는 등가 관계
      특정 고객에게만 제공됩니다.

### `BB_HASHSERVE_UPSTREAM`

      상위 해시 등가 서버를 지정합니다.

      이 선택적 설정은 로컬 해시 등가성이 필요한 경우에만 유용합니다.
      서버가 시작되었습니다(BB_HASHSERVE 설정이 `auto`로 변경됨).
      그리고 로컬 서버가 상위 서버에 쿼리하도록 하려면 어떻게 해야 할까요?
      해시 등가 데이터.

      사용 예시:

         BB_HASHSERVE_UPSTREAM = "hashserv.yoctoproject.org:8686"

### `BB_INVALIDCONF`

      `ConfigParsed` 이벤트와 함께 사용하여 트리거합니다.
      기본 메타데이터(즉, 모든 레시피)를 다시 분석합니다.
      `ConfigParsed` 이벤트는 재파싱을 트리거하도록 변수를 설정할 수 있습니다.
      이 기능을 사용할 때는 재귀 루프가 발생하지 않도록 주의해야 합니다.

### `BB_LOADFACTOR_MAX`

      이 값을 설정하면 BitBake가 시스템 부하를 확인합니다.
      새 작업을 실행하기 전에 평균 부하를 확인합니다. 평균 부하가 기준치를 초과하면 새 작업을 실행합니다.
      CPU 개수에 이 계수를 곱한 값만큼 새로운 작업이 시작되지 않습니다.
      실행 중인 작업이 없는 경우를 제외하고, "1.5"라는 값이 발견되었습니다.
      합리적으로 작동합니다. 이는 압력이 없는 시스템에 유용합니다.
      더욱 세분화된 규제가 활성화되었습니다. 압력 값은 다음과 같습니다.
      부하율보다 우선순위가 높습니다.

### `BB_LOGCONFIG`

      사용자 로깅 정보가 포함된 설정 파일의 이름을 지정합니다.
      구성. 참조하세요.
      :ref:`bitbake-user-manual/bitbake-user-manual-execution:logging`
      추가 정보

### `BB_LOGFMT`

      저장될 로그 파일의 이름을 지정합니다.
      ``${``\ `T`\ ``}``. 기본적으로 `BB_LOGFMT`
      변수가 정의되지 않았으며 로그 파일 이름은 다음을 사용하여 생성됩니다.
      다음 형식::

         로그.{작업}.{pid}

      로그 파일의 이름을 특정 이름으로 강제 지정하려면 이 설정을 사용하면 됩니다.
      설정 파일의 변수.

### `BB_MULTI_PROVIDER_ALLOWED`

      두 개의 파일을 빌드할 때 발생하는 BitBake 경고를 억제할 수 있습니다.
      동일한 결과를 제공하는 별도의 레시피.

      BitBake는 일반적으로 서로 다른 두 레시피를 빌드할 때 경고 메시지를 표시합니다.
      각각이 동일한 출력을 제공하는 경우입니다. 이러한 시나리오는 일반적으로 다음과 같습니다.
      사용자가 원하지 않는 것입니다. 하지만, 예외적인 경우도 존재합니다.
      특히 ``virtual/*`` 네임스페이스에서는 타당합니다. 사용할 수 있습니다.
      BitBake의 경고를 억제하기 위해 이 변수를 사용합니다.

      변수를 사용하려면 공급자 이름(예: 레시피 이름)을 나열하세요.
      ``virtual/kernel`` 등).

### `BB_NICE_LEVEL`

      BitBake를 특정 우선순위(예: nice 레벨)로 실행할 수 있도록 합니다.
      시스템 권한 설정으로 인해 BitBake의 우선순위가 낮아지는 경우가 많습니다.
      하지만 다시 제기하지 마십시오. 자세한 내용은 `BB_TASK_NICE_LEVEL`을 참조하십시오.
      추가 정보.

### `BB_NO_NETWORK`

      BitBake 페처 모듈에서 네트워크 접근을 비활성화합니다.
      접근이 비활성화되었습니다. 네트워크에 접근하려는 모든 명령은 차단됩니다.
      오류가 됩니다.

      네트워크 접근을 차단하는 것은 소스 미러를 테스트하는 데 유용합니다.
      인터넷에 연결되지 않은 상태에서 빌드를 실행하고, 운영 체제를 실행할 때
      특정 유형의 방화벽 환경에서.

### `BB_NUMBER_PARSE_THREADS`

      BitBake가 구문 분석 시 사용하는 스레드 수를 설정합니다. 기본값은 다음과 같습니다.
      스레드 수는 시스템의 코어 수와 같습니다.

### `BB_NUMBER_THREADS`

      BitBake가 동시에 실행할 수 있는 최대 작업 수
      시간이 걸립니다. 호스트 개발 시스템이 멀티 코어를 지원하는 경우, 좋은
      일반적으로 이 변수를 코어 수의 두 배로 설정하는 것이 좋습니다.

### `BB_ORIGENV`

      BitBake가 실행되었던 원래 외부 환경의 사본이 포함되어 있습니다.
      실행되었습니다. 복사본은 설정된 변수 값 이전에 생성됩니다.
      외부 환경에서 들어오는 신호는 BitBake로 필터링됩니다.
      데이터 저장소.

      .. 메모::

         이 변수의 내용은 데이터 저장소 객체입니다.
         일반적인 데이터 저장소 작업을 사용하여 조회했습니다.

### `BB_PRESERVE_ENV`

      환경 변수를 필터링하지 않고 모든 변수를 허용합니다.
      외부 환경에서 BitBake의 데이터 저장소로 데이터를 전송합니다.

      .. 메모::

         이 변수를 외부 환경에 설정해야 합니다.
         제대로 작동하려면.

### `BB_PRESSURE_MAX_CPU`

      BitBake의 CPU 부하 임계값을 최대치로 지정합니다. 이 임계값을 초과하면 BitBake는 오류를 발생시킵니다.
      스케줄러는 (최소한의 작업이 있는 경우) 새 작업을 시작하지 않습니다.
      활성 작업이 하나 있는 경우). 값이 설정되지 않으면 CPU 부하가 표시되지 않습니다.
      작업 시작 시 모니터링됩니다.

      압력 데이터는 리눅스 커널 이후 버전을 기준으로 계산됩니다.
      버전 4.20은 ``/proc/pressure`` 아래에 노출됩니다. 임계값은 다음을 나타냅니다.
      이전 초와의 "총" 압력 차이.
      최소값은 1.0(매우 느린 빌드)이고 최대값은 다음과 같습니다.
      1000000 (도달할 가능성이 거의 없는 압력 값). 참조
      자세한 내용은 https://docs.kernel.org/accounting/psi.html을 참조하십시오.

      CPU 부하를 제한하는 기본값은 `conf/local.conf` 파일에 설정해야 합니다.
      그럴 수도 있습니다::

         BB_PRESSURE_MAX_CPU = "15000"

      빌드 호스트에서 여러 값을 테스트하여 적합한 값을 결정해야 합니다.
      최적의 선택은 성능 요구 사항과 부하 평균에 따라 달라집니다.
      빌드.

      .. 메모::

         BitBake에서 여러 메시지가 출력될 수 있습니다.
         `BB_PRESSURE_MAX_CPU` 값이 너무 낮습니다::

            압력 상태가 CPU: True, IO: False, Mem: False로 변경되었습니다(CPU: 1105.9/2.0, IO: 0.0/2.0, Mem: 0.0/2.0) - 1/64개의 비트베이크 스레드를 사용합니다.

         이는 `BB_PRESSURE_MAX_CPU` 값을 늘려야 함을 의미합니다.
         시스템의 CPU 부하를 제한하는 데 적절한 값입니다.
         위의 ``CPU:`` 뒤의 변화하는 값을 모니터링하여 적절한 값을 설정하십시오.

### `BB_PRESSURE_MAX_IO`

      BitBake의 최대 I/O 압력 임계값을 지정합니다. 이 임계값을 초과하면 BitBake는 오류를 발생시킵니다.
      스케줄러는 (최소한의 작업이 있는 경우) 새 작업을 시작하지 않습니다.
      하나의 활성 작업). 값이 설정되지 않으면 I/O 압력은 표시되지 않습니다.
      작업 시작 시 모니터링됩니다.

      압력 데이터는 리눅스 커널 이후 버전을 기준으로 계산됩니다.
      버전 4.20은 ``/proc/pressure`` 아래에 노출됩니다. 임계값은 다음을 나타냅니다.
      이전 초와의 "총" 압력 차이.
      최소값은 1.0(매우 느린 빌드)이고 최대값은 다음과 같습니다.
      1000000 (도달할 가능성이 거의 없는 압력 값). 참조
      자세한 내용은 https://docs.kernel.org/accounting/psi.html을 참조하십시오.

      현재 시점에서 실험 결과에 따르면 IO 압력은 다음과 같은 경향을 보입니다.
      수명이 짧고 CPU만 조절하는 방식입니다.
      `BB_PRESSURE_MAX_CPU`를 사용하면 이를 줄이는 데 도움이 될 수 있습니다.

      `conf/local.conf` 파일에 설정해야 하는 입출력 부하 제한 기본값입니다.
      그럴 수도 있습니다::

         BB_PRESSURE_MAX_IO = "15000"

      빌드 호스트에서 여러 값을 테스트하여 적합한 값을 결정해야 합니다.
      최적의 선택은 성능과 I/O 사용량에 대한 요구 사항에 따라 달라집니다.
      짓다.

      .. 메모::

         BitBake에서 여러 메시지가 출력될 수 있습니다.
         `BB_PRESSURE_MAX_IO` 값이 너무 낮습니다::

            압력 상태가 CPU: 없음, IO: 참, 메모리: 거짓으로 변경되었습니다(CPU: 2236.0/없음, IO: 153.6/2.0, 메모리: 0.0/2.0) - 19/64개의 bitbake 스레드를 사용합니다.

         이는 `BB_PRESSURE_MAX_IO` 값을 증가시켜야 함을 의미합니다.
         시스템의 I/O 부하를 제한하기 위한 적절한 값입니다.
         위의 ``IO:`` 이후의 변화하는 값을 모니터링하여 적절한 값을 설정하십시오.

### `BB_PRESSURE_MAX_MEMORY`

      BitBake의 최대 메모리 사용량 임계값을 지정합니다. 이 임계값을 초과하면 BitBake는 오류를 발생시킵니다.
      스케줄러는 (최소한의 작업이 있는 경우) 새 작업을 시작하지 않습니다.
      하나의 활성 작업). 값이 설정되지 않으면 메모리 압력이 발생하지 않습니다.
      작업 시작 시 모니터링됩니다.

      압력 데이터는 리눅스 커널 이후 버전을 기준으로 계산됩니다.
      버전 4.20은 ``/proc/pressure`` 아래에 노출됩니다. 임계값은 다음을 나타냅니다.
      이전 초와의 "총" 압력 차이.
      최소값은 1.0(매우 느린 빌드)이고 최대값은 다음과 같습니다.
      1000000 (도달할 가능성이 거의 없는 압력 값). 참조
      자세한 내용은 https://docs.kernel.org/accounting/psi.html을 참조하십시오.

      메모리 사용량이 많아지면 메모리 압박을 느끼게 됩니다.
      페이지 캐시에서 페이지를 다시 로드하거나 직접 페이지 회수를 수행합니다.
      이것이 바로 메모리 압력이 거의 나타나지 않는 이유이지만, 이 변수를 설정하면
      만약 메모리 부족 오류를 방지해야 한다면, 최후의 수단으로 유용할 수 있습니다.
      빌드 중에 발생합니다.

      메모리 사용량을 제한하기 위한 기본값을 설정합니다.
      `conf/local.conf` 파일은 다음과 같을 수 있습니다.

         BB_PRESSURE_MAX_MEMORY = "15000"

      빌드 호스트에서 여러 값을 테스트하여 적합한 값을 결정해야 합니다.
      성능과 메모리 사용량에 대한 요구 사항을 고려하여 최적의 선택을 하세요.
      빌드 중에.

      .. 메모::

         BitBake에서 여러 메시지가 출력될 수 있습니다.
         `BB_PRESSURE_MAX_MEMORY` 값이 너무 낮습니다::

            압력 상태가 CPU: 없음, IO: 거짓, 메모리: 참(CPU: 29.5/없음, IO: 0.0/2.0, 메모리: 2553.3/2.0)으로 변경되었습니다. - 17/64개의 비트베이크 스레드를 사용합니다.

         이는 `BB_PRESSURE_MAX_MEMORY` 값을 늘려야 함을 의미합니다.
         시스템의 메모리 부하를 제한하는 데 적절한 값입니다.
         위의 ``Mem:`` 뒤의 변화하는 값을 모니터링하여 적절한 값을 설정하십시오.

### `BB_RUNFMT`

      실행 가능한 스크립트 파일(즉, 실행 파일)의 이름을 지정합니다.
      ``${``\ `T`\ ``}``에 저장됩니다. 기본적으로
      `BB_RUNFMT` 변수가 정의되지 않았으며 실행 파일 이름이 잘못되었습니다.
      다음 양식을 사용하여 생성되었습니다.

         실행.{함수}.{pid}

      실행 파일의 이름을 특정 이름으로 강제 지정하려면 이 설정을 사용하면 됩니다.
      설정 파일의 변수.

### `BB_RUNTASK`

      현재 실행 중인 작업의 이름을 포함합니다. 값에는 다음이 포함됩니다.
      "do\_" 접두사가 붙습니다. 예를 들어, 현재 실행 중인 작업이 다음과 같을 경우
      `do_config`의 값은 "do_config"입니다.

### `BB_SCHEDULER`

      스케줄링에 사용할 스케줄러의 이름을 선택합니다.
      BitBake 작업. 세 가지 옵션이 있습니다.

      - *기본* --- 모든 것이 파생되는 기본 틀. 사용
         이 옵션을 선택하면 작업이 순서대로 숫자로 정렬됩니다.
         분석되었습니다.

      - *속도* --- 종속 작업이 더 많은 작업을 먼저 실행합니다.
         그들에게. "속도" 옵션이 기본값입니다.

      - *완료* --- 스케줄러가 주어진 작업을 완료하려고 시도하게 합니다.
         레시피는 일단 빌드가 시작되면 완성됩니다.

### `BB_SCHEDULERS`

      가져올 사용자 지정 스케줄러를 정의합니다. 사용자 지정 스케줄러는 다음 조건을 충족해야 합니다.
      `RunQueueScheduler` 클래스에서 파생되었습니다.

      스케줄러 선택 방법에 대한 자세한 내용은 다음을 참조하십시오.
      `BB_SCHEDULER` 변수.

### `BB_SETSCENE_DEPVALID`

      BitBake가 호출하는 함수를 지정하여 BitBake가 작동할지 여부를 결정합니다.
      setscene 종속성이 충족되어야 합니다.

      setscene 작업을 실행할 때 BitBake는 어떤 장면이 어떤 것인지 알아야 합니다.
      setscene 작업의 종속성도 실행해야 합니다.
      종속성 실행 또한 메타데이터에 크게 의존합니다.
      이 변수에 지정된 함수는 "True" 또는 "False"를 반환합니다.
      종속성을 충족해야 하는지 여부에 따라 다릅니다.

### `BB_SIGNATURE_EXCLUDE_FLAGS`

      안전하게 제외할 수 있는 변수 플래그(varflags) 목록을 보여줍니다.
      데이터 저장소의 키에 대한 체크섬 및 종속성 데이터입니다.
      데이터 저장소의 키에 대한 체크섬 또는 종속성 데이터를 생성하는 것,
      해당 키에 설정된 플래그는 일반적으로 체크섬에 포함됩니다.

      varflags에 대한 자세한 내용은 다음을 참조하세요.
      ":ref:`bitbake-user-manual/bitbake-user-manual-metadata:variable flags`"
      부분.

### `BB_SIGNATURE_HANDLER`

      BitBake에서 사용하는 서명 처리기의 이름을 정의합니다. 서명
      핸들러는 스탬프 파일이 생성되고 처리되는 방식을 정의합니다.
      서명이 도장에 어떻게 포함되는지, 그리고
      서명 자체가 생성됩니다.

      파생 클래스를 주입함으로써 새로운 시그니처 핸들러를 추가할 수 있습니다.
      ``SignatureGenerator`` 클래스에서 전역 네임스페이스로 이동합니다.

### `BB_SRCREV_POLICY`

      소스와 상호 작용할 때 페처의 동작을 정의합니다.
      제어 시스템 및 동적 소스 수정.
      `BB_SRCREV_POLICY` 변수는 특정 조건 없이 작업할 때 유용합니다.
      회로망.

      해당 변수는 다음 두 가지 정책 중 하나를 사용하여 설정할 수 있습니다.

      - *캐시* --- 시스템이 이전에 얻은 값을 유지합니다.
         매번 소스 제어 시스템에 쿼리하는 것보다 낫습니다.

      - *clear* --- 소스 제어 시스템에 매번 쿼리를 보냅니다. 이렇게 하면
         정책상 캐시가 없습니다. "지우기" 정책이 기본값입니다.

### `BB_STRICT_CHECKSUM`

      로컬 URL이 아닌 URL에 대해 더 엄격한 체크섬 메커니즘을 설정합니다.
      이 변수를 특정 값으로 변경하면 BitBake에서 오류가 발생합니다.
      체크섬이 하나 이상 없는 비로컬 URL을 만났습니다.
      명시된.

### `BB_TASK_IONICE_LEVEL`

      작업의 입력/출력 우선순위를 조정할 수 있습니다.
      오토빌더 테스트 중 I/O 문제로 인해 작업에서 무작위 오류가 발생할 수 있습니다.
      기아 현상. 이러한 오류는 다양한 QEMU 런타임 중에 발생합니다.
      타임아웃이 발생할 수 있습니다. `BB_TASK_IONICE_LEVEL` 변수를 사용하여 조정할 수 있습니다.
      이러한 작업의 I/O 우선순위.

      .. 메모::

         이 변수는 `BB_TASK_NICE_LEVEL`과 유사하게 작동합니다.
         작업의 입출력 우선순위를 제외하고는 변수입니다.

      변수를 다음과 같이 설정하세요::

         BB_TASK_IONICE_LEVEL = "class.prio"

      *클래스*의 경우 기본값은 "2"이며, 이는 최선의 노력입니다. 다음과 같이 사용할 수 있습니다.
      "1"은 실시간, "3"은 유휴 상태를 의미합니다. 실시간 모드를 사용하려면 다음을 수행하십시오.
      관리자 권한이 있어야 합니다.

      *prio*의 경우, 가장 높은 값인 "0"부터 임의의 값을 사용할 수 있습니다.
      우선순위를 가장 낮은 "7"로 설정합니다. 기본값은 "4"입니다.
      이 우선순위 범위를 사용하기 위해 특별한 권한이 필요하지 않습니다.
      값들.

      .. 메모::

         I/O 우선 순위 설정이 적용되려면 다음이 필요합니다.
         백킹 블록에 대해 BFQ(Budget Fair Queuing) 스케줄러가 선택되었습니다.
         장치. 스케줄러를 선택하려면 다음 명령 형식을 사용하십시오.
         device는 장치를 의미합니다(예: sda, sdb 등).

            $ sudo sh -c "echo bfq > /sys/block/device/queue/scheduler"

### `BB_TASK_NICE_LEVEL`

      특정 작업의 우선순위(예: 만족도)를 변경할 수 있습니다.

      이 변수를 작업 재정의와 함께 사용하여 오류를 발생시킬 수 있습니다.
      또는 특정 작업의 우선순위를 낮춥니다. 예를 들어, `Yocto`에서
      프로젝트 <https://www.yoctoproject.org>`__ 자동 빌더, QEMU 에뮬레이션
      이미지 작업은 빌드 작업에 비해 더 높은 우선순위를 갖습니다.
      시스템에 부하가 걸린 상태에서 이미지 타임아웃이 발생하지 않도록 하십시오.

### `BB_TASKHASH`

      실행 중인 작업 내에서 이 변수는 해당 작업의 해시값을 저장합니다.
      현재 활성화된 서명 생성기에서 반환된 값입니다.

### `BB_USE_HOME_NPMRC`

      BitBake가 사용자의 .npmrc 파일을 사용할지 여부를 제어합니다.
      npm fetcher 내의 홈 디렉토리입니다. 이는 인증에 사용될 수 있습니다.
      개인 NPM 레지스트리 등 다양한 용도로 사용됩니다. 이 기능은 기본적으로 비활성화되어 있습니다.
      또한 사용자가 활성화하려면 해당 값을 "1"로 명시적으로 설정해야 합니다.

### `BB_VERBOSE_LOGS`

      빌드 과정에서 BitBake의 상세 출력 수준을 제어합니다. 설정된 경우 셸 스크립트가 실행됩니다.
      echo 명령과 셸 스크립트의 출력은 표준 출력으로 나타납니다.
      (표준 출력).

### `BB_WORKERCONTEXT`

      현재 컨텍스트가 작업을 실행 중인지 여부를 지정합니다. BitBake는 이를 설정합니다.
      이 변수는 작업 실행 시 "1"로 설정됩니다. 값은 다음과 같지 않습니다.
      구문 분석 또는 이벤트 처리 중에 작업이 서버 컨텍스트에 있을 때 설정됩니다.
      손질.

### `BBCLASSEXTEND`

      레시피를 확장하여 동일한 레시피의 변형을 만들 수 있도록 합니다.
      소프트웨어. 다음은 레시피에 대한 몇 가지 변형 예시입니다.
      OpenEmbedded-Core 메타데이터는 ``quilt-native``와 같은 "네이티브"입니다.
      이는 빌드 시스템에서 실행되도록 만들어진 Quilt의 복제본입니다. "crosses"
      예를 들어, 빌드 환경에서 실행되도록 만들어진 컴파일러인 ``gcc-cross`` 등이 있습니다.
      머신에서 실행되지만 대상 "MACHINE"에서 실행되는 바이너리를 생성합니다.
      "nativesdk"는 `MACHINE` 대신 SDK 머신을 대상으로 합니다.
      그리고 "multilibs"는 "``multilib:``\ multilib_name" 형식입니다.

      최소한의 재료로 레시피의 다른 변형을 만들려면
      코드의 경우, 일반적으로 레시피에 변수를 추가하는 것만큼 간단합니다.
      다음은 두 가지 예입니다. "네이티브" 변형은 다음에서 가져온 것입니다.
      OpenEmbedded-Core 메타데이터::

         BBCLASSEXTEND =+ "native nativesdk"
         BBCLASSEXTEND =+ "multilib:multilib_name"

      .. 메모::

         내부적으로, `BBCLASSEXTEND` 메커니즘은 레시피를 생성합니다.
         변수 값을 다시 작성하고 재정의를 적용하는 등의 방법으로 변형을 만들 수 있습니다.
         ``_class-native``와 같이 지정합니다. 예를 들어 네이티브 버전을 생성하려면 다음과 같이 합니다.
         레시피, 즉 "foo"에 의존하는 `DEPENDS`는
         "foo-native"에 대한 `DEPENDS`로 재작성되었습니다.

         `BBCLASSEXTEND`를 사용하더라도 레시피는 한 번만 파싱됩니다.
         한 번 파싱하면 몇 가지 제약 사항이 생깁니다. 예를 들어, 다음과 같은 것은 아닙니다.
         버전에 따라 다른 파일을 포함할 수 있습니다.
         `include` 문은 레시피가 처리될 때 실행되기 때문입니다.
         분석되었습니다.

### `BBDEBUG`

      BitBake 디버그 출력 레벨을 특정 값으로 설정합니다.
      ``-D`` 명령줄 옵션에 의해 증가합니다.

      .. 메모::

         이 변수를 외부 환경에 설정해야 합니다.
         제대로 작동하려면.

### `BBFILE_COLLECTIONS`

      구성된 레이어의 이름을 나열합니다. 이러한 이름은 찾기 위해 사용됩니다.
      다른 ``BBFILE_*`` 변수들. 일반적으로 각 레이어는 자체 변수를 추가합니다.
      `conf/layer.conf` 파일에서 이 변수의 이름을 지정합니다.

### `BBFILE_PATTERN`

      파일과 일치하도록 확장되는 변수
      특정 레이어의 `BBFILES`. 이것은
      해당 변수는 `conf/layer.conf` 파일에서 사용되며 접미사가 붙어야 합니다.
      특정 레이어의 이름과 함께 (예:
      ``BBFILE_PATTERN_emenlow``).

### `BBFILE_PRIORITY`

      각 계층의 레시피 파일에 우선순위를 지정합니다.

      이 변수는 `conf/layer.conf` 파일에서 사용되며 반드시 입력해야 합니다.
      `_` 뒤에 특정 레이어 이름이 붙습니다(예:
      ``BBFILE_PRIORITY_emenlow``). 구분자로 콜론을 사용하는 것은 지원되지 않습니다.

      이 변수는 동일한 레시피가 여러 번 나타나는 상황에서 유용합니다.
      두 개 이상의 레이어에서. 이 변수를 설정하면 다음을 수행할 수 있습니다.
      동일한 레시피를 포함하는 다른 레이어보다 특정 레이어의 우선순위를 지정합니다.
      --- 여러 항목에 대한 우선순위를 효과적으로 제어할 수 있습니다.
      레이어. 이 변수를 통해 확립된 우선순위는 다음과 같습니다.
      레시피 버전(PV 변수)과는 관계없습니다.
      예를 들어, 더 높은 PV 값을 가진 레시피를 포함하는 레이어가 있지만
      `BBFILE_PRIORITY`가 더 낮은 우선순위로 설정된 경우
      여전히 우선순위가 낮습니다.

      `BBFILE_PRIORITY` 변수에 더 큰 값을 입력하면 다음과 같은 결과가 나타납니다.
      우선순위가 더 높습니다. 예를 들어, 값 6은 우선순위가 더 높습니다.
      5보다 큰 값. 지정되지 않은 경우 `BBFILE_PRIORITY` 변수가 사용됩니다.
      레이어 종속성을 기반으로 설정됩니다(`LAYERDEPENDS` 변수 참조).
      자세한 내용은 (참조)를 참조하십시오. 지정되지 않은 경우 기본 우선순위가 적용됩니다.
      종속성이 없는 레이어는 가장 낮은 정의된 우선순위 + 1(또는 1)입니다.
      우선순위가 정해지지 않은 경우).

      팁::

         `bitbake-layers show-layers` 명령어를 사용하면 모든 레이어를 나열할 수 있습니다.
         우선순위와 함께 구성된 레이어입니다.

### `BBFILES`

      BitBake가 빌드에 사용하는 레시피 파일 목록(공백으로 구분)
      소프트웨어.

      레시피 파일을 지정할 때 Python의 패턴 매칭 기능을 사용할 수 있습니다.
      `glob <https://docs.python.org/3/library/glob.html>`_ 구문.
      구문에 대한 자세한 내용은 다음 문서를 참조하십시오.
      이전 링크.

### `BBFILES_DYNAMIC`

      식별된 레이어의 존재 여부에 따라 콘텐츠를 활성화합니다.
      레이어가 정의하는 컬렉션을 기준으로 레이어를 식별합니다.

      `.bbappend` 파일의 생성을 방지하려면 `BBFILES_DYNAMIC` 변수를 사용하십시오.
      해당 ``.bb`` 파일은 다른 레이어를 수정하려는 레이어에 있습니다.
      ``.bbappend``를 통해 레이어를 추가하지만, 하드코딩을 도입하고 싶지는 않습니다.
      다른 계층에 대한 의존성.

      또한 규칙 앞에 "!"를 붙여 ``.bbappend``를 추가할 수 있습니다.
      레이어가 없는 경우 ``.bb`` 파일을 생성합니다. 이를 사용하면 하드 드라이브를 피할 수 있습니다.
      다른 계층에 대한 의존성.

      `BBFILES_DYNAMIC`::에 대해 다음 형식을 사용하십시오.

         컬렉션 이름:파일 이름 패턴

      다음 예는 두 개의 컬렉션 이름과 두 개의 파일 이름을 나타냅니다.
      패턴::

         BBFILES_DYNAMIC += "\
             clang-layer:${LAYERDIR}/bbappends/meta-clang/*/*/*.bbappend \
             core:${LAYERDIR}/bbappends/openembedded-core/meta/*/*/*.bbappend \
         "

      컬렉션 이름 앞에 "!"가 붙으면 파일 패턴이 추가됩니다.
      해당 레이어가 없습니다.

         BBFILES_DYNAMIC += "\
             !clang-layer:${LAYERDIR}/backfill/meta-clang/*/*/*.bb \
         "

      다음 예시는 유효하지 않은 내용으로 인해 발생하는 오류 메시지를 보여줍니다.
      구문 분석 오류를 일으키는 항목이 발견되었습니다.

         오류: BBFILES_DYNAMIC 항목은 {!}<컬렉션 이름>:<파일 이름 패턴> 형식이어야 하며, 다음 형식이 아닙니다.
         /work/my-layer/bbappends/meta-security-isafw/*/*/*.bbappend
         /work/my-layer/bbappends/openembedded-core/meta/*/*/*.bbappend

### `BBINCLUDED`

      BitBake의 모든 파일 목록이 공백으로 구분되어 있습니다.
      현재 파일을 구문 분석하는 동안 파서가 포함되었습니다.

### `BBINCLUDELOGS`

      특정 값으로 설정하면 보고 시 작업 로그를 출력할 수 있습니다.
      작업이 실패했습니다.

### `BBINCLUDELOGS_LINES`

      `BBINCLUDELOGS`가 설정된 경우, 지정합니다.
      작업 로그 파일에서 출력할 최대 줄 수
      작업 실패를 보고합니다. `BBINCLUDELOGS_LINES`를 설정하지 않으면,
      로그 전체가 출력됩니다.

### `BBLAYERS`

      빌드 중에 활성화할 레이어 목록을 지정합니다. 이 변수는 정의되어 있습니다.
      빌드 디렉터리에 있는 ``bblayers.conf`` 구성 파일에서.
      다음은 예시입니다.

         BBLAYERS = " \
             /home/scottrif/poky/meta \
             /home/scottrif/poky/meta-yocto \
             /home/scottrif/poky/meta-yocto-bsp \
             /home/scottrif/poky/meta-mykernel \
         "

      이 예제는 네 개의 레이어를 지원하며, 그중 하나는 사용자 정의 레이어입니다.
      ``meta-mykernel``이라는 이름의 레이어입니다.

### `BBLAYERS_FETCH_DIR`

      레이어가 저장되는 기본 위치를 설정합니다. 이 설정은 다음과 같은 용도로 사용됩니다.
      ``bitbake-layers layerindex-fetch``와 함께 사용하면 다음과 같이 알려줍니다.
      가져온 레이어를 배치할 ``bitbake-layers``를 지정합니다.

### `BBMASK`

      BitBake가 레시피 및 레시피 추가 파일을 처리하는 것을 방지합니다.

      `BBMASK` 변수를 사용하면 이러한 ``.bb`` 파일을 "숨길" 수 있습니다.
      ``.bbappend`` 파일. BitBake는 레시피 또는 레시피 추가 파일을 무시합니다.
      어떤 표현식과도 일치하는 파일. 마치 BitBake가 그렇지 않은 것 같습니다.
      해당 파일들을 전혀 볼 수 없습니다. 결과적으로 일치하는 파일은 구문 분석되지 않습니다.
      그렇지 않으면 BitBake에서 사용됩니다.

      사용자가 제공하는 값은 파이썬의 정규 표현식에 전달됩니다.
      컴파일러입니다. 따라서 구문은 파이썬의 정규 구문을 따릅니다.
      표현식 (재) 구문. 표현식은 전체와 비교됩니다. 표현식은 전체와 비교됩니다.
      파일 경로입니다. 전체 구문 정보는 Python의 구문 가이드를 참조하세요.
      자세한 내용은 http://docs.python.org/3/library/re.html 에서 확인할 수 있습니다.

      다음 예제는 완전한 정규 표현식을 사용하여 설명합니다.
      BitBake에서 모든 레시피 및 레시피 추가 파일을 무시하도록 설정
      ``meta-ti/recipes-misc/`` 디렉토리::

         BBMASK = "meta-ti/recipes-misc/"

      여러 디렉토리 또는 레시피를 가리고 싶다면 다음과 같이 할 수 있습니다.
      여러 개의 정규 표현식 조각을 지정합니다. 다음 예시를 참조하세요.
      여러 디렉토리와 개별 레시피를 숨깁니다.

         BBMASK += "/meta-ti/recipes-misc/meta-ti/recipes-ti/packagegroup/"
         BBMASK += "/meta-oe/recipes-support/"
         BBMASK += "/meta-foo/.*/openldap"
         BBMASK += "opencv.*\.bbappend"
         BBMASK += "lzma"

      .. 메모::

         디렉터리 이름을 지정할 때는 끝에 슬래시(/) 문자를 사용하십시오.
         해당 디렉토리 이름과 정확히 일치하는지 확인하기 위해서입니다.

### `BBMULTICONFIG`

      BitBake가 여러 구성 빌드 및 목록을 수행할 수 있도록 합니다.
      각각의 개별 구성(멀티 구성)에 대해 이 변수를 사용할 수 있습니다.
      BitBake가 각 타겟에 대해 여러 개의 타겟을 빌드하도록 하려면
      별도의 설정을 하세요. 설정 파일에 `BBMULTICONFIG`를 정의하세요.
      `conf/local.conf` 설정 파일입니다.

      예를 들어, 다음 줄은 각각 세 개의 멀티 구성을 지정합니다.
      별도의 설정 파일을 가지고 있는 경우::

         BBMULTIFONFIG = "configA configB configC"

      사용하는 각 설정 파일은 다음 위치에 있어야 합니다.
      `conf/multiconfig`라는 디렉토리 내의 빌드 디렉토리 (예:
      빌드 디렉토리\ ``/conf/multiconfig/configA.conf``).

      환경에서 `BBMULTICONFIG`를 사용하는 방법에 대한 정보는 다음을 참조하십시오.
      다양한 구성을 가진 빌드 대상을 지원하는 기능에 대해서는 다음을 참조하십시오.
      ":ref:`bitbake-user-manual/bitbake-user-manual-intro:다중 구성 빌드 실행`"
      부분.

### `BBPATH`

      BitBake에서 클래스를 찾기 위해 사용하는 콜론으로 구분된 목록(``.bbclass``)
      및 구성 파일(``.conf``)입니다. 이 변수는 다음과 유사합니다.
      `PATH` 변수.

      빌드 디렉토리 외부의 디렉토리에서 BitBake를 실행하는 경우,
      빌드 디렉토리를 가리키도록 `BBPATH`를 반드시 설정해야 합니다.
      다른 환경 변수와 마찬가지로 변수를 설정한 다음 실행하세요.
      비트베이크::

         $ BBPATH="build_directory"
         $ BBPATH 내보내기
         $ 비트베이크 타겟

### `BBSERVER`

      메모리 상주 BitBake를 실행하는 서버를 가리킵니다. 변수
      이 기능은 메모리 상주 BitBake를 사용할 때만 사용됩니다.

### `BBTARGETS`

      구성 파일을 사용하여 목록에 추가할 수 있습니다.
      빌드하려는 명령줄 대상 레시피입니다.

### `BITBAKE_UI`

      BitBake를 실행할 때 사용할 UI 모듈을 지정하는 데 사용됩니다. 이를 사용하면
      이 변수는 명령줄 옵션 ``-u``를 사용하는 것과 동일합니다.

      .. 메모::

         이 변수를 외부 환경에 설정해야 합니다.
         제대로 작동하려면.

### `BUILDNAME`

      빌드에 할당된 이름입니다. 이 이름은 기본적으로 날짜/시간 스탬프 형식으로 지정됩니다.
      빌드가 시작된 시점이지만 메타데이터를 통해 정의할 수 있습니다.

### `BZRDIR`

      바자 시스템에서 체크아웃한 파일이 저장되는 디렉토리는 다음과 같습니다.
      저장됨.

### `CACHE`

      BitBake가 메타데이터 캐시를 저장하는 데 사용하는 디렉터리를 지정합니다.
      따라서 BitBake가 시작될 때마다 구문 분석할 필요가 없습니다.

### `CVSDIR`

      CVS 시스템에서 체크아웃된 파일이 저장되는 디렉토리는 다음과 같습니다.
      저장됨.

### `DEFAULT_PREFERENCE`

      레시피 선택 우선순위에 대한 약한 편향을 지정합니다.

      이 변수의 가장 일반적인 사용법은 해당 변수를 "-1"로 설정하는 것입니다.
      소프트웨어 개발 버전을 위한 레시피.
      이런 식으로 변수를 사용하면 레시피의 안정적인 버전이 빌드됩니다.
      기본적으로 `PREFERRED_VERSION`이 사용되지 않는 경우
      개발 버전을 빌드합니다.

      .. 메모::

         DEFAULT_PREFERENCE에서 제공하는 편향은 미약하며 다른 값으로 덮어쓰여집니다.
         `BBFILE_PRIORITY` 변수가 두 변수 간에 다른 경우
         같은 레시피의 여러 가지 버전이 담긴 층들.

### `DEPENDS`

      레시피의 빌드 시 필요한 종속 파일(즉, 다른 레시피 파일) 목록을 표시합니다.

      "a"와 "b"라는 두 가지 레시피를 예로 들어 보겠습니다.
      비슷한 이름의 패키지를 생성합니다. 이 예에서 `DEPENDS`는 비슷한 이름의 패키지를 생성합니다.
      해당 내용은 "a" 레시피에 나타납니다.

         의존성 = "b"

      여기서 종속성은 레시피 "a"에 대한 `do_configure` 작업과 같습니다.
      레시피 "b"의 `do_populate_sysroot` 작업에 의존합니다. 즉,
      레시피 "b"가 sysroot에 넣는 모든 내용은 레시피 "a"가 실행될 때 사용할 수 있습니다.
      스스로 구성 중입니다.

      런타임 종속성에 대한 자세한 내용은 `RDEPENDS`를 참조하십시오.
      변하기 쉬운.

### `DESCRIPTION`

      레시피에 대한 긴 설명입니다.

### `DL_DIR`

      빌드 프로세스에서 사용하는 중앙 다운로드 디렉터리
      다운로드. 기본적으로 `DL_DIR`은 미러링에 적합한 파일을 가져옵니다.
      Git 저장소를 제외한 모든 것. Git의 tarball을 원하시면
      저장소의 경우 `BB_GENERATE_MIRROR_TARBALLS` 변수를 사용하십시오.

### `EXCLUDE_FROM_WORLD`

      BitBake에게 월드 빌드에서 특정 레시피를 제외하도록 지시합니다(예:
      ``bitbake world``). 월드 빌드 과정에서 BitBake는 파일을 찾고, 구문 분석하고,
      모든 레이어에 노출된 모든 레시피를 빌드합니다.
      ``bblayers.conf`` 설정 파일.

      이 변수를 사용하여 월드 빌드에서 레시피를 제외하려면 다음을 설정하세요.
      레시피에서 변수를 "1"로 설정하세요. 월드 빌드에 다시 추가하려면 "0"으로 설정하세요.

      .. 메모::

         `EXCLUDE_FROM_WORLD`로 지정된 레시피도 월드 빌드 중에 생성될 수 있습니다.
         다른 레시피의 종속성을 충족시키기 위해 빌드합니다. 추가
         레시피를 `EXCLUDE_FROM_WORLD`로 설정하면 해당 레시피가 `EXCLUDE_FROM_WORLD`에 포함되지 않도록 보장할 뿐입니다.
         월드 빌드의 빌드 대상 목록에 명시적으로 추가되었습니다.

### `FAKEROOT`

      가짜 루트에서 셸 스크립트를 실행할 때 사용할 명령어가 포함되어 있습니다.
      환경. `FAKEROOT` 변수는 더 이상 사용되지 않으며 다음과 같이 변경되었습니다.
      다른 ``FAKEROOT*`` 변수로 대체됩니다. 다음 항목을 참조하십시오.
      자세한 내용은 용어집을 참조하세요.

### `FAKEROOTBASEENV`

      정의된 명령을 실행할 때 설정할 환경 변수 목록을 보여줍니다.
      `FAKEROOTCMD`에 의해 시작됩니다.
      fakeroot 환경에서 bitbake-worker 프로세스.

### `FAKEROOTCMD`

      이 파일에는 bitbake-worker 프로세스를 시작하는 명령이 포함되어 있습니다.
      fakeroot 환경.

### `FAKEROOTDIRS`

      fakeroot에서 작업을 실행하기 전에 생성할 디렉터리 목록을 보여줍니다.
      환경.

### `FAKEROOTENV`

      작업을 실행할 때 설정해야 하는 환경 변수 목록을 보여줍니다.
      fakeroot 환경입니다. 환경에 대한 추가 정보는 다음을 참조하세요.
      변수 및 fakeroot 환경에 대한 자세한 내용은 다음을 참조하십시오.
      `FAKEROOTBASEENV` 변수.

### `FAKEROOTNOENV`

      목록에 없는 작업을 실행할 때 설정해야 하는 환경 변수 목록을 보여줍니다.
      fakeroot 환경. 환경에 대한 추가 정보는 다음을 참조하세요.
      변수 및 fakeroot 환경에 대한 자세한 내용은 다음을 참조하십시오.
      `FAKEROOTENV` 변수.

### `FETCHCMD`

      BitBake 페처 모듈이 실행될 때 실행하는 명령어를 정의합니다.
      가져오기 작업. 사용할 때는 재정의 접미사를 사용해야 합니다.
      변수(예: ``FETCHCMD_git`` 또는 ``FETCHCMD_svn``).

### `FILE`

      현재 파일을 가리킵니다. BitBake는 실행 중에 이 변수를 설정합니다.
      파싱 ​​과정에서 파싱 대상 파일을 식별합니다. BitBake는 또한 다음과 같이 설정합니다.
      이 변수는 레시피가 실행될 때 레시피를 식별하는 데 사용됩니다.
      파일.

### `FILESPATH`

      BitBake가 패치를 검색할 때 사용하는 디렉터리를 지정합니다.
      파일. "로컬" 가져오기 모듈은 다음 디렉터리를 사용합니다.
      `file://` URL을 처리합니다. 이 변수는 셸의 `PATH`처럼 동작합니다.
      환경 변수입니다. 값은 콜론으로 구분된 목록입니다.
      디렉토리는 왼쪽에서 오른쪽 순서로 검색됩니다.

### `FILE_LAYERNAME`

      구문 분석 및 작업 실행 중에 이 값은 해당 이름으로 설정됩니다.
      레시피 파일이 포함된 레이어입니다. 코드는 이를 사용하여 어떤 파일인지 식별할 수 있습니다.
      레시피는 레이어에서 가져온 것입니다.

### `GITDIR`

      Git 저장소의 로컬 복사본이 저장되는 디렉터리
      복제될 때.

### `HGDIR`

      Mercurial 시스템에서 체크아웃한 파일이 저장되는 디렉터리는 다음과 같습니다.
      저장됨.

### `HOMEPAGE`

      해당 레시피 소프트웨어에 대한 자세한 정보가 있는 웹사이트입니다.
      건물을 찾을 수 있습니다.

### `INHERIT`

      지정된 클래스 또는 클래스들이 전역적으로 상속되도록 합니다. 익명
      클래스 또는 클래스 내의 함수는 서로 다른 두 상황에서 실행됩니다.

      - 오직 ~만
         :ref:`기본 구성 <bitbake-user-manual/bitbake-user-manual-execution:기본 구성 메타데이터 구문 분석>`
         파싱됩니다. 예를 들어 다음 BitBake 호출의 결과입니다.

            $ bitbake -e

      - 레시피가 분석될 때 - 분석된 각 레시피에 대해.

      Bitbake는 개별 레시피의 ``INHERIT`에 대한 변경 사항을 무시합니다.

      `INHERIT`에 대한 자세한 내용은 다음을 참조하십시오.
      ":ref:`bitbake-user-manual/bitbake-user-manual-metadata:\`\`구성 지시문 상속`"
      부분.

### `LAYERDEPENDS`

      이 레시피에 사용된 재료들을 공백으로 구분하여 나열합니다.
      상황에 따라 다릅니다. 선택적으로 특정 레이어 버전을 지정할 수 있습니다.
      레이어 이름 끝에 콜론을 붙여 종속성을 추가합니다.
      (예: "anotherlayer:3"과 비교)
      `레이어버전`\ ``_anotherlayer``에서
      이 경우). BitBake는 종속성 중 하나라도 누락되면 오류를 발생시킵니다.
      버전 번호가 정확히 일치하지 않습니다(명시된 경우).

      이 변수는 `conf/layer.conf` 파일에서 사용합니다. 또한 다음 사항도 준수해야 합니다.
      변수 뒤에 특정 레이어 이름을 접미사로 사용하세요(예:
      ``LAYERDEPENDS_mylayer``).

### `LAYERDIR`

      `layer.conf` 설정 파일 내에서 사용될 때, 이 변수는
      현재 레이어의 경로를 제공합니다. 이 변수는 아닙니다.
      `layer.conf` 외부에서 사용 가능하며 참조가 확장됩니다.
      파일 파싱이 완료되는 즉시.

### `LAYERDIR_RE`

      `layer.conf` 설정 파일 내에서 사용될 때, 이 변수는
      현재 레이어의 경로를 제공하며, 일반적인 사용을 위해 이스케이프 처리되었습니다.
      표현(`BBFILE_PATTERN`). 이것은
      해당 변수는 `layer.conf` 파일 및 참조 외부에서는 사용할 수 없습니다.
      파일 파싱이 완료되면 즉시 내용이 확장됩니다.

### `LAYERSERIES_COMPAT`

      OpenEmbedded-Core(OE-Core)의 버전 목록을 표시합니다.
      레이어가 호환되는지 확인하려면 `LAYERSERIES_COMPAT` 변수를 사용하세요.
      레이어 관리자가 어떤 조합을 사용할지 지정할 수 있도록 합니다.
      레이어와 OE-Core는 정상적으로 작동할 것으로 예상됩니다. 변수는 다음을 제공합니다.
      이 시스템은 레이어가 새로운 버전으로 테스트되지 않았을 때를 감지하는 방법을 제공합니다.
      OE-Core 릴리스(예: 해당 레이어는 유지 관리되지 않음).

      레이어가 호환되는 OE-Core 버전을 지정하려면 다음을 사용하십시오.
      이 변수는 레이어의 `conf/layer.conf` 설정 파일에 있습니다.
      목록을 작성할 때는 Yocto Project 릴리스 이름(예: "kirkstone")을 사용하세요.
      "mickledore"). 레이어에 대해 여러 OE-Core 버전을 지정하려면 다음을 사용하십시오.
      공백으로 구분된 목록::

         LAYERSERIES_COMPAT_layer_root_name = "kirkstone miclkledore"

      .. 메모::

         Yocto 프로젝트에서는 `LAYERSERIES_COMPAT` 설정을 필수로 요구합니다.
         호환 버전 2 표준.
         OpenEmbedded 빌드 시스템은 변수가 특정 값일 경우 경고를 생성합니다.
         어떤 레이어에도 설정되어 있지 않습니다.

### `LAYERVERSION`

      선택적으로 레이어 버전을 단일 숫자로 지정할 수 있습니다.
      이 변수를 사용할 수 있습니다.
      다른 레이어에 대한 `LAYERDEPENDS`
      레이어의 특정 버전에 의존하도록 하기 위함입니다.

      이 변수는 `conf/layer.conf` 파일에서 사용합니다. 또한 다음 사항도 준수해야 합니다.
      변수 뒤에 특정 레이어 이름을 접미사로 사용하세요(예:
      ``LAYERDEPENDS_mylayer``).

### `LICENSE`

      레시피에 사용된 소스 라이선스 목록입니다.

### `MIRRORS`

      BitBake가 소스 코드를 가져오는 추가 경로를 지정합니다.
      빌드 시스템은 소스 코드를 찾을 때 먼저 로컬 저장소를 시도합니다.
      다운로드 디렉토리입니다. 해당 위치에서 오류가 발생하면 빌드 시스템은 다른 위치를 시도합니다.
      `PREMIRRORS`로 정의된 위치,
      업스트림 소스, 그리고 그 안에 있는 `MIRRORS`로 지정된 위치들
      주문하다.

### `OVERRIDES`

      BitBake에서 변수를 제어하는 ​​데 사용하는 콜론으로 구분된 목록입니다.
      BitBake가 레시피와 구성 파일을 분석한 후 재정의됩니다.

      다음은 오버라이드 목록을 기반으로 하는 간단한 예입니다.
      머신 아키텍처: OVERRIDES = "arm:x86:mips:powerpc" 가능합니다
      `OVERRIDES`를 사용하는 방법에 대한 정보를 찾아보세요.
      ":ref:`bitbake-user-manual/bitbake-user-manual-metadata:조건부 구문
      (재정의)`" 섹션.

### `P4DIR`

      Perforce 저장소의 로컬 복사본이 저장되는 디렉터리입니다.
      가져올 때.

### `PACKAGES`

      레시피가 생성하는 패키지 목록입니다.

### `PACKAGES_DYNAMIC`

      레시피가 런타임 종속성을 충족한다는 약속
      다른 레시피에서 찾을 수 있는 선택적 모듈입니다.
      `PACKAGES_DYNAMIC`은 실제로 종속성을 충족시키지 않습니다.
      단지 만족해야 한다는 것만 명시합니다. 예를 들어, 어려운 상황이라면,
      다른 런타임 종속성(RDEPENDS)
      패키지는 빌드 과정에서 만족됩니다.
      `PACKAGES_DYNAMIC` 변수이지만 모듈 이름이 있는 패키지는 다음과 같습니다.
      실제로 생산되지 않으면 다른 패키지는 파손될 것입니다.

### `PE`

      레시피의 시점입니다. 기본적으로 이 변수는 설정되지 않았습니다.
      이 변수는 버전 관리 체계에서 업그레이드를 가능하게 하는 데 사용됩니다.
      일부 변경 사항이 이전 버전과 호환되지 않습니다.

### `PERSISTENT_DIR`

      BitBake가 데이터를 저장하는 데 사용하는 디렉터리를 지정합니다.
      빌드 간에 보존됩니다. 특히, 저장되는 데이터는 다음과 같습니다.
      BitBake의 영구 데이터 API를 사용하는 PR에서 사용되는 데이터
      서버 및 PR 서비스, 그리고 해시 등가값의 기본 위치
      데이터베이스(BB_HASHSERVE가 `auto`로 설정된 경우).

      이 디렉터리는 서로 다른 빌드 간에 공유되어서는 안 됩니다. 필요한 경우
      해시 등가 데이터베이스를 공유하려면 해시를 설정해야 합니다.
      동등성 서버 대신.

### `PF`

      레시피 또는 패키지 이름을 지정하고 모든 버전을 포함합니다.
      개정 번호(예: ``eglibc-2.13-r20+svnr15508/`` 및
      ``bash-4.2-r1/``).

### `PN`

      레시피 이름.

### `PR`

      레시피 수정.

### `PREFERRED_PROVIDER`

      여러 레시피가 있을 때 어떤 레시피를 우선적으로 사용할지 결정합니다.
      레시피는 동일한 재료를 제공합니다. 변수에는 항상 접미사를 붙여야 합니다.
      제공된 항목의 이름을 사용하여 설정해야 합니다.
      주고 싶은 레시피의 `PN`을 입력하세요.
      우선순위. 몇 가지 예시:

         PREFERRED_PROVIDER_virtual/kernel ?= "linux-yocto"
         PREFERRED_PROVIDER_virtual/xserver = "xserver-xf86"
         PREFERRED_PROVIDER_virtual/libgl ?= "mesa"

### `PREFERRED_PROVIDERS`

      어떤 경우에 어떤 레시피를 우선적으로 사용해야 하는지 결정합니다.
      여러 레시피가 동일한 재료를 제공합니다. 기능적으로,
      `PREFERRED_PROVIDERS`는 다음과 같습니다.
      `선호하는 공급자`. 하지만 `선호하는 공급자들` 변수는
      다음과 같이 여러 상황에 대한 기본 설정을 정의할 수 있습니다.
      형태::

         PREFERRED_PROVIDERS = "xxx:yyy aaa:bbb ..."

      이 양식은 다음 양식을 편리하게 대체할 수 있습니다.

         PREFERRED_PROVIDERS_xxx = "yyy"
         PREFERRED_PROVIDERS_aaa = "bbb"

### `PREFERRED_VERSION`

      레시피에 여러 버전이 있는 경우 이 변수
      어떤 버전에 우선순위를 부여할지 결정합니다. 항상
      원하는 PN 용어를 변수 끝에 추가하세요.
      선택하고, 그에 따라 `PV`를 설정해야 합니다.
      상위.

      `PREFERRED_VERSION` 변수는 제한적인 와일드카드 사용을 지원합니다.
      "%" 문자를 통해 연결할 수 있습니다. 이 문자를 사용하여 모든 항목과 일치시킬 수 있습니다.
      문자 수는 버전을 지정할 때 유용할 수 있습니다.
      변경될 가능성이 있는 긴 개정 번호를 포함하고 있습니다. 다음은 그 예입니다.
      두 가지 예시:

         PREFERRED_VERSION_python = "2.7.3"
         PREFERRED_VERSION_linux-yocto = "4.12%"

      .. 중요한::

         " % " 문자의 사용은 다음과 같은 경우에만 유효하다는 점에서 제한적입니다.
         문자열의 끝입니다. 와일드카드 문자는 다른 곳에서 사용할 수 없습니다.
         문자열의 위치.

      지정된 버전의 레시피를 사용할 수 없는 경우 경고 메시지가 표시됩니다.
      메시지가 표시됩니다. 이 기능을 원하시면 `REQUIRED_VERSION`을 참조하세요.
      오류가 되는 것입니다.

### `PREMIRRORS`

      BitBake가 소스 코드를 가져오는 추가 경로를 지정합니다.
      빌드 시스템은 소스 코드를 찾을 때 먼저 로컬 저장소를 시도합니다.
      다운로드 디렉토리입니다. 해당 위치에서 오류가 발생하면 빌드 시스템은 다른 위치를 시도합니다.
      `PREMIRRORS`로 정의된 위치, 상위 소스, 그리고
      `MIRRORS`로 지정된 위치들이 해당 순서대로 나타납니다.

      일반적으로 빌드 시스템을 위해 특정 서버를 추가합니다.
      다른 시도보다 먼저 다음과 같은 내용을 추가하여 시도해 보세요.
      사용자 설정::

         PREMIRRORS:prepend = "\
         git://.*/.* http://downloads.yoctoproject.org/mirror/sources/ \
         ftp://.*/.* http://downloads.yoctoproject.org/mirror/sources/ \
         http://.*/.* http://downloads.yoctoproject.org/mirror/sources/ \
         https://.*/.* http://downloads.yoctoproject.org/mirror/sources/"

      이러한 변경 사항으로 인해 빌드 시스템은 Git, FTP, HTTP 등을 가로채게 됩니다.
      HTTPS 요청을 ``http://`` 소스 미러로 리디렉션합니다.
      로컬 디렉터리 또는 네트워크 공유를 가리키도록 하려면 ``file://`` URL을 사용하십시오.
      잘.

### `PROVIDES`

      특정 레시피를 알 수 있는 별칭 목록입니다.
      기본적으로 레시피 자체의 `PN`은 이미 암묵적으로 포함되어 있습니다.
      `PROVIDES` 목록. 레시피에서 `PROVIDES`를 사용하는 경우, 추가 정보가 표시됩니다.
      별칭은 레시피의 동의어이며, 만족감을 주는 데 유용할 수 있습니다.
      빌드 중 다른 레시피의 종속성은 지정된 대로 적용됩니다.
      `의존적입니다`.

      레시피의 `PROVIDES` 문을 예로 들어 보겠습니다.
      파일 ``libav_0.8.11.bb``::

         PROVIDES += "libpostproc"

      ``PROVIDES` 문을 사용하면 "libav" 레시피도 알려지게 됩니다.
      "libpostproc"으로.

      다른 이름으로 레시피를 제공하는 것 외에도,
      `PROVIDES` 메커니즘은 가상 대상을 구현하는 데에도 사용됩니다.
      가상 대상은 특정 대상에 대응하는 이름입니다.
      기능(예: 리눅스 커널). 해당 기능을 제공하는 레시피
      해당 기능은 `PROVIDES`에 가상 대상을 나열합니다.
      해당 기능에 의존하는 레시피에는 다음이 포함될 수 있습니다.
      `DEPENDS`의 가상 대상을 남겨두려면
      서비스 제공업체 선택은 자유롭습니다.

      일반적으로 가상 대상은 양식에 이름이 지정됩니다.
      "가상/함수"(예: "가상/커널"). 슬래시는 단순히 일부입니다.
      이름의 의미일 뿐이며 구문론적 의미는 없습니다.

### `PRSERV_HOST`

      네트워크 기반 `PR` 서비스 호스트 및 포트입니다.

      다음은 `PRSERV_HOST` 변수를 설정하는 방법의 예입니다.

         PRSERV_HOST = "localhost:0"

      로컬 PR을 자동으로 시작하려면 해당 변수를 설정해야 합니다.
      서비스를 사용하려면 `PRSERV_HOST` 값을 다른 값으로 설정하여 원격 PR을 사용할 수 있습니다.
      서비스.

### `PV`

      레시피 버전입니다.

### `RDEPENDS`

      패키지의 런타임 종속성(즉, 다른 패키지) 목록을 표시합니다.
      빌드된 패키지가 올바르게 실행되려면 해당 패키지가 설치되어 있어야 합니다.
      빌드 중에 이 목록에 있는 패키지를 찾을 수 없으면 다음과 같은 오류가 발생합니다.
      빌드 오류입니다.

      `RDEPENDS` 변수는 빌드 중인 패키지에 적용되기 때문에,
      변수를 사용할 때는 항상 패키지가 첨부된 형태로 사용해야 합니다.
      이름. 예를 들어, 개발 패키지를 빌드한다고 가정해 보겠습니다.
      이는 `perl` 패키지에 따라 다릅니다. 이 경우 다음과 같이 사용합니다.
      다음 `RDEPENDS` 문::

         RDEPENDS:${PN}-dev += "perl"

      예시에서 개발 패키지는 ``perl`` 패키지에 의존합니다.
      따라서 `RDEPENDS` 변수에는 ``${PN}-dev`` 패키지 이름이 포함됩니다.
      변수의.

      BitBake는 버전이 지정된 종속성을 지정하는 기능을 지원합니다.
      구문은 패키징 형식에 따라 다르며, BitBake는 이러한 부분을 숨깁니다.
      당신과의 차이점을 알려드립니다. 버전 지정을 위한 일반적인 구문은 다음과 같습니다.
      `RDEPENDS` 변수를 사용하면::

         RDEPENDS:${PN} = "패키지(운영자 버전)"

      `operator`의 경우 다음과 같이 지정할 수 있습니다.

         =
         <
         >
         <=
         >=
예를 들어, 다음은 버전 1.2
      에 대한 종속성을 설정합니다 .
      패키지 `foo`의 더 큰 부분::

         RDEPENDS:${PN} = "foo (>= 1.2)"

      빌드 시 종속성에 대한 자세한 내용은 `DEPENDS`를 참조하십시오.
      변하기 쉬운.

### `REPODIR`

      `google-repo` 디렉터리의 로컬 복사본이 있는 디렉터리입니다.
      동기화될 때 저장됩니다.

### `REQUIRED_VERSION`

      레시피에 여러 버전이 있는 경우 이 변수
      어떤 버전을 우선시할지 결정합니다. `필수_버전`
      `PREFERRED_VERSION`과 완전히 동일한 방식으로 작동하지만, 몇 가지 예외 사항이 있습니다.
      지정된 버전을 사용할 수 없는 경우 오류 메시지가 표시됩니다.
      해당 메시지가 표시되고 빌드가 즉시 실패합니다.

      `REQUIRED_VERSION`과 `PREFERRED_VERSION`이 모두 설정된 경우
      동일한 레시피의 경우, `REQUIRED_VERSION` 값이 적용됩니다.

### `RPROVIDES`

      패키지가 제공하는 패키지 이름 별칭 목록입니다.
      별칭은 다른 항목의 런타임 종속성을 충족하는 데 유용합니다.
      빌드 과정과 대상 시스템 모두에서 패키지를 사용합니다(지정된 대로).
      `RDEPENDS`).

      다른 모든 패키지 제어 변수와 마찬가지로 항상 다음을 사용해야 합니다.
      패키지 이름 재정의와 함께 변수를 사용합니다. 다음은 그 예입니다.
      예::

         RPROVIDES:${PN} = "widget-abi-2"

### `RRECOMMENDS`

      패키지의 활용도를 확장하는 패키지 목록
      빌드가 완료되었습니다. 빌드 중인 패키지는 이 목록에 있는 항목에 의존하지 않습니다.
      성공적인 빌드를 위해서는 패키지가 필요하지만, 해당 패키지는 다른 용도로도 필요합니다.
      사용성이 향상되었습니다. 패키지의 런타임 종속성을 지정하려면 다음을 참조하세요.
      `RDEPENDS` 변수.

      BitBake는 버전이 지정된 권장 사항을 지정하는 기능을 지원합니다. 구문은 다소 복잡하지만요.
      포장 형식에 따라 다르며, BitBake는 이러한 내용을 숨깁니다.
      당신과의 차이점을 알려드립니다. 버전 지정을 위한 일반적인 구문은 다음과 같습니다.
      `RRECOMMENDS` 변수를 사용하면::

         권장 사항:${PN} = "패키지(운영자 버전)"

      `operator`의 경우 다음과 같이 지정할 수 있습니다.

         =
         <
         >
         <=
         >=

      예를 들어, 다음은 특정 버전에 대한 권장 사항을 설정합니다.
      `foo` 패키지의 1.2 이상 버전::

         권장 사항:${PN} = "foo (>= 1.2)"

### `SECTION`

      패키지를 분류해야 하는 섹션입니다.

### `SRC_URI`

      소스 파일 목록(로컬 또는 원격). 이 변수는 다음을 알려줍니다.
      BitBake에서 빌드에 필요한 비트를 선택하는 방법과 그 방법을 안내합니다.
      예를 들어, 레시피나 추가 파일에서 단일 tarball을 가져와야 하는 경우
      인터넷에서 가져온 레시피 또는 추가 파일은 `SRC_URI`를 사용합니다.
      해당 tarball을 지정하는 항목입니다. 반면에 레시피 또는
      파일을 추가하려면 tarball을 가져오고, 두 개의 패치를 적용하고, 포함해야 합니다.
      사용자 지정 파일, 레시피 또는 추가 파일에는 `SRC_URI`가 필요합니다.
      모든 소스를 지정하는 변수입니다.

      다음 목록은 사용 가능한 URI 프로토콜을 설명합니다. URI
      프로토콜은 특정 BitBake Fetcher에 크게 의존합니다.
      서브모듈. BitBake에서 사용하는 페처에 따라 다양한 URL이 사용됩니다.
      매개변수가 사용됩니다. 지원되는 Fetcher에 대한 자세한 내용은 다음을 참조하십시오.
      :ref:`bitbake-user-manual/bitbake-user-manual-fetching:fetchers`
      부분.

      - ``az://``: HTTPS를 사용하여 Azure Storage 계정에서 파일을 가져옵니다.

      - ``bzr://``: Bazaar 버전 관리 시스템에서 파일을 가져옵니다.
         저장소.

      - ``ccrc://``: ClearCase 저장소에서 파일을 가져옵니다.

      - ``cvs://``: CVS 버전 관리 시스템에서 파일을 가져옵니다.
         저장소.

      - ``file://``: 일반적으로 전송되는 파일인 파일을 가져옵니다.
         로컬 컴퓨터의 메타데이터를 사용합니다.
         경로는 `FILESPATH`를 기준으로 합니다.
         변수입니다. 따라서 빌드 시스템은 순서대로 검색합니다.
         다음 디렉터리들은 하위 디렉터리로 간주됩니다.
         레시피 파일(``.bb``) 또는 추가 파일이 있는 디렉토리
         (``.bbappend``) 위치:

         - ``${BPN}``: 특별한 접미사 없이 기본 레시피 이름입니다.
            또는 버전 번호.

         - ``${BP}`` - ``${BPN}-${PV}``: 기본 레시피 이름 및
            특별한 패키지 이름 접미사가 없는 버전입니다.

         - ``files``: ``files``라는 이름의 디렉터리 내의 파일들
            또한 레시피 또는 추가 파일과 함께 있습니다.

      - ``ftp://``: FTP를 사용하여 인터넷에서 파일을 가져옵니다.

      - ``git://``: Git 리비전 관리 시스템에서 파일을 가져옵니다.
         저장소.

      - ``gitsm://``: Git 리비전 관리에서 서브모듈을 가져옵니다.
         저장소.

      - ``hg://``: Mercurial(``hg``) 리비전에서 파일을 가져옵니다.
         제어 저장소.

      - ``http://``: HTTP를 사용하여 인터넷에서 파일을 가져옵니다.

      - ``https://``: HTTPS를 사용하여 인터넷에서 파일을 가져옵니다.

      - ``npm://``: 레지스트리에서 JavaScript 모듈을 가져옵니다.

      - ``osc://``: OSC(OpenSUSE 빌드 서비스)에서 파일을 가져옵니다.
         버전 관리 저장소.

      - ``p4://``: Perforce(``p4``) 리비전에서 파일을 가져옵니다.
         제어 저장소.

      - ``repo://``: 리포지토리(Git)에서 파일을 가져옵니다.

      - ``ssh://``: 보안 셸에서 파일을 가져옵니다.

      - ``svn://``: Subversion(``svn``) 리비전에서 파일을 가져옵니다.
         제어 저장소.

      다음은 언급할 만한 몇 가지 추가 옵션입니다.

      - ``downloadfilename``: 저장할 때 사용할 파일 이름을 지정합니다.
         다운로드된 파일.

      - ``이름``: 연관 관계에 사용할 이름을 지정합니다.
         SRC_URI 체크섬 또는 SRCREV가 두 개 이상인 경우 `SRC_URI` 체크섬 또는 `SRCREV`를 사용합니다.
         `SRC_URI`에 지정된 파일 또는 소스 제어 저장소입니다.
         예를 들어::

            SRC_URI = "git://example.com/foo.git;branch=main;name=first \
                       git://example.com/bar.git;branch=main;name=second \
                       http://example.com/file.tar.gz;name=third"

            SRCREV_first = "f1d2d2f924e986ac86fdf7b36c94bcdf32beec15"
            SRCREV_second = "e242ed3bffccdf271b7fbaf34ed72d089537b42f"
            SRC_URI[third.sha256sum] = "13550350a8681c84c861aac2e5b440161c2b33a3e4f302ac680ca5b686de48de"

      - ``subdir``: 파일을 (또는 파일 내용을) 다음 디렉터리에 배치합니다.
         지정된 하위 디렉터리입니다. 이 옵션은 특이한 tarball에 유용합니다.
         또는 파일이 이미 저장되어 있지 않은 다른 아카이브
         아카이브 내의 하위 디렉토리입니다. 이 경로는 추가로 수정할 수 있습니다.
         페처별 매개변수에 따라.

      - ``하위 경로``: 체크아웃을 특정 하위 경로로 제한합니다.
         Git 페처를 사용할 때 트리 구조가 사용됩니다.

      - ``unpack``: 파일이 압축 해제되지 않은 경우 압축 해제 여부를 제어합니다.
         아카이브입니다. 기본 동작은 파일 압축 해제입니다.

### `SRCDATE`

      패키지를 빌드하는 데 사용된 소스 코드의 날짜입니다. 이 변수는
      소스 코드가 소스 코드 관리자를 통해 가져온 경우에만 적용됩니다.
      (SCM).

### `SRCREV`

      패키지 빌드에 사용된 소스 코드의 수정 버전입니다.
      이 변수는 Subversion, Git, Mercurial을 사용할 때만 적용됩니다.
      바자회. 고정된 버전을 만들고 싶고 피하고 싶다면
      BitBake가 파싱할 때마다 원격 저장소에 대한 쿼리를 수행합니다.
      레시피를 작성할 때는 전체 수정 버전을 나타내는 `SRCREV`라는 용어를 지정해야 합니다.
      단순한 태그가 아닌 식별자입니다.

### `SRCREV_FORMAT`

      유효한 패키지 버전 문자열을 구성하는 데 도움이 됩니다.
      여러 개의 소스 제어 URL이 사용됩니다.
      `SRC_URI`.

      이 시스템은 다음 조건에서 해당 값을 구성하는 데 도움이 필요합니다.
      상황에 따라 다릅니다. `SRC_URI`의 각 구성 요소에는 이름이 할당됩니다.
      그리고 이것들은 `SRCREV_FORMAT` 변수에서 참조됩니다. 다음을 고려해 보세요.
      "machine"과 "meta"라는 이름의 URL을 사용한 예시입니다. 이 경우,
      `SRCREV_FORMAT`은 "machine_meta"와 같은 이름일 수 있습니다.
      각 위치에 SCM 버전이 대체될 것입니다. 단 하나만
      ``AUTOINC`` 플레이스홀더가 필요시 추가됩니다. 그리고 이 플레이스홀더는
      반환된 문자열의 시작 부분에 배치됩니다.

      `SRCREV_FORMAT`는 "_component2" 형식도 취할 수 있습니다.
      이는 `SRC_URI`에 구성 요소가 있는데, 그 구성 요소가 그렇지 않다고 가정합니다.
      이름을 지정하는 것은 바람직하지 않지만, 그렇게 할 수도 있습니다.
      ``.bbappend`` 파일이 `SRC_URI`를 확장해야 하는 경우 유용합니다.
      추가 저장소.

### `STAMP`

      레시피 스탬프 파일을 생성하는 데 사용되는 기본 경로를 지정합니다. 경로
      실제 우표 파일로 변환하는 과정은 이 문자열을 평가하여 수행됩니다.
      그다음 추가 정보를 덧붙입니다.

### `STAMPCLEAN`

      레시피 스탬프 파일을 생성하는 데 사용되는 기본 경로를 지정합니다.
      `STAMP` 변수, `STAMPCLEAN`에는 다음이 포함될 수 있습니다.
      정리 작업에 필요한 파일 범위와 일치하도록 와일드카드를 사용합니다.
      제거합니다. BitBake는 정리 작업을 사용하여 다른 스탬프를 모두 제거합니다.
      새로운 스탬프를 만들 때 제거해야 합니다.

### `SUMMARY`

      레시피에 대한 간략한 요약 (72자 이내).

### `SVNDIR`

      서브버전 시스템에서 체크아웃한 파일이 저장되는 디렉터리는 다음과 같습니다.
      저장됨.

### `T`

      BitBake가 임시 파일을 저장하는 디렉터리를 가리킵니다.
      특정 빌드를 수행할 때 주로 작업 로그와 스크립트로 구성됩니다.
      레시피.

### `TOPDIR`

      빌드 디렉토리를 가리킵니다. BitBake는 이 값을 자동으로 설정합니다.
      변하기 쉬운.
