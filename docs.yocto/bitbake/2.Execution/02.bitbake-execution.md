# BitBake 실행 (Execution)

BitBake의 실행 과정은 단순히 명령어를 순차적으로 수행하는 것이 아니라, 방대한 메타데이터를 파싱하고 복잡한 의존성을 해결하여 최적의 빌드 순서를 결정하는 정교한 프로세스입니다.

## 2.1 기본 설정 메타데이터 파싱 (Parsing the Base Configuration Metadata)

BitBake가 실행되면 가장 먼저 빌드 환경을 구성하는 기본 설정 파일들을 읽어들입니다.

1.  **`bblayers.conf`**: 빌드 디렉토리의 `conf/bblayers.conf`를 읽어 활성화된 레이어 목록을 파악합니다.
2.  **`layer.conf`**: 각 레이어 디렉토리 내의 `conf/layer.conf`를 파싱하여 레이어별 설정을 로드하고, 레시피 경로(`BBFILES`)를 수집합니다.
3.  **`bitbake.conf`**: BitBake 자체의 기본 설정(대부분 `meta/conf/bitbake.conf`)을 읽어 전역 변수들의 기본값을 설정합니다.
4.  **`local.conf`**: 사용자가 정의한 `conf/local.conf`를 마지막으로 읽어 이전 설정들을 덮어쓰거나 추가 설정을 적용합니다.
5.  **`bitbake-cookerdaemon.log`**: 파싱 과정 중 발생하는 로그는 주로 이곳에 기록됩니다.

## 2.2 레시피 위치 파악 및 파싱 (Locating and Parsing Recipes)

설정 파싱이 끝나면 `BBFILES` 변수에 정의된 경로를 통해 모든 레시피(`.bb`)와 추가 파일(`.bbappend`)을 찾습니다.

- **파싱 캐시**: 수천 개의 레시피를 매번 파싱하는 것은 시간이 오래 걸리므로, BitBake는 파싱 결과를 캐시(Cache)에 저장하여 재사용합니다. 레시피가 변경된 경우에만 다시 파싱합니다.
- **데이터 저장소**: 각 레시피는 독립적인 데이터 저장소(Data Store) 환경을 가지며, 이곳에 변수와 태스크 함수들이 로드됩니다.

## 2.3 공급자 (Providers)

BitBake는 타겟 이름(예: `virtual/kernel`, `sh`)을 실제 레시피 파일과 연결하기 위해 **공급자(Provider)** 개념을 사용합니다.

- **`PROVIDES`**: 레시피는 자신이 제공하는 기능이나 이름을 `PROVIDES` 변수에 명시합니다. (기본적으로 패키지 이름 `PN`은 자동으로 제공됩니다.)
- **가상 공급자 (Virtual Providers)**: 여러 레시피가 동일한 기능을 제공할 때 사용합니다. 예를 들어, 여러 커널 레시피가 `virtual/kernel`을 제공할 수 있습니다.

## 2.4 선호도 (Preferences)

동일한 대상을 제공하는 레시피가 여러 개일 때(예: 여러 버전의 `bash` 또는 여러 커널), BitBake는 **선호도(Preferences)** 규칙에 따라 하나를 선택합니다.

- **`PREFERRED_PROVIDER`**: 특정 타겟에 대해 어떤 레시피를 사용할지 명시합니다. (예: `PREFERRED_PROVIDER_virtual/kernel = "linux-yocto"`)
- **`PREFERRED_VERSION`**: 특정 레시피의 버전을 지정합니다. (예: `PREFERRED_VERSION_python3 = "3.8%"`)
- 기본적으로는 가장 높은 버전이 선택됩니다.

## 2.5 의존성 (Dependencies)

빌드 순서를 결정하기 위해 의존성 그래프를 생성합니다.

- **빌드 의존성 (`DEPENDS`)**: 컴파일 시점에 필요한 라이브러리나 도구를 지정합니다. `do_configure` 태스크 실행 전에 해당 의존성들의 `do_populate_sysroot`가 완료되어야 함을 의미합니다.
- **런타임 의존성 (`RDEPENDS`)**: 타겟 장치에서 실행될 때 필요한 패키지입니다. 주로 패키징 단계(`do_package_write_*`)에서 처리됩니다.
- **태스크 간 의존성**: `addtask` 명령이나 `[depends]` 플래그를 통해 태스크 간의 선후 관계가 정의됩니다.

## 2.6 태스크 리스트 (The Task List)

의존성 분석이 완료되면, BitBake는 실행해야 할 모든 태스크의 목록(RunQueue)을 생성합니다.

- 사용자가 요청한 타겟(예: `bitbake core-image-minimal`)을 달성하기 위해 필요한 모든 하위 레시피와 그들의 태스크들이 포함됩니다.
- 불필요한 태스크는 제외되며, 이미 완료된 태스크(Stamp 파일 확인)도 실행 목록에서 제외될 수 있습니다.

## 2.7 태스크 실행 (Executing Tasks)

준비된 태스크 리스트를 바탕으로 실제 실행을 시작합니다.

- **병렬 실행**: `BB_NUMBER_THREADS` 변수에 설정된 수만큼 태스크를 병렬로 실행하여 빌드 속도를 높입니다.
- **Fakeroot/Pseudo**: `do_install`이나 `do_rootfs`와 같이 루트 권한이 필요한 태스크는 `fakeroot` 환경(Pseudo)에서 실행되어, 일반 사용자 권한으로도 올바른 파일 소유권과 권한을 설정할 수 있게 합니다.
- **샌드박스**: 각 태스크는 격리된 환경에서 실행되며, 명시적으로 지정된 변수와 경로에만 접근할 수 있습니다.

## 2.8 체크섬 (Checksums / Signatures)

BitBake는 태스크를 다시 실행해야 할지 결정하기 위해 **체크섬(Signature)**을 사용합니다.

- **입력값 해싱**: 태스크의 코드, 변수 값, 의존성 태스크의 체크섬 등을 모두 합쳐 고유한 해시값을 생성합니다.
- **변경 감지**: 설정이나 소스 코드가 변경되면 체크섬이 바뀌고, BitBake는 이를 감지하여 해당 태스크와 그에 의존하는 태스크들을 다시 실행합니다.
- `bitbake-dumpsig` 도구를 사용하여 체크섬 계산에 포함된 변수들을 확인할 수 있습니다.

## 2.9 셋씬 (Setscene) - Sstate Cache

**Setscene** 단계는 BitBake의 강력한 캐싱 메커니즘인 **Shared State (sstate) Cache**를 활용하는 단계입니다.

1.  태스크 실행 전, BitBake는 해당 태스크의 체크섬과 일치하는 캐시 아티팩트가 `SSTATE_DIR`에 존재하는지 확인합니다.
2.  **캐시 히트**: 만약 존재한다면, 태스크를 실제로 실행(컴파일 등)하는 대신 캐시된 결과물을 가져와서 설치합니다. 이를 통해 빌드 시간을 획기적으로 단축합니다.
3.  이 과정은 `do_populate_sysroot_setscene`, `do_package_write_rpm_setscene` 등의 형태로 나타납니다.

## 2.10 로깅 (Logging)

모든 태스크 실행 결과는 로그로 남습니다.

- **콘솔 출력**: 빌드 진행 상황, 경고, 에러 메시지가 터미널에 출력됩니다.
- **태스크 로그**: 각 태스크의 상세 로그는 해당 레시피의 작업 디렉토리(`WORKDIR/temp/`)에 `log.do_taskname` 형태로 저장됩니다. (예: `log.do_compile`)
- **심볼릭 링크**: 가장 최근 실행된 로그는 `log.do_compile`로, 이전 로그는 PID가 붙은 파일명으로 저장됩니다.
- **에러 분석**: 빌드 실패 시 BitBake는 해당 로그 파일의 경로를 알려주며, 이를 통해 구체적인 실패 원인을 파악할 수 있습니다.
